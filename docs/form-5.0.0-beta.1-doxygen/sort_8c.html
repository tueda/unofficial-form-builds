<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FORM: sort.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FORM
   &#160;<span id="projectnumber">5.0.0-beta.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_08d237fc27d4ecd563f71c5d52f2fecc.html">sources</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">sort.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="form3_8h_source.html">form3.h</a>&quot;</code><br />
</div>
<p><a href="sort_8c_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a3cec6a8469c5202341e4ec3cd5b5158f"><td class="memItemLeft" align="right" valign="top"><a id="a3cec6a8469c5202341e4ec3cd5b5158f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NEWSPLITMERGE</b></td></tr>
<tr class="separator:a3cec6a8469c5202341e4ec3cd5b5158f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb15c27bdc04b9176743f65d1ff3fd39"><td class="memItemLeft" align="right" valign="top"><a id="afb15c27bdc04b9176743f65d1ff3fd39"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>INSLENGTH</b>(x)&#160;&#160;&#160;w[1] = FUNHEAD+ARGHEAD+x; w[FUNHEAD] = ARGHEAD+x;</td></tr>
<tr class="separator:afb15c27bdc04b9176743f65d1ff3fd39"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac9d4907e604906152f2561e123434519"><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sort_8c.html#ac9d4907e604906152f2561e123434519">WriteStats</a> (<a class="el" href="structPoSiTiOn.html">POSITION</a> *plspace, WORD par)</td></tr>
<tr class="separator:ac9d4907e604906152f2561e123434519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a6fb48e7021f221c53df558baee3bc"><td class="memItemLeft" align="right" valign="top">WORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sort_8c.html#a41a6fb48e7021f221c53df558baee3bc">NewSort</a> (PHEAD0)</td></tr>
<tr class="separator:a41a6fb48e7021f221c53df558baee3bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e9216c6a29ab7719f0d37cb2b51d361"><td class="memItemLeft" align="right" valign="top">LONG&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sort_8c.html#a2e9216c6a29ab7719f0d37cb2b51d361">EndSort</a> (PHEAD WORD *buffer, int par)</td></tr>
<tr class="separator:a2e9216c6a29ab7719f0d37cb2b51d361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c7178b3e8a23956c3f252af74948681"><td class="memItemLeft" align="right" valign="top">LONG&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sort_8c.html#a0c7178b3e8a23956c3f252af74948681">PutIn</a> (<a class="el" href="structs_8h.html#a36b8571cff77310201b5cf441466ba83">FILEHANDLE</a> *file, <a class="el" href="structPoSiTiOn.html">POSITION</a> *position, WORD *buffer, WORD **take, int npat)</td></tr>
<tr class="separator:a0c7178b3e8a23956c3f252af74948681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0b32dbf3df6772a6e730c26863a97e"><td class="memItemLeft" align="right" valign="top">WORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sort_8c.html#a1c0b32dbf3df6772a6e730c26863a97e">Sflush</a> (<a class="el" href="structs_8h.html#a36b8571cff77310201b5cf441466ba83">FILEHANDLE</a> *fi)</td></tr>
<tr class="separator:a1c0b32dbf3df6772a6e730c26863a97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911e7252a3311fdd541e91d7a874b56b"><td class="memItemLeft" align="right" valign="top">WORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sort_8c.html#a911e7252a3311fdd541e91d7a874b56b">PutOut</a> (PHEAD WORD *term, <a class="el" href="structPoSiTiOn.html">POSITION</a> *position, <a class="el" href="structs_8h.html#a36b8571cff77310201b5cf441466ba83">FILEHANDLE</a> *fi, WORD ncomp)</td></tr>
<tr class="separator:a911e7252a3311fdd541e91d7a874b56b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fbe76f255d33036140255457662930e"><td class="memItemLeft" align="right" valign="top">WORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sort_8c.html#a2fbe76f255d33036140255457662930e">FlushOut</a> (<a class="el" href="structPoSiTiOn.html">POSITION</a> *position, <a class="el" href="structs_8h.html#a36b8571cff77310201b5cf441466ba83">FILEHANDLE</a> *fi, int compr)</td></tr>
<tr class="separator:a2fbe76f255d33036140255457662930e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b20d2b5a97d8aeccd497d1adaa8302"><td class="memItemLeft" align="right" valign="top">WORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sort_8c.html#ae0b20d2b5a97d8aeccd497d1adaa8302">AddCoef</a> (PHEAD WORD **ps1, WORD **ps2)</td></tr>
<tr class="separator:ae0b20d2b5a97d8aeccd497d1adaa8302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7171afcad3c9f5f529eaa94ba6175c2a"><td class="memItemLeft" align="right" valign="top">WORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sort_8c.html#a7171afcad3c9f5f529eaa94ba6175c2a">AddPoly</a> (PHEAD WORD **ps1, WORD **ps2)</td></tr>
<tr class="separator:a7171afcad3c9f5f529eaa94ba6175c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae36114ce5e26fea98876b640b3609cbf"><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sort_8c.html#ae36114ce5e26fea98876b640b3609cbf">AddArgs</a> (PHEAD WORD *s1, WORD *s2, WORD *m)</td></tr>
<tr class="separator:ae36114ce5e26fea98876b640b3609cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2be00b4e77fb9aadece75551388fd07a"><td class="memItemLeft" align="right" valign="top">WORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sort_8c.html#a2be00b4e77fb9aadece75551388fd07a">Compare1</a> (PHEAD WORD *term1, WORD *term2, WORD level)</td></tr>
<tr class="separator:a2be00b4e77fb9aadece75551388fd07a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa36a4ad93dbde449e658716c583b5bab"><td class="memItemLeft" align="right" valign="top">WORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sort_8c.html#aa36a4ad93dbde449e658716c583b5bab">CompareSymbols</a> (PHEAD WORD *term1, WORD *term2, WORD par)</td></tr>
<tr class="separator:aa36a4ad93dbde449e658716c583b5bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fa16944756ec68a21da7fa95b92a5a8"><td class="memItemLeft" align="right" valign="top">WORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sort_8c.html#a5fa16944756ec68a21da7fa95b92a5a8">CompareHSymbols</a> (PHEAD WORD *term1, WORD *term2, WORD par)</td></tr>
<tr class="separator:a5fa16944756ec68a21da7fa95b92a5a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e8fbe2d8d79e21021a924fa30e5d65"><td class="memItemLeft" align="right" valign="top">LONG&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sort_8c.html#a77e8fbe2d8d79e21021a924fa30e5d65">ComPress</a> (WORD **ss, LONG *n)</td></tr>
<tr class="separator:a77e8fbe2d8d79e21021a924fa30e5d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1406ab273f5f7b7dfed046e1b243bb1e"><td class="memItemLeft" align="right" valign="top">LONG&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sort_8c.html#a1406ab273f5f7b7dfed046e1b243bb1e">SplitMerge</a> (PHEAD WORD **Pointer, LONG number)</td></tr>
<tr class="separator:a1406ab273f5f7b7dfed046e1b243bb1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ede99980b98cbd35000b39e0395a36a"><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sort_8c.html#a7ede99980b98cbd35000b39e0395a36a">GarbHand</a> (VOID)</td></tr>
<tr class="separator:a7ede99980b98cbd35000b39e0395a36a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a670aa98242104557b1bbbb5368cafe8e"><td class="memItemLeft" align="right" valign="top">WORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sort_8c.html#a670aa98242104557b1bbbb5368cafe8e">MergePatches</a> (WORD par)</td></tr>
<tr class="separator:a670aa98242104557b1bbbb5368cafe8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6848642c1c54636cc54fbcec683607f5"><td class="memItemLeft" align="right" valign="top">WORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sort_8c.html#a6848642c1c54636cc54fbcec683607f5">StoreTerm</a> (PHEAD WORD *term)</td></tr>
<tr class="separator:a6848642c1c54636cc54fbcec683607f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad756bbef980a939c623c0f93c390e585"><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sort_8c.html#ad756bbef980a939c623c0f93c390e585">StageSort</a> (<a class="el" href="structs_8h.html#a36b8571cff77310201b5cf441466ba83">FILEHANDLE</a> *fout)</td></tr>
<tr class="separator:ad756bbef980a939c623c0f93c390e585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d9949d945319a088d33b5969925e08"><td class="memItemLeft" align="right" valign="top">WORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sort_8c.html#a30d9949d945319a088d33b5969925e08">SortWild</a> (WORD *w, WORD nw)</td></tr>
<tr class="separator:a30d9949d945319a088d33b5969925e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0bf76b7c13a32df1744703bb5585270"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sort_8c.html#ab0bf76b7c13a32df1744703bb5585270">CleanUpSort</a> (int num)</td></tr>
<tr class="separator:ab0bf76b7c13a32df1744703bb5585270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae08e5ed1367868f7338f16f0b5d6b412"><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sort_8c.html#ae08e5ed1367868f7338f16f0b5d6b412">LowerSortLevel</a> (VOID)</td></tr>
<tr class="separator:ae08e5ed1367868f7338f16f0b5d6b412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcefbaa2c1fb9737e4b48e0cef405501"><td class="memItemLeft" align="right" valign="top"><a id="adcefbaa2c1fb9737e4b48e0cef405501"></a>
WORD *&#160;</td><td class="memItemRight" valign="bottom"><b>PolyRatFunSpecial</b> (PHEAD WORD *t1, WORD *t2)</td></tr>
<tr class="separator:adcefbaa2c1fb9737e4b48e0cef405501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd1324d7abcddae4c55ae2651aee0d3"><td class="memItemLeft" align="right" valign="top"><a id="a7cd1324d7abcddae4c55ae2651aee0d3"></a>
VOID&#160;</td><td class="memItemRight" valign="bottom"><b>SimpleSplitMergeRec</b> (WORD *array, WORD num, WORD *auxarray)</td></tr>
<tr class="separator:a7cd1324d7abcddae4c55ae2651aee0d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08c64a399cf290022052f7cf895d2481"><td class="memItemLeft" align="right" valign="top"><a id="a08c64a399cf290022052f7cf895d2481"></a>
VOID&#160;</td><td class="memItemRight" valign="bottom"><b>SimpleSplitMerge</b> (WORD *array, WORD num)</td></tr>
<tr class="separator:a08c64a399cf290022052f7cf895d2481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42357c67932cd6af49574ce9c0739d44"><td class="memItemLeft" align="right" valign="top"><a id="a42357c67932cd6af49574ce9c0739d44"></a>
WORD&#160;</td><td class="memItemRight" valign="bottom"><b>BinarySearch</b> (WORD *array, WORD num, WORD x)</td></tr>
<tr class="separator:a42357c67932cd6af49574ce9c0739d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ad8d9b43e3006411637608918d171ed05"><td class="memItemLeft" align="right" valign="top"><a id="ad8d9b43e3006411637608918d171ed05"></a>
LONG&#160;</td><td class="memItemRight" valign="bottom"><b>numcompares</b></td></tr>
<tr class="separator:ad8d9b43e3006411637608918d171ed05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1173f5fb8610bfebbfa81d95727790"><td class="memItemLeft" align="right" valign="top"><a id="abc1173f5fb8610bfebbfa81d95727790"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>toterms</b> [] = { &quot; &quot;, &quot; &gt;&gt;&quot;, &quot;--&gt;&quot; }</td></tr>
<tr class="separator:abc1173f5fb8610bfebbfa81d95727790"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains the sort routines. We distinguish levels of sorting. The ground level is the sorting of terms in an expression. When a term has functions, the arguments can contain terms that need sorting, which this then done by raising the level. This can happen recursively. NewSort and EndSort automatically raise and lower the level. Because the ground level does some special things, sometimes we have to raise immediately to the second level skipping the ground level.</p>
<p>Special routines for the parallel sorting are in the file <a class="el" href="threads_8c.html">threads.c</a> Also the sorting of terms in polynomials is special but most of that is controled by changing the address of the compare routine. Other routines relevant for adding rational polynomials are in the file polynito.c </p>

<p class="definition">Definition in file <a class="el" href="sort_8c_source.html">sort.c</a>.</p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ac9d4907e604906152f2561e123434519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9d4907e604906152f2561e123434519">&#9670;&nbsp;</a></span>WriteStats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID WriteStats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPoSiTiOn.html">POSITION</a> *&#160;</td>
          <td class="paramname"><em>plspace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WORD&#160;</td>
          <td class="paramname"><em>par</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes the statistics.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plspace</td><td>The size in bytes currently occupied </td></tr>
    <tr><td class="paramname">par</td><td>par = 0 after a splitmerge. par = 1 after merge to sortfile. par = 2 after the sort</td></tr>
  </table>
  </dd>
</dl>
<p>current expression is to be found in AR.CurExpr. terms are in S-&gt;TermsLeft. S-&gt;GenTerms. </p>

<p class="definition">Definition at line <a class="el" href="sort_8c_source.html#l00093">93</a> of file <a class="el" href="sort_8c_source.html">sort.c</a>.</p>

</div>
</div>
<a id="a41a6fb48e7021f221c53df558baee3bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41a6fb48e7021f221c53df558baee3bc">&#9670;&nbsp;</a></span>NewSort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WORD NewSort </td>
          <td>(</td>
          <td class="paramtype">PHEAD0&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starts a new sort. At the lowest level this is a 'main sort' with the struct according to the parameters in S0. At higher levels this is a sort for functions, subroutines or dollars. We prepare the arrays and structs.</p>
<dl class="section return"><dt>Returns</dt><dd>Regular convention (OK -&gt; 0) </dd></dl>

<p class="definition">Definition at line <a class="el" href="sort_8c_source.html#l00592">592</a> of file <a class="el" href="sort_8c_source.html">sort.c</a>.</p>

</div>
</div>
<a id="a2e9216c6a29ab7719f0d37cb2b51d361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e9216c6a29ab7719f0d37cb2b51d361">&#9670;&nbsp;</a></span>EndSort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LONG EndSort </td>
          <td>(</td>
          <td class="paramtype">PHEAD WORD *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>par</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finishes a sort. At AR.sLevel == 0 the output is to the regular output stream. When AR.sLevel &gt; 0, the parameter par determines the actual output. The AR.sLevel will be popped. All ongoing stages are finished and if the sortfile is open it is closed. The statistics are printed when AR.sLevel == 0 par == 0 <a class="el" href="classOutput.html">Output</a> to the buffer. par == 1 Sort for function arguments. The output will be copied into the buffer. It is assumed that this is in the WorkSpace. par == 2 Sort for $-variable. We return the address of the buffer that contains the output in buffer (treated like WORD **). We first catch the output in a file (unless we can intercept things after the small buffer has been sorted) Then we read from the file into a buffer. Only when par == 0 data compression can be attempted at AT.SS==AT.S0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>buffer for output when needed </td></tr>
    <tr><td class="paramname">par</td><td>See above </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If negative: error. If positive: number of words in output. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sort_8c_source.html#l00682">682</a> of file <a class="el" href="sort_8c_source.html">sort.c</a>.</p>

</div>
</div>
<a id="a0c7178b3e8a23956c3f252af74948681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c7178b3e8a23956c3f252af74948681">&#9670;&nbsp;</a></span>PutIn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LONG PutIn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structs_8h.html#a36b8571cff77310201b5cf441466ba83">FILEHANDLE</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPoSiTiOn.html">POSITION</a> *&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WORD *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WORD **&#160;</td>
          <td class="paramname"><em>take</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>npat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a new patch from position in file handle. It is put at buffer, anything after take is moved forward. This would be part of a term that hasn't been used yet. Because of this there should be some space before the start of the buffer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The file system from which to read </td></tr>
    <tr><td class="paramname">position</td><td>The position from which to read </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer into which to read </td></tr>
    <tr><td class="paramname">take</td><td>The unused tail should be moved before the buffer </td></tr>
    <tr><td class="paramname">npat</td><td>The number of the patch. Is needed if the information was compressed with gzip, because each patch has its own independent gzip encoding. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sort_8c_source.html#l01259">1259</a> of file <a class="el" href="sort_8c_source.html">sort.c</a>.</p>

</div>
</div>
<a id="a1c0b32dbf3df6772a6e730c26863a97e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c0b32dbf3df6772a6e730c26863a97e">&#9670;&nbsp;</a></span>Sflush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WORD Sflush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structs_8h.html#a36b8571cff77310201b5cf441466ba83">FILEHANDLE</a> *&#160;</td>
          <td class="paramname"><em>fi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Puts the contents of a buffer to output Only to be used when there is a single patch in the large buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fi</td><td>The filesystem (or its cache) to which the patch should be written </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sort_8c_source.html#l01319">1319</a> of file <a class="el" href="sort_8c_source.html">sort.c</a>.</p>

</div>
</div>
<a id="a911e7252a3311fdd541e91d7a874b56b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a911e7252a3311fdd541e91d7a874b56b">&#9670;&nbsp;</a></span>PutOut()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WORD PutOut </td>
          <td>(</td>
          <td class="paramtype">PHEAD WORD *&#160;</td>
          <td class="paramname"><em>term</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPoSiTiOn.html">POSITION</a> *&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structs_8h.html#a36b8571cff77310201b5cf441466ba83">FILEHANDLE</a> *&#160;</td>
          <td class="paramname"><em>fi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WORD&#160;</td>
          <td class="paramname"><em>ncomp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Routine writes one term to file handle at position. It returns the new value of the position.</p>
<p>NOTE: For 'final output' we may have to index the brackets. See the struct BRACKETINDEX. We should maintain: 1: a list with brackets array with the brackets 2: a list of objects of type BRACKETINDEX. It contains array with either pointers or offsets to the list of brackets. starting positions in the file. The index may be tied to a maximum size. In that case we may have to prune the list occasionally.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">term</td><td>The term to be written </td></tr>
    <tr><td class="paramname">position</td><td>The position in the file. Afterwards it is updated </td></tr>
    <tr><td class="paramname">fi</td><td>The file (or its cache) to which should be written </td></tr>
    <tr><td class="paramname">ncomp</td><td>Information about what type of compression should be used </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sort_8c_source.html#l01405">1405</a> of file <a class="el" href="sort_8c_source.html">sort.c</a>.</p>

</div>
</div>
<a id="a2fbe76f255d33036140255457662930e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fbe76f255d33036140255457662930e">&#9670;&nbsp;</a></span>FlushOut()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WORD FlushOut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPoSiTiOn.html">POSITION</a> *&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structs_8h.html#a36b8571cff77310201b5cf441466ba83">FILEHANDLE</a> *&#160;</td>
          <td class="paramname"><em>fi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>compr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Completes output to an output file and writes the trailing zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The position in the file after writing </td></tr>
    <tr><td class="paramname">fi</td><td>The file (or its cache) </td></tr>
    <tr><td class="paramname">compr</td><td>Indicates whether there should be compression with gzip. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Regular conventions (OK -&gt; 0). </dd></dl>

<p class="definition">Definition at line <a class="el" href="sort_8c_source.html#l01767">1767</a> of file <a class="el" href="sort_8c_source.html">sort.c</a>.</p>

</div>
</div>
<a id="ae0b20d2b5a97d8aeccd497d1adaa8302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0b20d2b5a97d8aeccd497d1adaa8302">&#9670;&nbsp;</a></span>AddCoef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WORD AddCoef </td>
          <td>(</td>
          <td class="paramtype">PHEAD WORD **&#160;</td>
          <td class="paramname"><em>ps1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WORD **&#160;</td>
          <td class="paramname"><em>ps2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds the coefficients of the terms *ps1 and *ps2. The problem comes when there is not enough space for a new longer coefficient. First a local solution is tried. If this is not succesfull we need to move terms around. The possibility of a garbage collection should not be ignored, as avoiding this costs very much extra space which is nearly wasted otherwise.</p>
<p>If the return value is zero the terms cancelled.</p>
<p>The resulting term is left in *ps1. </p>

<p class="definition">Definition at line <a class="el" href="sort_8c_source.html#l01981">1981</a> of file <a class="el" href="sort_8c_source.html">sort.c</a>.</p>

</div>
</div>
<a id="a7171afcad3c9f5f529eaa94ba6175c2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7171afcad3c9f5f529eaa94ba6175c2a">&#9670;&nbsp;</a></span>AddPoly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WORD AddPoly </td>
          <td>(</td>
          <td class="paramtype">PHEAD WORD **&#160;</td>
          <td class="paramname"><em>ps1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WORD **&#160;</td>
          <td class="paramname"><em>ps2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Routine should be called when S-&gt;PolyWise != 0. It points then to the position of AR.PolyFun in both terms.</p>
<p>We add the contents of the arguments of the two polynomials. Special attention has to be given to special arguments. We have to reserve a space equal to the size of one term + the size of the argument of the other. The addition has to be done in this routine because not all objects are reentrant.</p>
<p>Newer addition (12-nov-2007). The PolyFun can have two arguments. In that case S-&gt;PolyFlag is 2 and we have to call the routine for adding rational polynomials. We have to be rather careful what happens with: The location of the output The order of the terms in the arguments At first we allow only univariate polynomials in the PolyFun. This restriction will be lifted a.s.a.p.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ps1</td><td>A pointer to the postion of the first term </td></tr>
    <tr><td class="paramname">ps2</td><td>A pointer to the postion of the second term </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If zero the terms cancel. Otherwise the new term is in *ps1. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sort_8c_source.html#l02110">2110</a> of file <a class="el" href="sort_8c_source.html">sort.c</a>.</p>

</div>
</div>
<a id="ae36114ce5e26fea98876b640b3609cbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae36114ce5e26fea98876b640b3609cbf">&#9670;&nbsp;</a></span>AddArgs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID AddArgs </td>
          <td>(</td>
          <td class="paramtype">PHEAD WORD *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WORD *&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WORD *&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds the arguments of two occurrences of the PolyFun. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>Pointer to the first occurrence. </td></tr>
    <tr><td class="paramname">s2</td><td>Pointer to the second occurrence. </td></tr>
    <tr><td class="paramname">m</td><td>Pointer to where the answer should be. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sort_8c_source.html#l02272">2272</a> of file <a class="el" href="sort_8c_source.html">sort.c</a>.</p>

</div>
</div>
<a id="a2be00b4e77fb9aadece75551388fd07a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2be00b4e77fb9aadece75551388fd07a">&#9670;&nbsp;</a></span>Compare1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WORD Compare1 </td>
          <td>(</td>
          <td class="paramtype">PHEAD WORD *&#160;</td>
          <td class="paramname"><em>term1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WORD *&#160;</td>
          <td class="paramname"><em>term2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WORD&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compares two terms. The answer is: 0 equal ( with exception of the coefficient if level == 0. ) &gt;0 term1 comes first. &lt;0 term2 comes first. Some special precautions may be needed to keep the CompCoef routine from generating overflows, although this is very unlikely in subterms. This routine should not return an error condition.</p>
<p>Originally this routine was called Compare. With the treatment of special polynomials with terms that contain only symbols and the need for extreme speed for the polynomial routines we made a special compare routine and now we store the address of the current compare routine in AR.CompareRoutine and have a macro Compare which makes all existing code work properly and we can just replace the routine on a thread by thread basis (each thread has its own AR struct).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">term1</td><td>First input term </td></tr>
    <tr><td class="paramname">term2</td><td>Second input term </td></tr>
    <tr><td class="paramname">level</td><td>The sorting level (may influence on the result) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 equal ( with exception of the coefficient if level == 0. ) &gt;0 term1 comes first. &lt;0 term2 comes first.</dd></dl>
<p>When there are floating point numbers active (float_ = FLOATFUN) the presence of one or more float_ functions is returned in AT.SortFloatMode: 0: no float_ 1: float_ in term1 only 2: float_ in term2 only 3: float_ in both terms </p>

<p class="definition">Definition at line <a class="el" href="sort_8c_source.html#l02565">2565</a> of file <a class="el" href="sort_8c_source.html">sort.c</a>.</p>

</div>
</div>
<a id="aa36a4ad93dbde449e658716c583b5bab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa36a4ad93dbde449e658716c583b5bab">&#9670;&nbsp;</a></span>CompareSymbols()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WORD CompareSymbols </td>
          <td>(</td>
          <td class="paramtype">PHEAD WORD *&#160;</td>
          <td class="paramname"><em>term1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WORD *&#160;</td>
          <td class="paramname"><em>term2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WORD&#160;</td>
          <td class="paramname"><em>par</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compares the terms, based on the value of AN.polysortflag. If term1 &lt; term2 the return value is -1 If term1 &gt; term2 the return value is 1 If term1 = term2 the return value is 0 The coefficients may differ. The terms contain only a single subterm of type SYMBOL. If AN.polysortflag = 0 it is a 'regular' compare. If AN.polysortflag = 1 the sum of the powers is more important par is a dummy parameter to make the parameter field identical to that of Compare1 which is the regular compare routine in <a class="el" href="sort_8c.html">sort.c</a> </p>

<p class="definition">Definition at line <a class="el" href="sort_8c_source.html#l03029">3029</a> of file <a class="el" href="sort_8c_source.html">sort.c</a>.</p>

</div>
</div>
<a id="a5fa16944756ec68a21da7fa95b92a5a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fa16944756ec68a21da7fa95b92a5a8">&#9670;&nbsp;</a></span>CompareHSymbols()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WORD CompareHSymbols </td>
          <td>(</td>
          <td class="paramtype">PHEAD WORD *&#160;</td>
          <td class="paramname"><em>term1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WORD *&#160;</td>
          <td class="paramname"><em>term2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WORD&#160;</td>
          <td class="paramname"><em>par</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compares terms that can have only SYMBOL and HAAKJE subterms. If term1 &lt; term2 the return value is -1 If term1 &gt; term2 the return value is 1 If term1 = term2 the return value is 0 par is a dummy parameter to make the parameter field identical to that of Compare1 which is the regular compare routine in <a class="el" href="sort_8c.html">sort.c</a> </p>

<p class="definition">Definition at line <a class="el" href="sort_8c_source.html#l03072">3072</a> of file <a class="el" href="sort_8c_source.html">sort.c</a>.</p>

</div>
</div>
<a id="a77e8fbe2d8d79e21021a924fa30e5d65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77e8fbe2d8d79e21021a924fa30e5d65">&#9670;&nbsp;</a></span>ComPress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LONG ComPress </td>
          <td>(</td>
          <td class="paramtype">WORD **&#160;</td>
          <td class="paramname"><em>ss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LONG *&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets a list of pointers to terms and compresses the terms. In n it collects the number of terms and the return value of the function is the space that is occupied.</p>
<p>We have to pay some special attention to the compression of terms with a PolyFun. This PolyFun should occur only straight before the coefficient, so we can use the same trick as for the coefficient to sabotage compression of this object (Replace in the history the function pointer by zero. This is safe, because terms that would be identical otherwise would have been added).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ss</td><td>Array of pointers to terms to be compressed. </td></tr>
    <tr><td class="paramname">n</td><td>Number of pointers in ss. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total number of words needed for the compressed result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sort_8c_source.html#l03125">3125</a> of file <a class="el" href="sort_8c_source.html">sort.c</a>.</p>

</div>
</div>
<a id="a1406ab273f5f7b7dfed046e1b243bb1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1406ab273f5f7b7dfed046e1b243bb1e">&#9670;&nbsp;</a></span>SplitMerge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LONG SplitMerge </td>
          <td>(</td>
          <td class="paramtype">PHEAD WORD **&#160;</td>
          <td class="paramname"><em>Pointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LONG&#160;</td>
          <td class="paramname"><em>number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Algorithm by J.A.M.Vermaseren (31-7-1988)</p>
<p>Note that AN.SplitScratch and AN.InScratch are used also in GarbHand</p>
<p>Merge sort in memory. The input is an array of pointers. Sorting is done recursively by dividing the array in two equal parts and calling SplitMerge for each. When the parts are small enough we can do the compare and take the appropriate action. An addition is that we look for 'runs'. Sequences that are already ordered. This happens a lot when there is very little action in a module. This made FORM faster by a few percent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Pointer</td><td>The array of pointers to the terms to be sorted. </td></tr>
    <tr><td class="paramname">number</td><td>The number of pointers in Pointer.</td></tr>
  </table>
  </dd>
</dl>
<p>The terms are supposed to be sitting in the small buffer and there is supposed to be an extension to this buffer for when there are two terms that should be added and the result takes more space than each of the original terms. The notation guarantees that the result never needs more space than the sum of the spaces of the original terms. </p>

<p class="definition">Definition at line <a class="el" href="sort_8c_source.html#l03291">3291</a> of file <a class="el" href="sort_8c_source.html">sort.c</a>.</p>

</div>
</div>
<a id="a7ede99980b98cbd35000b39e0395a36a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ede99980b98cbd35000b39e0395a36a">&#9670;&nbsp;</a></span>GarbHand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID GarbHand </td>
          <td>(</td>
          <td class="paramtype">VOID&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Garbage collection that takes place when the small extension is full and we need to place more terms there. When this is the case there are many holes in the small buffer and the whole can be compactified. The major complication is the buffer for SplitMerge. There are to options for temporary memory: 1: find some buffer that has enough space (maybe in the large buffer). 2: allocate a buffer. Give it back afterwards of course. If the small extension is properly dimensioned this routine should be called very rarely. Most of the time it will be called when the polyfun or polyratfun is active. </p>

<p class="definition">Definition at line <a class="el" href="sort_8c_source.html#l03513">3513</a> of file <a class="el" href="sort_8c_source.html">sort.c</a>.</p>

</div>
</div>
<a id="a670aa98242104557b1bbbb5368cafe8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a670aa98242104557b1bbbb5368cafe8e">&#9670;&nbsp;</a></span>MergePatches()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WORD MergePatches </td>
          <td>(</td>
          <td class="paramtype">WORD&#160;</td>
          <td class="paramname"><em>par</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The general merge routine. Can be used for the large buffer and the file merging. The array S-&gt;Patches tells where the patches start S-&gt;pStop tells where they end (has to be computed first). The end of a 'line to be merged' is indicated by a zero. If the end is reached without running into a zero or a term runs over the boundary of a patch it is a file merging operation and a new piece from the file is read in.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">par</td><td>If par == 0 the sort is for file -&gt; outputfile. If par == 1 the sort is for large buffer -&gt; sortfile. If par == 2 the sort is for large buffer -&gt; outputfile. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="sort_8c_source.html#l03628">3628</a> of file <a class="el" href="sort_8c_source.html">sort.c</a>.</p>

</div>
</div>
<a id="a6848642c1c54636cc54fbcec683607f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6848642c1c54636cc54fbcec683607f5">&#9670;&nbsp;</a></span>StoreTerm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WORD StoreTerm </td>
          <td>(</td>
          <td class="paramtype">PHEAD WORD *&#160;</td>
          <td class="paramname"><em>term</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The central routine to accept terms, store them and keep things at least partially sorted. A call to EndSort will then complete storing and sorting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">term</td><td>The term to be stored </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Regular return conventions (OK -&gt; 0) </dd></dl>

<p class="definition">Definition at line <a class="el" href="sort_8c_source.html#l04394">4394</a> of file <a class="el" href="sort_8c_source.html">sort.c</a>.</p>

</div>
</div>
<a id="ad756bbef980a939c623c0f93c390e585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad756bbef980a939c623c0f93c390e585">&#9670;&nbsp;</a></span>StageSort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID StageSort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structs_8h.html#a36b8571cff77310201b5cf441466ba83">FILEHANDLE</a> *&#160;</td>
          <td class="paramname"><em>fout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prepares a stage 4 or higher sort. Stage 4 sorts occur when the sort file contains more patches than can be merged in one pass. </p>

<p class="definition">Definition at line <a class="el" href="sort_8c_source.html#l04514">4514</a> of file <a class="el" href="sort_8c_source.html">sort.c</a>.</p>

</div>
</div>
<a id="a30d9949d945319a088d33b5969925e08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30d9949d945319a088d33b5969925e08">&#9670;&nbsp;</a></span>SortWild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WORD SortWild </td>
          <td>(</td>
          <td class="paramtype">WORD *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WORD&#160;</td>
          <td class="paramname"><em>nw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sorts the wildcard entries in the parameter w. Double entries are removed. Full space taken is nw words. Routine serves for the reading of wildcards in the compiler. The entries come in the format: (type,4,number,0) in which the zero is reserved for the future replacement of 'number'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>buffer with wildcard entries. </td></tr>
    <tr><td class="paramname">nw</td><td>number of wildcard entries. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Normal conventions (OK -&gt; 0) </dd></dl>

<p class="definition">Definition at line <a class="el" href="sort_8c_source.html#l04613">4613</a> of file <a class="el" href="sort_8c_source.html">sort.c</a>.</p>

</div>
</div>
<a id="ab0bf76b7c13a32df1744703bb5585270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0bf76b7c13a32df1744703bb5585270">&#9670;&nbsp;</a></span>CleanUpSort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CleanUpSort </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Partially or completely frees function sort buffers. </p>

<p class="definition">Definition at line <a class="el" href="sort_8c_source.html#l04705">4705</a> of file <a class="el" href="sort_8c_source.html">sort.c</a>.</p>

</div>
</div>
<a id="ae08e5ed1367868f7338f16f0b5d6b412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae08e5ed1367868f7338f16f0b5d6b412">&#9670;&nbsp;</a></span>LowerSortLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LowerSortLevel </td>
          <td>(</td>
          <td class="paramtype">VOID&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lowers the level in the sort system. </p>

<p class="definition">Definition at line <a class="el" href="sort_8c_source.html#l04788">4788</a> of file <a class="el" href="sort_8c_source.html">sort.c</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
