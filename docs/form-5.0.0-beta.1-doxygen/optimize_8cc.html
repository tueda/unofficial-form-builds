<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FORM: optimize.cc File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FORM
   &#160;<span id="projectnumber">5.0.0-beta.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_08d237fc27d4ecd563f71c5d52f2fecc.html">sources</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">optimize.cc File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;vector&gt;</code><br />
<code>#include &lt;stack&gt;</code><br />
<code>#include &lt;algorithm&gt;</code><br />
<code>#include &lt;set&gt;</code><br />
<code>#include &lt;map&gt;</code><br />
<code>#include &lt;climits&gt;</code><br />
<code>#include &lt;cmath&gt;</code><br />
<code>#include &lt;string&gt;</code><br />
<code>#include &lt;iostream&gt;</code><br />
<code>#include &lt;tr1/unordered_map&gt;</code><br />
<code>#include &lt;tr1/unordered_set&gt;</code><br />
<code>#include &quot;<a class="el" href="form3_8h_source.html">form3.h</a>&quot;</code><br />
<code>#include &quot;mytime.h&quot;</code><br />
</div>
<p><a href="optimize_8cc_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree__node.html">tree_node</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCSEHash.html">CSEHash</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCSEEq.html">CSEEq</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnode.html">node</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNodeHash.html">NodeHash</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNodeEq.html">NodeEq</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoptimization.html">optimization</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:adcce2ad1d5c8ca216a02505517168316"><td class="memItemLeft" align="right" valign="top"><a id="adcce2ad1d5c8ca216a02505517168316"></a>
typedef struct <a class="el" href="structnode.html">node</a>&#160;</td><td class="memItemRight" valign="bottom"><b>NODE</b></td></tr>
<tr class="separator:adcce2ad1d5c8ca216a02505517168316"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa62d63886ab915072922b1f23b0851a7"><td class="memItemLeft" align="right" valign="top"><a id="aa62d63886ab915072922b1f23b0851a7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>print_instr</b> (const vector&lt; WORD &gt; &amp;instr, WORD num)</td></tr>
<tr class="separator:aa62d63886ab915072922b1f23b0851a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adefbae07efcb5278e0fed2653443eab3"><td class="memTemplParams" colspan="2">template&lt;class RandomAccessIterator &gt; </td></tr>
<tr class="memitem:adefbae07efcb5278e0fed2653443eab3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="optimize_8cc.html#adefbae07efcb5278e0fed2653443eab3">my_random_shuffle</a> (PHEAD RandomAccessIterator fr, RandomAccessIterator to)</td></tr>
<tr class="separator:adefbae07efcb5278e0fed2653443eab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcc71a308991ae8dc729fb69c6222cf8"><td class="memItemLeft" align="right" valign="top">LONG&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optimize_8cc.html#abcc71a308991ae8dc729fb69c6222cf8">get_expression</a> (int exprnr)</td></tr>
<tr class="separator:abcc71a308991ae8dc729fb69c6222cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adae1c48384d6b3d171c1b5e2bf2953d7"><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; WORD &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optimize_8cc.html#adae1c48384d6b3d171c1b5e2bf2953d7">get_brackets</a> ()</td></tr>
<tr class="separator:adae1c48384d6b3d171c1b5e2bf2953d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6021663b5861197cb619dfbf0b61c98f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optimize_8cc.html#a6021663b5861197cb619dfbf0b61c98f">count_operators</a> (const WORD *expr, bool print=false)</td></tr>
<tr class="separator:a6021663b5861197cb619dfbf0b61c98f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed4fa10a3e861decd68281769e77ded"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optimize_8cc.html#a6ed4fa10a3e861decd68281769e77ded">count_operators</a> (const vector&lt; WORD &gt; &amp;instr, bool print=false)</td></tr>
<tr class="separator:a6ed4fa10a3e861decd68281769e77ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab193934e627fad1810f2844c63ecb139"><td class="memItemLeft" align="right" valign="top">vector&lt; WORD &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optimize_8cc.html#ab193934e627fad1810f2844c63ecb139">occurrence_order</a> (const WORD *expr, bool rev)</td></tr>
<tr class="separator:ab193934e627fad1810f2844c63ecb139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0fd473fa3804ea755fca497f7d89f6a"><td class="memItemLeft" align="right" valign="top">WORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optimize_8cc.html#af0fd473fa3804ea755fca497f7d89f6a">getpower</a> (const WORD *term, int var, int pos)</td></tr>
<tr class="separator:af0fd473fa3804ea755fca497f7d89f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf3f8c95c8f6b3d1b06bedce470afe97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optimize_8cc.html#acf3f8c95c8f6b3d1b06bedce470afe97">fixarg</a> (UWORD *t, WORD &amp;n)</td></tr>
<tr class="separator:acf3f8c95c8f6b3d1b06bedce470afe97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d1608e0dd2f21122a5fac16bef8fc5"><td class="memItemLeft" align="right" valign="top"><a id="a05d1608e0dd2f21122a5fac16bef8fc5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>GcdLong_fix_args</b> (PHEAD UWORD *a, WORD na, UWORD *b, WORD nb, UWORD *c, WORD *nc)</td></tr>
<tr class="separator:a05d1608e0dd2f21122a5fac16bef8fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a313eb973f69c08d949385c53e19a2c7e"><td class="memItemLeft" align="right" valign="top"><a id="a313eb973f69c08d949385c53e19a2c7e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>DivLong_fix_args</b> (UWORD *a, WORD na, UWORD *b, WORD nb, UWORD *c, WORD *nc, UWORD *d, WORD *nd)</td></tr>
<tr class="separator:a313eb973f69c08d949385c53e19a2c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea6d5654ede742b4d4b9da416116f5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optimize_8cc.html#acea6d5654ede742b4d4b9da416116f5d">build_Horner_tree</a> (const WORD **terms, int numterms, int var, int maxvar, int pos, vector&lt; WORD &gt; *res)</td></tr>
<tr class="separator:acea6d5654ede742b4d4b9da416116f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add58d2f1e0422685a10f31a3a0a16b57"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optimize_8cc.html#add58d2f1e0422685a10f31a3a0a16b57">term_compare</a> (const WORD *a, const WORD *b)</td></tr>
<tr class="separator:add58d2f1e0422685a10f31a3a0a16b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a274a87bfb03189ac75814d90d5e68701"><td class="memItemLeft" align="right" valign="top">vector&lt; WORD &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optimize_8cc.html#a274a87bfb03189ac75814d90d5e68701">Horner_tree</a> (const WORD *expr, const vector&lt; WORD &gt; &amp;order)</td></tr>
<tr class="separator:a274a87bfb03189ac75814d90d5e68701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12c175d3af7d1212f5e4c44d9a2c125a"><td class="memItemLeft" align="right" valign="top"><a id="a12c175d3af7d1212f5e4c44d9a2c125a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>print_tree</b> (const vector&lt; WORD &gt; &amp;<a class="el" href="structtree.html">tree</a>)</td></tr>
<tr class="separator:a12c175d3af7d1212f5e4c44d9a2c125a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d40508034b7fabd464faefeed95fee"><td class="memTemplParams" colspan="2"><a id="ad2d40508034b7fabd464faefeed95fee"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad2d40508034b7fabd464faefeed95fee"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>hash_range</b> (T *array, int size)</td></tr>
<tr class="separator:ad2d40508034b7fabd464faefeed95fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d7b65dcb6f75e092976b87f6ffc13f5"><td class="memItemLeft" align="right" valign="top">vector&lt; WORD &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optimize_8cc.html#a2d7b65dcb6f75e092976b87f6ffc13f5">generate_instructions</a> (const vector&lt; WORD &gt; &amp;<a class="el" href="structtree.html">tree</a>, bool do_CSE)</td></tr>
<tr class="separator:a2d7b65dcb6f75e092976b87f6ffc13f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab9eca226619182e82960044cee4be4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optimize_8cc.html#abab9eca226619182e82960044cee4be4">count_operators_cse</a> (const vector&lt; WORD &gt; &amp;<a class="el" href="structtree.html">tree</a>)</td></tr>
<tr class="separator:abab9eca226619182e82960044cee4be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa80cf157ecf9fe6e0576f80448d3aec"><td class="memItemLeft" align="right" valign="top"><a id="afa80cf157ecf9fe6e0576f80448d3aec"></a>
<a class="el" href="structnode.html">NODE</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>buildTree</b> (vector&lt; WORD &gt; &amp;<a class="el" href="structtree.html">tree</a>)</td></tr>
<tr class="separator:afa80cf157ecf9fe6e0576f80448d3aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44711030e302db551d5970aff3ccca25"><td class="memItemLeft" align="right" valign="top"><a id="a44711030e302db551d5970aff3ccca25"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>count_operators_cse_topdown</b> (vector&lt; WORD &gt; &amp;<a class="el" href="structtree.html">tree</a>)</td></tr>
<tr class="separator:a44711030e302db551d5970aff3ccca25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3609756bbdfe04bc3a58021e709f6bf4"><td class="memItemLeft" align="right" valign="top"><a id="a3609756bbdfe04bc3a58021e709f6bf4"></a>
vector&lt; WORD &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>simulated_annealing</b> ()</td></tr>
<tr class="separator:a3609756bbdfe04bc3a58021e709f6bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb06a6c8e0e95ed8b73a01f0b343a09"><td class="memItemLeft" align="right" valign="top"><a id="aebb06a6c8e0e95ed8b73a01f0b343a09"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>find_Horner_MCTS_expand_tree</b> ()</td></tr>
<tr class="separator:aebb06a6c8e0e95ed8b73a01f0b343a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a895adb819258c8f5a95d3635bb608575"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optimize_8cc.html#a895adb819258c8f5a95d3635bb608575">find_Horner_MCTS</a> ()</td></tr>
<tr class="separator:a895adb819258c8f5a95d3635bb608575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad898f09d5c8951bc139dae96b1121648"><td class="memItemLeft" align="right" valign="top">vector&lt; WORD &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optimize_8cc.html#ad898f09d5c8951bc139dae96b1121648">merge_operators</a> (const vector&lt; WORD &gt; &amp;all_instr, bool move_coeff)</td></tr>
<tr class="separator:ad898f09d5c8951bc139dae96b1121648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38297edbfede135a1fb148b10635500d"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="classoptimization.html">optimization</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optimize_8cc.html#a38297edbfede135a1fb148b10635500d">find_optimizations</a> (const vector&lt; WORD &gt; &amp;instr)</td></tr>
<tr class="separator:a38297edbfede135a1fb148b10635500d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac21af0c2bd95ce022dd1aa04ef3c87ed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optimize_8cc.html#ac21af0c2bd95ce022dd1aa04ef3c87ed">do_optimization</a> (const <a class="el" href="classoptimization.html">optimization</a> optim, vector&lt; WORD &gt; &amp;instr, int newid)</td></tr>
<tr class="separator:ac21af0c2bd95ce022dd1aa04ef3c87ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3e43a3ac83c7fbe414e9dd75db0073a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optimize_8cc.html#ac3e43a3ac83c7fbe414e9dd75db0073a">partial_factorize</a> (vector&lt; WORD &gt; &amp;instr, int n, int improve)</td></tr>
<tr class="separator:ac3e43a3ac83c7fbe414e9dd75db0073a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6764fac1ab2ccb3c7d881bf6679865f"><td class="memItemLeft" align="right" valign="top">vector&lt; WORD &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optimize_8cc.html#af6764fac1ab2ccb3c7d881bf6679865f">optimize_greedy</a> (vector&lt; WORD &gt; instr, LONG time_limit)</td></tr>
<tr class="separator:af6764fac1ab2ccb3c7d881bf6679865f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fbca64500fa79eb561dc30d3392fc27"><td class="memItemLeft" align="right" valign="top">vector&lt; WORD &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optimize_8cc.html#a5fbca64500fa79eb561dc30d3392fc27">recycle_variables</a> (const vector&lt; WORD &gt; &amp;all_instr)</td></tr>
<tr class="separator:a5fbca64500fa79eb561dc30d3392fc27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bdc03e040f8c452701cb70c679209cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optimize_8cc.html#a9bdc03e040f8c452701cb70c679209cd">optimize_expression_given_Horner</a> ()</td></tr>
<tr class="separator:a9bdc03e040f8c452701cb70c679209cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac75fb7b35eb6a8db734a9609b300dc57"><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optimize_8cc.html#ac75fb7b35eb6a8db734a9609b300dc57">generate_output</a> (const vector&lt; WORD &gt; &amp;instr, int exprnr, int extraoffset, const vector&lt; vector&lt; WORD &gt; &gt; &amp;brackets)</td></tr>
<tr class="separator:ac75fb7b35eb6a8db734a9609b300dc57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2817d97c0cf037f1c1bb7b0f6fb71a4"><td class="memItemLeft" align="right" valign="top">WORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optimize_8cc.html#ab2817d97c0cf037f1c1bb7b0f6fb71a4">generate_expression</a> (WORD exprnr)</td></tr>
<tr class="separator:ab2817d97c0cf037f1c1bb7b0f6fb71a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99cd604c80a3f0b23fa5ec7f1e1446e7"><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optimize_8cc.html#a99cd604c80a3f0b23fa5ec7f1e1446e7">optimize_print_code</a> (int print_expr)</td></tr>
<tr class="separator:a99cd604c80a3f0b23fa5ec7f1e1446e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae04aeacaac92dd6eb6e2d17daf981d3c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optimize_8cc.html#ae04aeacaac92dd6eb6e2d17daf981d3c">Optimize</a> (WORD exprnr, int do_print)</td></tr>
<tr class="separator:ae04aeacaac92dd6eb6e2d17daf981d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b8879feddd8be746e5104265fe3155"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optimize_8cc.html#a44b8879feddd8be746e5104265fe3155">ClearOptimize</a> ()</td></tr>
<tr class="separator:a44b8879feddd8be746e5104265fe3155"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a565ed9955394dfa29ba653459e0b344b"><td class="memItemLeft" align="right" valign="top"><a id="a565ed9955394dfa29ba653459e0b344b"></a>
const WORD&#160;</td><td class="memItemRight" valign="bottom"><b>OPER_ADD</b> = -1</td></tr>
<tr class="separator:a565ed9955394dfa29ba653459e0b344b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fa558f0d9beb8ef6d2dff6379cae809"><td class="memItemLeft" align="right" valign="top"><a id="a8fa558f0d9beb8ef6d2dff6379cae809"></a>
const WORD&#160;</td><td class="memItemRight" valign="bottom"><b>OPER_MUL</b> = -2</td></tr>
<tr class="separator:a8fa558f0d9beb8ef6d2dff6379cae809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a2cd460594376079b6154e9c71c88c0"><td class="memItemLeft" align="right" valign="top"><a id="a1a2cd460594376079b6154e9c71c88c0"></a>
const WORD&#160;</td><td class="memItemRight" valign="bottom"><b>OPER_COMMA</b> = -3</td></tr>
<tr class="separator:a1a2cd460594376079b6154e9c71c88c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb8b934f94e6df92e68786acf0f09aa"><td class="memItemLeft" align="right" valign="top"><a id="a7fb8b934f94e6df92e68786acf0f09aa"></a>
WORD *&#160;</td><td class="memItemRight" valign="bottom"><b>optimize_expr</b></td></tr>
<tr class="separator:a7fb8b934f94e6df92e68786acf0f09aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a5d9c60b46342f733a622e17db9315"><td class="memItemLeft" align="right" valign="top"><a id="a05a5d9c60b46342f733a622e17db9315"></a>
vector&lt; vector&lt; WORD &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>optimize_best_Horner_schemes</b></td></tr>
<tr class="separator:a05a5d9c60b46342f733a622e17db9315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6fd717ddea70ee6635c44185c529a29"><td class="memItemLeft" align="right" valign="top"><a id="ac6fd717ddea70ee6635c44185c529a29"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>optimize_num_vars</b></td></tr>
<tr class="separator:ac6fd717ddea70ee6635c44185c529a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6987b3db641144d6222d09807f4e1d4"><td class="memItemLeft" align="right" valign="top"><a id="af6987b3db641144d6222d09807f4e1d4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>optimize_best_num_oper</b></td></tr>
<tr class="separator:af6987b3db641144d6222d09807f4e1d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa011944f1e78226dccf7800ebd649c"><td class="memItemLeft" align="right" valign="top"><a id="a6fa011944f1e78226dccf7800ebd649c"></a>
vector&lt; WORD &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>optimize_best_instr</b></td></tr>
<tr class="separator:a6fa011944f1e78226dccf7800ebd649c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a565e07c9653f144b0cd7bc84bab77c84"><td class="memItemLeft" align="right" valign="top"><a id="a565e07c9653f144b0cd7bc84bab77c84"></a>
vector&lt; WORD &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>optimize_best_vars</b></td></tr>
<tr class="separator:a565e07c9653f144b0cd7bc84bab77c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8fb6d524fe5f0a704d4fdb5e19dbad7"><td class="memItemLeft" align="right" valign="top"><a id="ab8fb6d524fe5f0a704d4fdb5e19dbad7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>mcts_factorized</b></td></tr>
<tr class="separator:ab8fb6d524fe5f0a704d4fdb5e19dbad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b99cab292459b172e95b23117f95905"><td class="memItemLeft" align="right" valign="top"><a id="a6b99cab292459b172e95b23117f95905"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>mcts_separated</b></td></tr>
<tr class="separator:a6b99cab292459b172e95b23117f95905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1de4c2f99ababf79fde8bfe106fed7d4"><td class="memItemLeft" align="right" valign="top"><a id="a1de4c2f99ababf79fde8bfe106fed7d4"></a>
vector&lt; WORD &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mcts_vars</b></td></tr>
<tr class="separator:a1de4c2f99ababf79fde8bfe106fed7d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc3afe3e2b40da2e695b1e0352938f46"><td class="memItemLeft" align="right" valign="top"><a id="afc3afe3e2b40da2e695b1e0352938f46"></a>
<a class="el" href="classtree__node.html">tree_node</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mcts_root</b></td></tr>
<tr class="separator:afc3afe3e2b40da2e695b1e0352938f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abec871687bca84694e46f791e30490a9"><td class="memItemLeft" align="right" valign="top"><a id="abec871687bca84694e46f791e30490a9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>mcts_expr_score</b></td></tr>
<tr class="separator:abec871687bca84694e46f791e30490a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95fb96ae59b34b283fe839e0dbb084d8"><td class="memItemLeft" align="right" valign="top"><a id="a95fb96ae59b34b283fe839e0dbb084d8"></a>
set&lt; pair&lt; int, vector&lt; WORD &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mcts_best_schemes</b></td></tr>
<tr class="separator:a95fb96ae59b34b283fe839e0dbb084d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>experimental routines for the optimization of FORTRAN or C output. </p>

<p class="definition">Definition in file <a class="el" href="optimize_8cc_source.html">optimize.cc</a>.</p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="adefbae07efcb5278e0fed2653443eab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adefbae07efcb5278e0fed2653443eab3">&#9670;&nbsp;</a></span>my_random_shuffle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void my_random_shuffle </td>
          <td>(</td>
          <td class="paramtype">PHEAD RandomAccessIterator&#160;</td>
          <td class="paramname"><em>fr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Random shuffle</p>
<h1><a class="anchor" id="autotoc_md0"></a>
Description</h1>
<p>Randomly permutes elements in the range [fr,to). Functionality is the same as C++'s "random_shuffle", but it uses Form's "wranf". </p>

<p class="definition">Definition at line <a class="el" href="optimize_8cc_source.html#l00184">184</a> of file <a class="el" href="optimize_8cc_source.html">optimize.cc</a>.</p>

</div>
</div>
<a id="abcc71a308991ae8dc729fb69c6222cf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcc71a308991ae8dc729fb69c6222cf8">&#9670;&nbsp;</a></span>get_expression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LONG get_expression </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>exprnr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get expression</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Description</h1>
<p>Reads an expression from the input file into a buffer (called optimize_expr). This buffer is used during the optimization process. Non-symbols are removed by ConvertToPoly and are put in temporary symbols.</p>
<p>The return value is the length of the expression in WORDs, or a negative number if it failed. </p>

<p class="definition">Definition at line <a class="el" href="optimize_8cc_source.html#l00208">208</a> of file <a class="el" href="optimize_8cc_source.html">optimize.cc</a>.</p>

</div>
</div>
<a id="adae1c48384d6b3d171c1b5e2bf2953d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adae1c48384d6b3d171c1b5e2bf2953d7">&#9670;&nbsp;</a></span>get_brackets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;vector&lt;WORD&gt; &gt; get_brackets </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get brackets</p>
<h1><a class="anchor" id="autotoc_md2"></a>
Description</h1>
<p>Checks whether the input expression (stored in optimize_expr) contains brackets. If so, this method replaces terms outside brackets by powers of SEPERATESYMBOL (equal brackets have equal powers) and the brackets are returned. If not, the result is empty.</p>
<p>Brackets are used for simultaneous optimization. The symbol SEPARATESYMBOL is always the first one used in a Horner scheme. </p>

<p class="definition">Definition at line <a class="el" href="optimize_8cc_source.html#l00285">285</a> of file <a class="el" href="optimize_8cc_source.html">optimize.cc</a>.</p>

</div>
</div>
<a id="a6021663b5861197cb619dfbf0b61c98f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6021663b5861197cb619dfbf0b61c98f">&#9670;&nbsp;</a></span>count_operators() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int count_operators </td>
          <td>(</td>
          <td class="paramtype">const WORD *&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>print</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Count operators</p>
<h1><a class="anchor" id="autotoc_md3"></a>
Description</h1>
<p>Counts the number of operators in a Form-style expression. </p>

<p class="definition">Definition at line <a class="el" href="optimize_8cc_source.html#l00405">405</a> of file <a class="el" href="optimize_8cc_source.html">optimize.cc</a>.</p>

<p class="reference">Referenced by <a class="el" href="optimize_8cc_source.html#l03745">optimize_greedy()</a>.</p>

</div>
</div>
<a id="a6ed4fa10a3e861decd68281769e77ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ed4fa10a3e861decd68281769e77ded">&#9670;&nbsp;</a></span>count_operators() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int count_operators </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; WORD &gt; &amp;&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>print</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Count operators</p>
<h1><a class="anchor" id="autotoc_md4"></a>
Description</h1>
<p>Counts the number of operators in a vector of instructions </p>

<p class="definition">Definition at line <a class="el" href="optimize_8cc_source.html#l00459">459</a> of file <a class="el" href="optimize_8cc_source.html">optimize.cc</a>.</p>

</div>
</div>
<a id="ab193934e627fad1810f2844c63ecb139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab193934e627fad1810f2844c63ecb139">&#9670;&nbsp;</a></span>occurrence_order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;WORD&gt; occurrence_order </td>
          <td>(</td>
          <td class="paramtype">const WORD *&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Occurrence order</p>
<h1><a class="anchor" id="autotoc_md5"></a>
Description</h1>
<p>Extracts all variables from an expression and sorts them with most occurring first (or last, with rev=true) </p>

<p class="definition">Definition at line <a class="el" href="optimize_8cc_source.html#l00502">502</a> of file <a class="el" href="optimize_8cc_source.html">optimize.cc</a>.</p>

</div>
</div>
<a id="af0fd473fa3804ea755fca497f7d89f6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0fd473fa3804ea755fca497f7d89f6a">&#9670;&nbsp;</a></span>getpower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WORD getpower </td>
          <td>(</td>
          <td class="paramtype">const WORD *&#160;</td>
          <td class="paramname"><em>term</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Horner tree building</p>
<h1><a class="anchor" id="autotoc_md6"></a>
Description</h1>
<p>Given a Form-style expression (in a buffer in memory), this builds an expression tree. The tree is determined by a multivariate Horner scheme, i.e., something of the form:</p>
<p>1+y+x*(2+y*(1+y)+x*(3-y*(...)))</p>
<p>The order of the variables is given to the method "Horner_tree", which renumbers ad reorders the terms of the expression. Next, the recursive method "build_Horner_tree" does the actual tree construction.</p>
<p>The tree is represented in postfix notation. Tokens are of the following forms:</p>
<ul>
<li>SNUMBER tokenlength num den coefflength</li>
<li>SYMBOL tokenlength variable power</li>
<li>OPER_ADD or OPER_MUL</li>
</ul>
<h1><a class="anchor" id="autotoc_md7"></a>
Note</h1>
<p>Sets AN.poly_num_vars and allocates AN.poly_vars. The latter should be freed later. Get power of variable (helper function for build_Horner_tree)</p>
<h1><a class="anchor" id="autotoc_md8"></a>
Description</h1>
<p>Returns the power of the variable "var", which is at position "pos" in this term, if it is present. </p>

<p class="definition">Definition at line <a class="el" href="optimize_8cc_source.html#l00583">583</a> of file <a class="el" href="optimize_8cc_source.html">optimize.cc</a>.</p>

</div>
</div>
<a id="acf3f8c95c8f6b3d1b06bedce470afe97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf3f8c95c8f6b3d1b06bedce470afe97">&#9670;&nbsp;</a></span>fixarg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fixarg </td>
          <td>(</td>
          <td class="paramtype">UWORD *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WORD &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call GcdLong/DivLong with leading zeroes</p>
<h1><a class="anchor" id="autotoc_md9"></a>
Description</h1>
<p>These method remove leading zeroes, so that GcdLong and DivLong can safely be called. </p>

<p class="definition">Definition at line <a class="el" href="optimize_8cc_source.html#l00597">597</a> of file <a class="el" href="optimize_8cc_source.html">optimize.cc</a>.</p>

</div>
</div>
<a id="acea6d5654ede742b4d4b9da416116f5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acea6d5654ede742b4d4b9da416116f5d">&#9670;&nbsp;</a></span>build_Horner_tree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void build_Horner_tree </td>
          <td>(</td>
          <td class="paramtype">const WORD **&#160;</td>
          <td class="paramname"><em>terms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numterms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxvar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; WORD &gt; *&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Build the Horner tree</p>
<h1><a class="anchor" id="autotoc_md10"></a>
Description</h1>
<p>Constructs the Horner tree. The method processes one variable and continues recursively until the Horner scheme is completed.</p>
<p>"terms" is a pointer to the starts of the terms. "numterms" is the number of terms to be processed. "var" is the next variable to be processed (index between 0 and #maxvar) and "maxvar" is the last variable to be processed, so that partial Horner trees can also be constructed. "pos" is the position that the power of "var" should be in (one level further in the recursion, "pos" has increased by 0 or 1 depending on whether the previous power was 0 or not). The result is written at the pointer "res".</p>
<p>This method also factors out gcds of the coefficients. The result should end with "gcd OPER_MUL" at all times, so that one level higher gcds can be extracted again. </p>

<p class="definition">Definition at line <a class="el" href="optimize_8cc_source.html#l00635">635</a> of file <a class="el" href="optimize_8cc_source.html">optimize.cc</a>.</p>

</div>
</div>
<a id="add58d2f1e0422685a10f31a3a0a16b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add58d2f1e0422685a10f31a3a0a16b57">&#9670;&nbsp;</a></span>term_compare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool term_compare </td>
          <td>(</td>
          <td class="paramtype">const WORD *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const WORD *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Term compare (helper function for Horner_tree)</p>
<h1><a class="anchor" id="autotoc_md11"></a>
Description</h1>
<p>Compares two terms of the form "L SYM 4 x n coeff" or "L
coeff". Lower powers of lower-indexed symbols come first. This is used to sort the terms in correct order. </p>

<p class="definition">Definition at line <a class="el" href="optimize_8cc_source.html#l00835">835</a> of file <a class="el" href="optimize_8cc_source.html">optimize.cc</a>.</p>

</div>
</div>
<a id="a274a87bfb03189ac75814d90d5e68701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a274a87bfb03189ac75814d90d5e68701">&#9670;&nbsp;</a></span>Horner_tree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;WORD&gt; Horner_tree </td>
          <td>(</td>
          <td class="paramtype">const WORD *&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; WORD &gt; &amp;&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prepare Horner tree building</p>
<h1><a class="anchor" id="autotoc_md12"></a>
Description</h1>
<p>This method renumbers the variables to 0...#vars-1 according to the specified order. Next, it stored pointer to individual terms and sorts the terms with higher power first. Then the sorted lists of power is used for the construction of the Horner tree. </p>

<p class="definition">Definition at line <a class="el" href="optimize_8cc_source.html#l00856">856</a> of file <a class="el" href="optimize_8cc_source.html">optimize.cc</a>.</p>

</div>
</div>
<a id="a2d7b65dcb6f75e092976b87f6ffc13f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d7b65dcb6f75e092976b87f6ffc13f5">&#9670;&nbsp;</a></span>generate_instructions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;WORD&gt; generate_instructions </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; WORD &gt; &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>do_CSE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate instructions</p>
<h1><a class="anchor" id="autotoc_md13"></a>
Description</h1>
<p>Converts the expression tree to a list of instructions that directly translate to code. Instructions are of the form:</p>
<p>expr.nr operator length [operands]+ trailing.zero</p>
<p>The operands are of the form:</p>
<p>length [(EXTRA)SYMBOL length variable power] coeff</p>
<p>This method only generates binary operators. Merging is done later. The method also checks for common subexpressions and eliminates them and the flag "do_CSE" is set.</p>
<h1><a class="anchor" id="autotoc_md14"></a>
Implementation details</h1>
<p>The map "ID" keeps track of which subexpressions already exist. The key is formatted as one of the following:</p>
<p>SYMBOL x n SNUMBER coeff OPERATOR LHS RHS</p>
<p>with LHS/RHS formatted as one of the following:</p>
<p>SNUMBER idx 0 (EXTRA)SYMBOL x n</p>
<p>ID[symbol] or ID[operator] equals a subexpression number. ID[coeff] equals the position of the number in the input.</p>
<p>The stack s is used the process the postfix expression tree. Three-word tokens of the form:</p>
<p>SNUMBER idx.of.coeff 0 SYMBOL x n EXTRASYMBOL x 1</p>
<p>are pushed onto it. Operators pop two operands and push the resulting expression.</p>
<p>(Extra)symbols are 1-indexed, because -X is also needed to represent -1 times this term.</p>
<p>There is currently a bug. The notation cannot tell if there is a single bracket and then ignores the bracket.</p>
<p>TODO: check if this method performs properly if do_CSE=false </p>

<p class="definition">Definition at line <a class="el" href="optimize_8cc_source.html#l01104">1104</a> of file <a class="el" href="optimize_8cc_source.html">optimize.cc</a>.</p>

</div>
</div>
<a id="abab9eca226619182e82960044cee4be4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abab9eca226619182e82960044cee4be4">&#9670;&nbsp;</a></span>count_operators_cse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int count_operators_cse </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; WORD &gt; &amp;&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Count number of operators in a binary tree, while removing CSEs on the fly. The instruction set is not created, which makes this method slightly faster.</p>
<p>A hash is created on the fly and is passed through the stack. TODO: find better hash functions </p>

<p class="definition">Definition at line <a class="el" href="optimize_8cc_source.html#l01313">1313</a> of file <a class="el" href="optimize_8cc_source.html">optimize.cc</a>.</p>

</div>
</div>
<a id="a895adb819258c8f5a95d3635bb608575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a895adb819258c8f5a95d3635bb608575">&#9670;&nbsp;</a></span>find_Horner_MCTS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void find_Horner_MCTS </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find best Horner schemes using MCTS</p>
<h1><a class="anchor" id="autotoc_md17"></a>
Description</h1>
<p>The method governs the MCTS for the best Horner schemes. It does some pre-processing, calls "find_Horner_MCTS_expand_tree" a number of times and does some post-processing. </p>

<p class="definition">Definition at line <a class="el" href="optimize_8cc_source.html#l02226">2226</a> of file <a class="el" href="optimize_8cc_source.html">optimize.cc</a>.</p>

</div>
</div>
<a id="ad898f09d5c8951bc139dae96b1121648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad898f09d5c8951bc139dae96b1121648">&#9670;&nbsp;</a></span>merge_operators()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;WORD&gt; merge_operators </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; WORD &gt; &amp;&#160;</td>
          <td class="paramname"><em>all_instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>move_coeff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Merge operators</p>
<h1><a class="anchor" id="autotoc_md18"></a>
Description</h1>
<p>The input instructions form a binary DAG. This method merges expressions like</p>
<p>Z1 = a+b; Z2 = Z1+c;</p>
<p>into</p>
<p>Z2 = a+b+c;</p>
<p>An instruction is merged iff it only has one parent and the operator equals its parent's operator.</p>
<p>This still leaves some freedom: where should the coefficients end up in cases as:</p>
<p>Z1 = Z2 + x &lt;=&gt; Z1 = 2*Z2 + x Z2 = 2*x*y Z2 = x*y</p>
<p>Both are relevant, e.g. for CSE of the form "2*x" and "2*Z2". The flag "move_coeff" moves coefficients from LHS-like expressions to RHS-like expressions.</p>
<p>Furthermore, this method removes empty equation (Z1=0), that are introduced by some "optimize_greedy" substitutions.</p>
<h1><a class="anchor" id="autotoc_md19"></a>
Implementation details</h1>
<p>Expressions are mostly traversed via a stack, so that parents are evaluated before their children.</p>
<p>With "move_coeff" set coefficients are moved, but this leads to some tricky cases, e.g.</p>
<p>Z1 = Z2 + x Z2 = 2*y</p>
<p>Here Z2 reduces to the trivial equation Z2=y, which should be eliminated. Here the array skip[i] comes in.</p>
<p>Furthermore in the case</p>
<p>Z1 = Z2 + x Z2 = 2*Z3 Z3 = x*Z4 Z4 = y*z</p>
<p>after substituting Z1 = 2*Z3 + x, the parent expression for Z4 becomes Z3 instead of Z2. This is where renum_par[i] comes in.</p>
<p>Finally, once a coefficient has been moved, skip_coeff[i] is set and this coefficient is copied into the new expression anymore. </p>

<p class="definition">Definition at line <a class="el" href="optimize_8cc_source.html#l02374">2374</a> of file <a class="el" href="optimize_8cc_source.html">optimize.cc</a>.</p>

</div>
</div>
<a id="a38297edbfede135a1fb148b10635500d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38297edbfede135a1fb148b10635500d">&#9670;&nbsp;</a></span>find_optimizations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="classoptimization.html">optimization</a>&gt; find_optimizations </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; WORD &gt; &amp;&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find optimizations</p>
<h1><a class="anchor" id="autotoc_md21"></a>
Description</h1>
<p>This method find all optimization of the form described in "class
Optimization". It process every equation, looking for possible optimizations and stores them in a fast-access data structure to count the total improvement of an optimization. </p>

<p class="definition">Definition at line <a class="el" href="optimize_8cc_source.html#l02669">2669</a> of file <a class="el" href="optimize_8cc_source.html">optimize.cc</a>.</p>

</div>
</div>
<a id="ac21af0c2bd95ce022dd1aa04ef3c87ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac21af0c2bd95ce022dd1aa04ef3c87ed">&#9670;&nbsp;</a></span>do_optimization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool do_optimization </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoptimization.html">optimization</a>&#160;</td>
          <td class="paramname"><em>optim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; WORD &gt; &amp;&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do optimization</p>
<h1><a class="anchor" id="autotoc_md22"></a>
Description</h1>
<p>This method performs an optimization. It scans through the equations of "optim.eqnidxs" and looks in which this optimization can still be performed (due to other performed optimizations this isn't always the case). If possible, it substitutes the common subexpression by a new extra symbol numbered "newid". Finally, the new extrasymbol is defined accordingly.</p>
<p>Substitutions may lead to trivial equations of the form "Zi=Zj", but these are removed in the end of the method. The method returns whether the substitution has been done once or more (or not). </p>

<p class="definition">Definition at line <a class="el" href="optimize_8cc_source.html#l02902">2902</a> of file <a class="el" href="optimize_8cc_source.html">optimize.cc</a>.</p>

</div>
</div>
<a id="ac3e43a3ac83c7fbe414e9dd75db0073a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3e43a3ac83c7fbe414e9dd75db0073a">&#9670;&nbsp;</a></span>partial_factorize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int partial_factorize </td>
          <td>(</td>
          <td class="paramtype">vector&lt; WORD &gt; &amp;&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>improve</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Partial factorization of instructions</p>
<h1><a class="anchor" id="autotoc_md23"></a>
Description</h1>
<p>This method performs partial factorization of instructions. In particular the following instructions</p>
<p>Z1 = x*a*b Z2 = x*c*d*e Z3 = 2*x + Z1 + Z2 + more</p>
<p>are replaced by</p>
<p>Z1 = a*b Z2 = c*d*e Z3 = Zj + more Zi = 2 + Z1 + Z2 Zj = x*Zi</p>
<p>Here it is necessary that no other equations refer to Z1 and Z2. The generation of trivial instructions (Zi=Zj or Zi=x) is prevented. </p>

<p class="definition">Definition at line <a class="el" href="optimize_8cc_source.html#l03451">3451</a> of file <a class="el" href="optimize_8cc_source.html">optimize.cc</a>.</p>

</div>
</div>
<a id="af6764fac1ab2ccb3c7d881bf6679865f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6764fac1ab2ccb3c7d881bf6679865f">&#9670;&nbsp;</a></span>optimize_greedy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;WORD&gt; optimize_greedy </td>
          <td>(</td>
          <td class="paramtype">vector&lt; WORD &gt;&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LONG&#160;</td>
          <td class="paramname"><em>time_limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Optimize instructions greedily</p>
<h1><a class="anchor" id="autotoc_md24"></a>
Description</h1>
<p>This method optimizes an expression greedily. It calls "find_optimizations" to obtain candidates and performs the best one(s) by calling "do_optimization".</p>
<p>How many different optimization are done, before "find_optimization" is called again, is determined by the settings "greedyminnum" and "greedymaxperc".</p>
<p>During the optimization process, sequences of zeroes are introduced in the instructions, since moving all instructions when one gets optimized, is very costly. Therefore, in the end, the instructions are "compressed" again to remove these extra zeroes. </p>

<p class="definition">Definition at line <a class="el" href="optimize_8cc_source.html#l03745">3745</a> of file <a class="el" href="optimize_8cc_source.html">optimize.cc</a>.</p>

<p class="reference">References <a class="el" href="optimize_8cc_source.html#l00405">count_operators()</a>.</p>

</div>
</div>
<a id="a5fbca64500fa79eb561dc30d3392fc27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fbca64500fa79eb561dc30d3392fc27">&#9670;&nbsp;</a></span>recycle_variables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;WORD&gt; recycle_variables </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; WORD &gt; &amp;&#160;</td>
          <td class="paramname"><em>all_instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recycle variables</p>
<h1><a class="anchor" id="autotoc_md25"></a>
Description</h1>
<p>The current input uses many temporary variables. Many of them become obsolete at some point during the evaluation of the code, so can be recycled. This method renumbers the temporary variables, so that they are recycled. Furthermore, the input is order in depth-first order, so that the instructions can be performed consecutively.</p>
<h1><a class="anchor" id="autotoc_md26"></a>
Implementation details</h1>
<p>First, for each subDAG, an estimate for the number of variables needed is made. This is done by the following recursive formula:</p>
<p>#vars(x) = max(#vars(ch_i(x)) + i),</p>
<p>with ch_i(x) the i-th child of x, where the childs are ordered w.r.t. #vars(ch_i). This formula is exact if the input forms a tree, and otherwise gives a reasonable estimate.</p>
<p>Then, the instructions are reordered in a depth-first order with childs ordered w.r.t. #vars. Next, the times that variables become obsolete are found. Each LHS of an instruction is renumbered to the lowest-numbered temporary variable that is available at that time. </p>

<p class="definition">Definition at line <a class="el" href="optimize_8cc_source.html#l03885">3885</a> of file <a class="el" href="optimize_8cc_source.html">optimize.cc</a>.</p>

</div>
</div>
<a id="a9bdc03e040f8c452701cb70c679209cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bdc03e040f8c452701cb70c679209cd">&#9670;&nbsp;</a></span>optimize_expression_given_Horner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void optimize_expression_given_Horner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Optimize expression given a Horner scheme</p>
<h1><a class="anchor" id="autotoc_md27"></a>
Description</h1>
<p>This method picks one Horner scheme from the list of best Horner schemes, applies this scheme to the expression and then, depending on optimize.settings, does a common subexpression elimination (CSE) or performs greedy optimizations.</p>
<p>CSE is fast, while greedy might be slow. CSE followed by greedy is faster than greedy alone, but typically results in slightly worse code (not proven; just observed). </p>
<p>eventually do greedy optimations</p>

<p class="definition">Definition at line <a class="el" href="optimize_8cc_source.html#l04032">4032</a> of file <a class="el" href="optimize_8cc_source.html">optimize.cc</a>.</p>

</div>
</div>
<a id="ac75fb7b35eb6a8db734a9609b300dc57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac75fb7b35eb6a8db734a9609b300dc57">&#9670;&nbsp;</a></span>generate_output()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID generate_output </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; WORD &gt; &amp;&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>exprnr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>extraoffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; vector&lt; WORD &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>brackets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate output</p>
<h1><a class="anchor" id="autotoc_md28"></a>
Description</h1>
<p>This method prepares the instructions for printing. They are stored in Form format, so that they can be printed by "PrintExtraSymbol". The results are stored in the buffer AO.OptimizeResult. </p>

<p class="definition">Definition at line <a class="el" href="optimize_8cc_source.html#l04263">4263</a> of file <a class="el" href="optimize_8cc_source.html">optimize.cc</a>.</p>

</div>
</div>
<a id="ab2817d97c0cf037f1c1bb7b0f6fb71a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2817d97c0cf037f1c1bb7b0f6fb71a4">&#9670;&nbsp;</a></span>generate_expression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WORD generate_expression </td>
          <td>(</td>
          <td class="paramtype">WORD&#160;</td>
          <td class="paramname"><em>exprnr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate expression</p>
<h1><a class="anchor" id="autotoc_md29"></a>
Description</h1>
<p>This method modifies the original optimized expression by an expression with extra symbols. This is used for "#Optimize". </p>

<p class="definition">Definition at line <a class="el" href="optimize_8cc_source.html#l04416">4416</a> of file <a class="el" href="optimize_8cc_source.html">optimize.cc</a>.</p>

</div>
</div>
<a id="a99cd604c80a3f0b23fa5ec7f1e1446e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99cd604c80a3f0b23fa5ec7f1e1446e7">&#9670;&nbsp;</a></span>optimize_print_code()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID optimize_print_code </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>print_expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print optimized code</p>
<h1><a class="anchor" id="autotoc_md30"></a>
Description</h1>
<p>This method prints the optimized code via "PrintExtraSymbol". Depending on the flag, the original expression is printed (for "Print") or not (for "#Optimize /
#write "O"). </p>

<p class="definition">Definition at line <a class="el" href="optimize_8cc_source.html#l04496">4496</a> of file <a class="el" href="optimize_8cc_source.html">optimize.cc</a>.</p>

</div>
</div>
<a id="ae04aeacaac92dd6eb6e2d17daf981d3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae04aeacaac92dd6eb6e2d17daf981d3c">&#9670;&nbsp;</a></span>Optimize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Optimize </td>
          <td>(</td>
          <td class="paramtype">WORD&#160;</td>
          <td class="paramname"><em>exprnr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>do_print</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Optimization of expression</p>
<h1><a class="anchor" id="autotoc_md31"></a>
Description</h1>
<p>This method takes an input expression and generates optimized code to calculate its value. The following methods are called to do so:</p>
<p>(1) get_expression : to read to expression</p>
<p>(2) get_brackets : find brackets for simultaneous optimization</p>
<p>(3) occurrence_order or find_Horner_MCTS : to determine (the) Horner scheme(s) to use; this depends on AO.optimize.horner</p>
<p>(4) optimize_expression_given_Horner : to do the optimizations for each Horner scheme; this method does either CSE or greedy optimizations dependings on AO.optimize.method</p>
<p>(5) generate_output : to format the output in Form notation and store it in a buffer</p>
<p>(6a) optimize_print_code : to print the expression (for "Print") or (6b) generate_expression : to modify the expression (for "#Optimize")</p>
<p>On ParFORM, all the processes must call this function at the same time. Then</p>
<p>(1) Because only the master can access to the expression to be optimized, the master broadcast the expression to all the slaves after reading the expression (PF_get_expression).</p>
<p>(2) get_brackets reads optimize_expr as the input and it works also on the slaves. We leave it although the bracket information is not needed on the slaves (used in (5) on the master).</p>
<p>(3) and (4) find_Horner_MCTS and optimize_expression_given_Horner are parallelized.</p>
<p>(5), (6a) and (6b) are needed only on the master. </p>

<p class="definition">Definition at line <a class="el" href="optimize_8cc_source.html#l04609">4609</a> of file <a class="el" href="optimize_8cc_source.html">optimize.cc</a>.</p>

</div>
</div>
<a id="a44b8879feddd8be746e5104265fe3155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44b8879feddd8be746e5104265fe3155">&#9670;&nbsp;</a></span>ClearOptimize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ClearOptimize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Optimization of expression</p>
<h1><a class="anchor" id="autotoc_md32"></a>
Description</h1>
<p>Clears the buffers that were used for optimization output. Clears the expression from the buffers (marks it to be dropped). Note: we need to use the expression by its name, because numbers may change if we drop other expressions between when we do the optimizations and clear the results (in <a class="el" href="execute_8c.html">execute.c</a>). Also this is not 100% safe, because we could overwrite the optimized expression. But that can be done only in a Local or Global statement and hence we only have to test there that we might have to call ClearOptimize first. (in file <a class="el" href="comexpr_8c.html">comexpr.c</a>) </p>

<p class="definition">Definition at line <a class="el" href="optimize_8cc_source.html#l04946">4946</a> of file <a class="el" href="optimize_8cc_source.html">optimize.cc</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
