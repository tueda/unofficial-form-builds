<!DOCTYPE HTML>

<!--Converted with LaTeX2HTML 2019.2 (Released June 5, 2019) -->
<HTML lang="EN">
<HEAD>
<TITLE>FORM version 4.3.0 Reference manual</TITLE>
<META NAME="description" CONTENT="FORM version 4.3.0 Reference manual">
<META NAME="keywords" CONTENT="manual">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="viewport" CONTENT="width=device-width, initial-scale=1.0">
<META NAME="Generator" CONTENT="LaTeX2HTML v2019.2">

<LINK REL="STYLESHEET" HREF="manual.css">

</HEAD>

<BODY >

<H1 class="CENTER"><SPAN CLASS="XHUGE">FORM 
<BR><SPAN CLASS="XLARGE">version 4.3.0 
<BR><SPAN CLASS="HUGE">Reference manual</SPAN></SPAN></SPAN></H1>
<DIV CLASS="author_info">

<STRONG>J.A.M.&nbsp;Vermaseren, T.&nbsp;Kaneko, J.&nbsp;Kuipers, B.&nbsp;Ruijl, M.&nbsp;Tentyukov, T.&nbsp;Ueda and J.&nbsp;Vollinga</STRONG>
<P>
15 November 2022</P>
</DIV>

<P>


 <SPAN CLASS="TINY">. </SPAN>


<BR>

<H2><A ID="SECTION00100000000000000000">
Contents</A>
</H2>
<!--Table of Contents-->

<UL CLASS="TofC">
<LI><A ID="tex2html370"
  HREF="#SECTION00200000000000000000">Running FORM</A>
<LI><A ID="tex2html371"
  HREF="#SECTION00300000000000000000">Variables</A>
<UL>
<LI><A ID="tex2html372"
  HREF="#SECTION00310000000000000000">Names</A>
<LI><A ID="tex2html373"
  HREF="#SECTION00320000000000000000">Symbols</A>
<LI><A ID="tex2html374"
  HREF="#SECTION00330000000000000000">Vectors</A>
<LI><A ID="tex2html375"
  HREF="#SECTION00340000000000000000">Indices</A>
<LI><A ID="tex2html376"
  HREF="#SECTION00350000000000000000">Functions</A>
<LI><A ID="tex2html377"
  HREF="#SECTION00360000000000000000">Sets</A>
<LI><A ID="tex2html378"
  HREF="#SECTION00370000000000000000">The autodeclare conventions</A>
<LI><A ID="tex2html379"
  HREF="#SECTION00380000000000000000">Name lists</A>
<LI><A ID="tex2html380"
  HREF="#SECTION00390000000000000000">Dummy indices</A>
<LI><A ID="tex2html381"
  HREF="#SECTION003100000000000000000">Kronecker delta's</A>
<LI><A ID="tex2html382"
  HREF="#SECTION003110000000000000000">Extra Symbols</A>
<LI><A ID="tex2html383"
  HREF="#SECTION003120000000000000000">Restrictions</A>
<LI><A ID="tex2html384"
  HREF="#SECTION003130000000000000000">Some common bugs</A>
</UL>
<BR>
<LI><A ID="tex2html385"
  HREF="#SECTION00400000000000000000">The preprocessor</A>
<UL>
<LI><A ID="tex2html386"
  HREF="#SECTION00410000000000000000">The preprocessor variables</A>
<LI><A ID="tex2html387"
  HREF="#SECTION00420000000000000000">The preprocessor calculator</A>
<LI><A ID="tex2html388"
  HREF="#SECTION00430000000000000000">The triple dot operator</A>
<LI><A ID="tex2html389"
  HREF="#SECTION00440000000000000000">#add</A>
<LI><A ID="tex2html390"
  HREF="#SECTION00450000000000000000">#addseparator</A>
<LI><A ID="tex2html391"
  HREF="#SECTION00460000000000000000">#append</A>
<LI><A ID="tex2html392"
  HREF="#SECTION00470000000000000000">#appendpath</A>
<LI><A ID="tex2html393"
  HREF="#SECTION00480000000000000000">#break</A>
<LI><A ID="tex2html394"
  HREF="#SECTION00490000000000000000">#breakdo</A>
<LI><A ID="tex2html395"
  HREF="#SECTION004100000000000000000">#call</A>
<LI><A ID="tex2html396"
  HREF="#SECTION004110000000000000000">#case</A>
<LI><A ID="tex2html397"
  HREF="#SECTION004120000000000000000">#clearoptimize</A>
<LI><A ID="tex2html398"
  HREF="#SECTION004130000000000000000">#close</A>
<LI><A ID="tex2html399"
  HREF="#SECTION004140000000000000000">#closedictionary</A>
<LI><A ID="tex2html400"
  HREF="#SECTION004150000000000000000">#commentchar</A>
<LI><A ID="tex2html401"
  HREF="#SECTION004160000000000000000">#create</A>
<LI><A ID="tex2html402"
  HREF="#SECTION004170000000000000000">#default</A>
<LI><A ID="tex2html403"
  HREF="#SECTION004180000000000000000">#define</A>
<LI><A ID="tex2html404"
  HREF="#SECTION004190000000000000000">#do</A>
<LI><A ID="tex2html405"
  HREF="#SECTION004200000000000000000">#else</A>
<LI><A ID="tex2html406"
  HREF="#SECTION004210000000000000000">#elseif</A>
<LI><A ID="tex2html407"
  HREF="#SECTION004220000000000000000">#enddo</A>
<LI><A ID="tex2html408"
  HREF="#SECTION004230000000000000000">#endif</A>
<LI><A ID="tex2html409"
  HREF="#SECTION004240000000000000000">#endinside</A>
<LI><A ID="tex2html410"
  HREF="#SECTION004250000000000000000">#endprocedure</A>
<LI><A ID="tex2html411"
  HREF="#SECTION004260000000000000000">#endswitch</A>
<LI><A ID="tex2html412"
  HREF="#SECTION004270000000000000000">#exchange</A>
<LI><A ID="tex2html413"
  HREF="#SECTION004280000000000000000">#external</A>
<LI><A ID="tex2html414"
  HREF="#SECTION004290000000000000000">#factdollar</A>
<LI><A ID="tex2html415"
  HREF="#SECTION004300000000000000000">#fromexternal</A>
<LI><A ID="tex2html416"
  HREF="#SECTION004310000000000000000">#if</A>
<LI><A ID="tex2html417"
  HREF="#SECTION004320000000000000000">#ifdef</A>
<LI><A ID="tex2html418"
  HREF="#SECTION004330000000000000000">#ifndef</A>
<LI><A ID="tex2html419"
  HREF="#SECTION004340000000000000000">#include</A>
<LI><A ID="tex2html420"
  HREF="#SECTION004350000000000000000">#inside</A>
<LI><A ID="tex2html421"
  HREF="#SECTION004360000000000000000">#message</A>
<LI><A ID="tex2html422"
  HREF="#SECTION004370000000000000000">#opendictionary</A>
<LI><A ID="tex2html423"
  HREF="#SECTION004380000000000000000">#optimize</A>
<LI><A ID="tex2html424"
  HREF="#SECTION004390000000000000000">#pipe</A>
<LI><A ID="tex2html425"
  HREF="#SECTION004400000000000000000">#preout</A>
<LI><A ID="tex2html426"
  HREF="#SECTION004410000000000000000">#prependpath</A>
<LI><A ID="tex2html427"
  HREF="#SECTION004420000000000000000">#printtimes</A>
<LI><A ID="tex2html428"
  HREF="#SECTION004430000000000000000">#procedure</A>
<LI><A ID="tex2html429"
  HREF="#SECTION004440000000000000000">#procedureextension</A>
<LI><A ID="tex2html430"
  HREF="#SECTION004450000000000000000">#prompt</A>
<LI><A ID="tex2html431"
  HREF="#SECTION004460000000000000000">#redefine</A>
<LI><A ID="tex2html432"
  HREF="#SECTION004470000000000000000">#remove</A>
<LI><A ID="tex2html433"
  HREF="#SECTION004480000000000000000">#reset</A>
<LI><A ID="tex2html434"
  HREF="#SECTION004490000000000000000">#reverseinclude</A>
<LI><A ID="tex2html435"
  HREF="#SECTION004500000000000000000">#rmexternal</A>
<LI><A ID="tex2html436"
  HREF="#SECTION004510000000000000000">#rmseparator</A>
<LI><A ID="tex2html437"
  HREF="#SECTION004520000000000000000">#setexternal</A>
<LI><A ID="tex2html438"
  HREF="#SECTION004530000000000000000">#setexternalattr</A>
<LI><A ID="tex2html439"
  HREF="#SECTION004540000000000000000">#setrandom</A>
<LI><A ID="tex2html440"
  HREF="#SECTION004550000000000000000">#show</A>
<LI><A ID="tex2html441"
  HREF="#SECTION004560000000000000000">#skipextrasymbols</A>
<LI><A ID="tex2html442"
  HREF="#SECTION004570000000000000000">#switch</A>
<LI><A ID="tex2html443"
  HREF="#SECTION004580000000000000000">#system</A>
<LI><A ID="tex2html444"
  HREF="#SECTION004590000000000000000">#terminate</A>
<LI><A ID="tex2html445"
  HREF="#SECTION004600000000000000000">#timeoutafter</A>
<LI><A ID="tex2html446"
  HREF="#SECTION004610000000000000000">#toexternal</A>
<LI><A ID="tex2html447"
  HREF="#SECTION004620000000000000000">#undefine</A>
<LI><A ID="tex2html448"
  HREF="#SECTION004630000000000000000">#usedictionary</A>
<LI><A ID="tex2html449"
  HREF="#SECTION004640000000000000000">#write</A>
<LI><A ID="tex2html450"
  HREF="#SECTION004650000000000000000">Some remarks</A>
</UL>
<BR>
<LI><A ID="tex2html451"
  HREF="#SECTION00500000000000000000">Modules</A>
<UL>
<LI><A ID="tex2html452"
  HREF="#SECTION00510000000000000000">Checkpoints</A>
</UL>
<BR>
<LI><A ID="tex2html453"
  HREF="#SECTION00600000000000000000">Pattern matching</A>
<LI><A ID="tex2html454"
  HREF="#SECTION00700000000000000000">The dollar variables</A>
<UL>
<LI><A ID="tex2html455"
  HREF="#SECTION00710000000000000000">Dollar variables in a parallel environment</A>
</UL>
<BR>
<LI><A ID="tex2html456"
  HREF="#SECTION00800000000000000000">Statements</A>
<UL>
<LI><A ID="tex2html457"
  HREF="#SECTION00810000000000000000">abrackets, antibrackets</A>
<LI><A ID="tex2html458"
  HREF="#SECTION00820000000000000000">also</A>
<LI><A ID="tex2html459"
  HREF="#SECTION00830000000000000000">antiputinside</A>
<LI><A ID="tex2html460"
  HREF="#SECTION00840000000000000000">antisymmetrize</A>
<LI><A ID="tex2html461"
  HREF="#SECTION00850000000000000000">apply</A>
<LI><A ID="tex2html462"
  HREF="#SECTION00860000000000000000">argexplode</A>
<LI><A ID="tex2html463"
  HREF="#SECTION00870000000000000000">argimplode</A>
<LI><A ID="tex2html464"
  HREF="#SECTION00880000000000000000">argtoextrasymbol</A>
<LI><A ID="tex2html465"
  HREF="#SECTION00890000000000000000">argument</A>
<LI><A ID="tex2html466"
  HREF="#SECTION008100000000000000000">auto, autodeclare</A>
<LI><A ID="tex2html467"
  HREF="#SECTION008110000000000000000">bracket</A>
<LI><A ID="tex2html468"
  HREF="#SECTION008120000000000000000">break</A>
<LI><A ID="tex2html469"
  HREF="#SECTION008130000000000000000">case</A>
<LI><A ID="tex2html470"
  HREF="#SECTION008140000000000000000">cfunctions</A>
<LI><A ID="tex2html471"
  HREF="#SECTION008150000000000000000">chainin</A>
<LI><A ID="tex2html472"
  HREF="#SECTION008160000000000000000">chainout</A>
<LI><A ID="tex2html473"
  HREF="#SECTION008170000000000000000">chisholm</A>
<LI><A ID="tex2html474"
  HREF="#SECTION008180000000000000000">cleartable</A>
<LI><A ID="tex2html475"
  HREF="#SECTION008190000000000000000">collect</A>
<LI><A ID="tex2html476"
  HREF="#SECTION008200000000000000000">commuteinset</A>
<LI><A ID="tex2html477"
  HREF="#SECTION008210000000000000000">commuting</A>
<LI><A ID="tex2html478"
  HREF="#SECTION008220000000000000000">compress</A>
<LI><A ID="tex2html479"
  HREF="#SECTION008230000000000000000">contract</A>
<LI><A ID="tex2html480"
  HREF="#SECTION008240000000000000000">copyspectator</A>
<LI><A ID="tex2html481"
  HREF="#SECTION008250000000000000000">createspectator</A>
<LI><A ID="tex2html482"
  HREF="#SECTION008260000000000000000">ctable</A>
<LI><A ID="tex2html483"
  HREF="#SECTION008270000000000000000">ctensors</A>
<LI><A ID="tex2html484"
  HREF="#SECTION008280000000000000000">cyclesymmetrize</A>
<LI><A ID="tex2html485"
  HREF="#SECTION008290000000000000000">deallocatetable</A>
<LI><A ID="tex2html486"
  HREF="#SECTION008300000000000000000">default</A>
<LI><A ID="tex2html487"
  HREF="#SECTION008310000000000000000">delete</A>
<LI><A ID="tex2html488"
  HREF="#SECTION008320000000000000000">denominators</A>
<LI><A ID="tex2html489"
  HREF="#SECTION008330000000000000000">dimension</A>
<LI><A ID="tex2html490"
  HREF="#SECTION008340000000000000000">discard</A>
<LI><A ID="tex2html491"
  HREF="#SECTION008350000000000000000">disorder</A>
<LI><A ID="tex2html492"
  HREF="#SECTION008360000000000000000">do</A>
<LI><A ID="tex2html493"
  HREF="#SECTION008370000000000000000">drop</A>
<LI><A ID="tex2html494"
  HREF="#SECTION008380000000000000000">dropcoefficient</A>
<LI><A ID="tex2html495"
  HREF="#SECTION008390000000000000000">dropsymbols</A>
<LI><A ID="tex2html496"
  HREF="#SECTION008400000000000000000">else</A>
<LI><A ID="tex2html497"
  HREF="#SECTION008410000000000000000">elseif</A>
<LI><A ID="tex2html498"
  HREF="#SECTION008420000000000000000">emptyspectator</A>
<LI><A ID="tex2html499"
  HREF="#SECTION008430000000000000000">endargument</A>
<LI><A ID="tex2html500"
  HREF="#SECTION008440000000000000000">enddo</A>
<LI><A ID="tex2html501"
  HREF="#SECTION008450000000000000000">endif</A>
<LI><A ID="tex2html502"
  HREF="#SECTION008460000000000000000">endinexpression</A>
<LI><A ID="tex2html503"
  HREF="#SECTION008470000000000000000">endinside</A>
<LI><A ID="tex2html504"
  HREF="#SECTION008480000000000000000">endrepeat</A>
<LI><A ID="tex2html505"
  HREF="#SECTION008490000000000000000">endswitch</A>
<LI><A ID="tex2html506"
  HREF="#SECTION008500000000000000000">endterm</A>
<LI><A ID="tex2html507"
  HREF="#SECTION008510000000000000000">endwhile</A>
<LI><A ID="tex2html508"
  HREF="#SECTION008520000000000000000">exit</A>
<LI><A ID="tex2html509"
  HREF="#SECTION008530000000000000000">extrasymbols</A>
<LI><A ID="tex2html510"
  HREF="#SECTION008540000000000000000">factarg</A>
<LI><A ID="tex2html511"
  HREF="#SECTION008550000000000000000">factdollar</A>
<LI><A ID="tex2html512"
  HREF="#SECTION008560000000000000000">factorize</A>
<LI><A ID="tex2html513"
  HREF="#SECTION008570000000000000000">fill</A>
<LI><A ID="tex2html514"
  HREF="#SECTION008580000000000000000">fillexpression</A>
<LI><A ID="tex2html515"
  HREF="#SECTION008590000000000000000">fixindex</A>
<LI><A ID="tex2html516"
  HREF="#SECTION008600000000000000000">format</A>
<LI><A ID="tex2html517"
  HREF="#SECTION008610000000000000000">frompolynomial</A>
<LI><A ID="tex2html518"
  HREF="#SECTION008620000000000000000">functions</A>
<LI><A ID="tex2html519"
  HREF="#SECTION008630000000000000000">funpowers</A>
<LI><A ID="tex2html520"
  HREF="#SECTION008640000000000000000">gfactorized</A>
<LI><A ID="tex2html521"
  HREF="#SECTION008650000000000000000">global</A>
<LI><A ID="tex2html522"
  HREF="#SECTION008660000000000000000">goto</A>
<LI><A ID="tex2html523"
  HREF="#SECTION008670000000000000000">hide</A>
<LI><A ID="tex2html524"
  HREF="#SECTION008680000000000000000">identify</A>
<LI><A ID="tex2html525"
  HREF="#SECTION008690000000000000000">idnew</A>
<LI><A ID="tex2html526"
  HREF="#SECTION008700000000000000000">idold</A>
<LI><A ID="tex2html527"
  HREF="#SECTION008710000000000000000">if</A>
<LI><A ID="tex2html528"
  HREF="#SECTION008720000000000000000">ifmatch</A>
<LI><A ID="tex2html529"
  HREF="#SECTION008730000000000000000">ifnomatch</A>
<LI><A ID="tex2html530"
  HREF="#SECTION008740000000000000000">index, indices</A>
<LI><A ID="tex2html531"
  HREF="#SECTION008750000000000000000">inexpression</A>
<LI><A ID="tex2html532"
  HREF="#SECTION008760000000000000000">inparallel</A>
<LI><A ID="tex2html533"
  HREF="#SECTION008770000000000000000">inside</A>
<LI><A ID="tex2html534"
  HREF="#SECTION008780000000000000000">insidefirst</A>
<LI><A ID="tex2html535"
  HREF="#SECTION008790000000000000000">intohide</A>
<LI><A ID="tex2html536"
  HREF="#SECTION008800000000000000000">keep</A>
<LI><A ID="tex2html537"
  HREF="#SECTION008810000000000000000">label</A>
<LI><A ID="tex2html538"
  HREF="#SECTION008820000000000000000">lfactorized</A>
<LI><A ID="tex2html539"
  HREF="#SECTION008830000000000000000">load</A>
<LI><A ID="tex2html540"
  HREF="#SECTION008840000000000000000">local</A>
<LI><A ID="tex2html541"
  HREF="#SECTION008850000000000000000">makeinteger</A>
<LI><A ID="tex2html542"
  HREF="#SECTION008860000000000000000">many</A>
<LI><A ID="tex2html543"
  HREF="#SECTION008870000000000000000">merge</A>
<LI><A ID="tex2html544"
  HREF="#SECTION008880000000000000000">metric</A>
<LI><A ID="tex2html545"
  HREF="#SECTION008890000000000000000">moduleoption</A>
<LI><A ID="tex2html546"
  HREF="#SECTION008900000000000000000">modulus</A>
<LI><A ID="tex2html547"
  HREF="#SECTION008910000000000000000">multi</A>
<LI><A ID="tex2html548"
  HREF="#SECTION008920000000000000000">multiply</A>
<LI><A ID="tex2html549"
  HREF="#SECTION008930000000000000000">ndrop</A>
<LI><A ID="tex2html550"
  HREF="#SECTION008940000000000000000">nfactorize</A>
<LI><A ID="tex2html551"
  HREF="#SECTION008950000000000000000">nfunctions</A>
<LI><A ID="tex2html552"
  HREF="#SECTION008960000000000000000">nhide</A>
<LI><A ID="tex2html553"
  HREF="#SECTION008970000000000000000">normalize</A>
<LI><A ID="tex2html554"
  HREF="#SECTION008980000000000000000">notinparallel</A>
<LI><A ID="tex2html555"
  HREF="#SECTION008990000000000000000">nprint</A>
<LI><A ID="tex2html556"
  HREF="#SECTION0081000000000000000000">nskip</A>
<LI><A ID="tex2html557"
  HREF="#SECTION0081010000000000000000">ntable</A>
<LI><A ID="tex2html558"
  HREF="#SECTION0081020000000000000000">ntensors</A>
<LI><A ID="tex2html559"
  HREF="#SECTION0081030000000000000000">nunfactorize</A>
<LI><A ID="tex2html560"
  HREF="#SECTION0081040000000000000000">nunhide</A>
<LI><A ID="tex2html561"
  HREF="#SECTION0081050000000000000000">nwrite</A>
<LI><A ID="tex2html562"
  HREF="#SECTION0081060000000000000000">off</A>
<LI><A ID="tex2html563"
  HREF="#SECTION0081070000000000000000">on</A>
<LI><A ID="tex2html564"
  HREF="#SECTION0081080000000000000000">once</A>
<LI><A ID="tex2html565"
  HREF="#SECTION0081090000000000000000">only</A>
<LI><A ID="tex2html566"
  HREF="#SECTION0081100000000000000000">polyfun</A>
<LI><A ID="tex2html567"
  HREF="#SECTION0081110000000000000000">polyratfun</A>
<LI><A ID="tex2html568"
  HREF="#SECTION0081120000000000000000">pophide</A>
<LI><A ID="tex2html569"
  HREF="#SECTION0081130000000000000000">print</A>
<LI><A ID="tex2html570"
  HREF="#SECTION0081140000000000000000">print[&nbsp;]</A>
<LI><A ID="tex2html571"
  HREF="#SECTION0081150000000000000000">printtable</A>
<LI><A ID="tex2html572"
  HREF="#SECTION0081160000000000000000">processbucketsize</A>
<LI><A ID="tex2html573"
  HREF="#SECTION0081170000000000000000">propercount</A>
<LI><A ID="tex2html574"
  HREF="#SECTION0081180000000000000000">pushhide</A>
<LI><A ID="tex2html575"
  HREF="#SECTION0081190000000000000000">putinside</A>
<LI><A ID="tex2html576"
  HREF="#SECTION0081200000000000000000">ratio</A>
<LI><A ID="tex2html577"
  HREF="#SECTION0081210000000000000000">rcyclesymmetrize</A>
<LI><A ID="tex2html578"
  HREF="#SECTION0081220000000000000000">redefine</A>
<LI><A ID="tex2html579"
  HREF="#SECTION0081230000000000000000">removespectator</A>
<LI><A ID="tex2html580"
  HREF="#SECTION0081240000000000000000">renumber</A>
<LI><A ID="tex2html581"
  HREF="#SECTION0081250000000000000000">repeat</A>
<LI><A ID="tex2html582"
  HREF="#SECTION0081260000000000000000">replaceloop</A>
<LI><A ID="tex2html583"
  HREF="#SECTION0081270000000000000000">save</A>
<LI><A ID="tex2html584"
  HREF="#SECTION0081280000000000000000">select</A>
<LI><A ID="tex2html585"
  HREF="#SECTION0081290000000000000000">set</A>
<LI><A ID="tex2html586"
  HREF="#SECTION0081300000000000000000">setexitflag</A>
<LI><A ID="tex2html587"
  HREF="#SECTION0081310000000000000000">shuffle</A>
<LI><A ID="tex2html588"
  HREF="#SECTION0081320000000000000000">skip</A>
<LI><A ID="tex2html589"
  HREF="#SECTION0081330000000000000000">sort</A>
<LI><A ID="tex2html590"
  HREF="#SECTION0081340000000000000000">splitarg</A>
<LI><A ID="tex2html591"
  HREF="#SECTION0081350000000000000000">splitfirstarg</A>
<LI><A ID="tex2html592"
  HREF="#SECTION0081360000000000000000">splitlastarg</A>
<LI><A ID="tex2html593"
  HREF="#SECTION0081370000000000000000">stuffle</A>
<LI><A ID="tex2html594"
  HREF="#SECTION0081380000000000000000">sum</A>
<LI><A ID="tex2html595"
  HREF="#SECTION0081390000000000000000">switch</A>
<LI><A ID="tex2html596"
  HREF="#SECTION0081400000000000000000">symbols</A>
<LI><A ID="tex2html597"
  HREF="#SECTION0081410000000000000000">symmetrize</A>
<LI><A ID="tex2html598"
  HREF="#SECTION0081420000000000000000">table</A>
<LI><A ID="tex2html599"
  HREF="#SECTION0081430000000000000000">tablebase</A>
<LI><A ID="tex2html600"
  HREF="#SECTION0081440000000000000000">tensors</A>
<LI><A ID="tex2html601"
  HREF="#SECTION0081450000000000000000">term</A>
<LI><A ID="tex2html602"
  HREF="#SECTION0081460000000000000000">testuse</A>
<LI><A ID="tex2html603"
  HREF="#SECTION0081470000000000000000">threadbucketsize</A>
<LI><A ID="tex2html604"
  HREF="#SECTION0081480000000000000000">topolynomial</A>
<LI><A ID="tex2html605"
  HREF="#SECTION0081490000000000000000">tospectator</A>
<LI><A ID="tex2html606"
  HREF="#SECTION0081500000000000000000">totensor</A>
<LI><A ID="tex2html607"
  HREF="#SECTION0081510000000000000000">tovector</A>
<LI><A ID="tex2html608"
  HREF="#SECTION0081520000000000000000">trace4</A>
<LI><A ID="tex2html609"
  HREF="#SECTION0081530000000000000000">tracen</A>
<LI><A ID="tex2html610"
  HREF="#SECTION0081540000000000000000">transform</A>
<LI><A ID="tex2html611"
  HREF="#SECTION0081550000000000000000">tryreplace</A>
<LI><A ID="tex2html612"
  HREF="#SECTION0081560000000000000000">unfactorize</A>
<LI><A ID="tex2html613"
  HREF="#SECTION0081570000000000000000">unhide</A>
<LI><A ID="tex2html614"
  HREF="#SECTION0081580000000000000000">unittrace</A>
<LI><A ID="tex2html615"
  HREF="#SECTION0081590000000000000000">vectors</A>
<LI><A ID="tex2html616"
  HREF="#SECTION0081600000000000000000">while</A>
<LI><A ID="tex2html617"
  HREF="#SECTION0081610000000000000000">write</A>
</UL>
<BR>
<LI><A ID="tex2html618"
  HREF="#SECTION00900000000000000000">Functions</A>
<UL>
<LI><A ID="tex2html619"
  HREF="#SECTION00910000000000000000">abs_</A>
<LI><A ID="tex2html620"
  HREF="#SECTION00920000000000000000">bernoulli_</A>
<LI><A ID="tex2html621"
  HREF="#SECTION00930000000000000000">binom_</A>
<LI><A ID="tex2html622"
  HREF="#SECTION00940000000000000000">conjg_</A>
<LI><A ID="tex2html623"
  HREF="#SECTION00950000000000000000">content_</A>
<LI><A ID="tex2html624"
  HREF="#SECTION00960000000000000000">count_</A>
<LI><A ID="tex2html625"
  HREF="#SECTION00970000000000000000">d_</A>
<LI><A ID="tex2html626"
  HREF="#SECTION00980000000000000000">dd_</A>
<LI><A ID="tex2html627"
  HREF="#SECTION00990000000000000000">delta_</A>
<LI><A ID="tex2html628"
  HREF="#SECTION009100000000000000000">deltap_</A>
<LI><A ID="tex2html629"
  HREF="#SECTION009110000000000000000">denom_</A>
<LI><A ID="tex2html630"
  HREF="#SECTION009120000000000000000">distrib_</A>
<LI><A ID="tex2html631"
  HREF="#SECTION009130000000000000000">div_</A>
<LI><A ID="tex2html632"
  HREF="#SECTION009140000000000000000">dum_</A>
<LI><A ID="tex2html633"
  HREF="#SECTION009150000000000000000">dummy_</A>
<LI><A ID="tex2html634"
  HREF="#SECTION009160000000000000000">dummyten_</A>
<LI><A ID="tex2html635"
  HREF="#SECTION009170000000000000000">e_</A>
<LI><A ID="tex2html636"
  HREF="#SECTION009180000000000000000">exp_</A>
<LI><A ID="tex2html637"
  HREF="#SECTION009190000000000000000">exteuclidean_</A>
<LI><A ID="tex2html638"
  HREF="#SECTION009200000000000000000">extrasymbol_</A>
<LI><A ID="tex2html639"
  HREF="#SECTION009210000000000000000">fac_</A>
<LI><A ID="tex2html640"
  HREF="#SECTION009220000000000000000">factorin_</A>
<LI><A ID="tex2html641"
  HREF="#SECTION009230000000000000000">farg_</A>
<LI><A ID="tex2html642"
  HREF="#SECTION009240000000000000000">firstbracket_</A>
<LI><A ID="tex2html643"
  HREF="#SECTION009250000000000000000">firstterm_</A>
<LI><A ID="tex2html644"
  HREF="#SECTION009260000000000000000">g5_</A>
<LI><A ID="tex2html645"
  HREF="#SECTION009270000000000000000">g6_</A>
<LI><A ID="tex2html646"
  HREF="#SECTION009280000000000000000">g7_</A>
<LI><A ID="tex2html647"
  HREF="#SECTION009290000000000000000">g_</A>
<LI><A ID="tex2html648"
  HREF="#SECTION009300000000000000000">gcd_</A>
<LI><A ID="tex2html649"
  HREF="#SECTION009310000000000000000">gi_</A>
<LI><A ID="tex2html650"
  HREF="#SECTION009320000000000000000">id_</A>
<LI><A ID="tex2html651"
  HREF="#SECTION009330000000000000000">integer_</A>
<LI><A ID="tex2html652"
  HREF="#SECTION009340000000000000000">inverse_</A>
<LI><A ID="tex2html653"
  HREF="#SECTION009350000000000000000">invfac_</A>
<LI><A ID="tex2html654"
  HREF="#SECTION009360000000000000000">makerational_</A>
<LI><A ID="tex2html655"
  HREF="#SECTION009370000000000000000">match_</A>
<LI><A ID="tex2html656"
  HREF="#SECTION009380000000000000000">max_</A>
<LI><A ID="tex2html657"
  HREF="#SECTION009390000000000000000">maxpowerof_</A>
<LI><A ID="tex2html658"
  HREF="#SECTION009400000000000000000">min_</A>
<LI><A ID="tex2html659"
  HREF="#SECTION009410000000000000000">minpowerof_</A>
<LI><A ID="tex2html660"
  HREF="#SECTION009420000000000000000">mod_</A>
<LI><A ID="tex2html661"
  HREF="#SECTION009430000000000000000">mod2_</A>
<LI><A ID="tex2html662"
  HREF="#SECTION009440000000000000000">moebius_</A>
<LI><A ID="tex2html663"
  HREF="#SECTION009450000000000000000">mul_</A>
<LI><A ID="tex2html664"
  HREF="#SECTION009460000000000000000">nargs_</A>
<LI><A ID="tex2html665"
  HREF="#SECTION009470000000000000000">node_</A>
<LI><A ID="tex2html666"
  HREF="#SECTION009480000000000000000">nterms_</A>
<LI><A ID="tex2html667"
  HREF="#SECTION009490000000000000000">numfactors_</A>
<LI><A ID="tex2html668"
  HREF="#SECTION009500000000000000000">partitions_</A>
<LI><A ID="tex2html669"
  HREF="#SECTION009510000000000000000">pattern_</A>
<LI><A ID="tex2html670"
  HREF="#SECTION009520000000000000000">perm_</A>
<LI><A ID="tex2html671"
  HREF="#SECTION009530000000000000000">poly_</A>
<LI><A ID="tex2html672"
  HREF="#SECTION009540000000000000000">prime_</A>
<LI><A ID="tex2html673"
  HREF="#SECTION009550000000000000000">putfirst_</A>
<LI><A ID="tex2html674"
  HREF="#SECTION009560000000000000000">random_</A>
<LI><A ID="tex2html675"
  HREF="#SECTION009570000000000000000">ranperm_</A>
<LI><A ID="tex2html676"
  HREF="#SECTION009580000000000000000">rem_</A>
<LI><A ID="tex2html677"
  HREF="#SECTION009590000000000000000">replace_</A>
<LI><A ID="tex2html678"
  HREF="#SECTION009600000000000000000">reverse_</A>
<LI><A ID="tex2html679"
  HREF="#SECTION009610000000000000000">root_</A>
<LI><A ID="tex2html680"
  HREF="#SECTION009620000000000000000">setfun_</A>
<LI><A ID="tex2html681"
  HREF="#SECTION009630000000000000000">sig_</A>
<LI><A ID="tex2html682"
  HREF="#SECTION009640000000000000000">sign_</A>
<LI><A ID="tex2html683"
  HREF="#SECTION009650000000000000000">sizeof_</A>
<LI><A ID="tex2html684"
  HREF="#SECTION009660000000000000000">sum_</A>
<LI><A ID="tex2html685"
  HREF="#SECTION009670000000000000000">sump_</A>
<LI><A ID="tex2html686"
  HREF="#SECTION009680000000000000000">table_</A>
<LI><A ID="tex2html687"
  HREF="#SECTION009690000000000000000">tbl_</A>
<LI><A ID="tex2html688"
  HREF="#SECTION009700000000000000000">term_</A>
<LI><A ID="tex2html689"
  HREF="#SECTION009710000000000000000">termsin_</A>
<LI><A ID="tex2html690"
  HREF="#SECTION009720000000000000000">termsinbracket_</A>
<LI><A ID="tex2html691"
  HREF="#SECTION009730000000000000000">theta_</A>
<LI><A ID="tex2html692"
  HREF="#SECTION009740000000000000000">thetap_</A>
<LI><A ID="tex2html693"
  HREF="#SECTION009750000000000000000">topologies_</A>
<LI><A ID="tex2html694"
  HREF="#SECTION009760000000000000000">Extra reserved names</A>
</UL>
<BR>
<LI><A ID="tex2html695"
  HREF="#SECTION001000000000000000000">Brackets</A>
<LI><A ID="tex2html696"
  HREF="#SECTION001100000000000000000">Output optimization</A>
<UL>
<LI><A ID="tex2html697"
  HREF="#SECTION001101000000000000000">Optimization options of the Format statement</A>
</UL>
<BR>
<LI><A ID="tex2html698"
  HREF="#SECTION001200000000000000000">Polynomials and Factorization</A>
<LI><A ID="tex2html699"
  HREF="#SECTION001300000000000000000">The TableBase</A>
<UL>
<LI><A ID="tex2html700"
  HREF="#SECTION001310000000000000000">addto</A>
<LI><A ID="tex2html701"
  HREF="#SECTION001320000000000000000">apply</A>
<LI><A ID="tex2html702"
  HREF="#SECTION001330000000000000000">audit</A>
<LI><A ID="tex2html703"
  HREF="#SECTION001340000000000000000">create</A>
<LI><A ID="tex2html704"
  HREF="#SECTION001350000000000000000">enter</A>
<LI><A ID="tex2html705"
  HREF="#SECTION001360000000000000000">load</A>
<LI><A ID="tex2html706"
  HREF="#SECTION001370000000000000000">off</A>
<LI><A ID="tex2html707"
  HREF="#SECTION001380000000000000000">on</A>
<LI><A ID="tex2html708"
  HREF="#SECTION001390000000000000000">open</A>
<LI><A ID="tex2html709"
  HREF="#SECTION0013100000000000000000">testuse</A>
<LI><A ID="tex2html710"
  HREF="#SECTION0013110000000000000000">use</A>
</UL>
<BR>
<LI><A ID="tex2html711"
  HREF="#SECTION001400000000000000000">Dictionaries</A>
<LI><A ID="tex2html712"
  HREF="#SECTION001500000000000000000">Dirac algebra</A>
<LI><A ID="tex2html713"
  HREF="#SECTION001600000000000000000">A few notes on the use of a metric</A>
<LI><A ID="tex2html714"
  HREF="#SECTION001700000000000000000">Sorting and statistics</A>
<LI><A ID="tex2html715"
  HREF="#SECTION001800000000000000000">The setup</A>
<LI><A ID="tex2html716"
  HREF="#SECTION001900000000000000000">The parallel version</A>
<UL>
<LI><A ID="tex2html717"
  HREF="#SECTION001910000000000000000">TFORM</A>
<LI><A ID="tex2html718"
  HREF="#SECTION001920000000000000000">ParFORM</A>
<LI><A ID="tex2html719"
  HREF="#SECTION001930000000000000000">Some problems</A>
</UL>
<BR>
<LI><A ID="tex2html720"
  HREF="#SECTION002000000000000000000">External communication</A>
<UL>
<LI><A ID="tex2html721"
  HREF="#SECTION002010000000000000000">#external</A>
<LI><A ID="tex2html722"
  HREF="#SECTION002020000000000000000">#toexternal</A>
<LI><A ID="tex2html723"
  HREF="#SECTION002030000000000000000">#fromexternal</A>
<LI><A ID="tex2html724"
  HREF="#SECTION002040000000000000000">#prompt</A>
<LI><A ID="tex2html725"
  HREF="#SECTION002050000000000000000">#setexternal</A>
<LI><A ID="tex2html726"
  HREF="#SECTION002060000000000000000">#rmexternal</A>
<LI><A ID="tex2html727"
  HREF="#SECTION002070000000000000000">#setexternalattr</A>
<LI><A ID="tex2html728"
  HREF="#SECTION002080000000000000000">An example</A>
<LI><A ID="tex2html729"
  HREF="#SECTION002090000000000000000">Embedding FORM in other applications</A>
</UL>
<BR>
<LI><A ID="tex2html730"
  HREF="#SECTION002100000000000000000">Spectators</A>
<LI><A ID="tex2html731"
  HREF="#SECTION002200000000000000000">Diagram generation</A>
<LI><A ID="tex2html732"
  HREF="#SECTION002300000000000000000">Index</A>
</UL>
<!--End of Table of Contents-->
 <SPAN CLASS="TINY">. </SPAN>

<P>

<H1><A ID="SECTION00200000000000000000"></A>
<A ID="running"></A>
<BR>
Running FORM
</H1>

<P>
The proper way to invoke the running<A NAME="167"></A> of FORM depends on 
the operating system that is being used. Here we will consider the 
UNIX<A NAME="168"></A> operating system and its derivatives. The version for 
computers with the Windows operating system use Cygwin<A NAME="169"></A>, which 
is a UNIX derivative as well and hence it functions similarly. In all cases 
a proper call of FORM is
<PRE>
     form [options] inputfile
</PRE>
The input file<A NAME="172"></A> should have a name that ends in the 
extension <code>.frm</code>. It is however not needed to specify this extension. 
If this extension is absent, FORM will add it. Example:
<PRE>
     form myformprogram
</PRE>
and FORM will look for the file <code>myformprogram.frm</code>. 
It is also possible to use the standard input as the input, rather than a file, 
by giving <code>-</code> for the <code>inputfile</code> (which is currently not supported by P<SMALL>AR</SMALL>FORM, though). 
The options are 
separated by blanks and start with a minus sign, followed by one or more 
alphabetic characters. They are:
<DL>
<DT><STRONG>-c</STRONG></DT>
<DD>Error checking only. Notice that this will not work 
     properly if there are conditionals in the preprocessor phase that 
     depend on results obtained at earlier stages of the program.
</DD>
<DT><STRONG>-C</STRONG></DT>
<DD>Next argument/option is a custom filename for the log file.
</DD>
<DT><STRONG>-d</STRONG></DT>
<DD>Next argument/option is the name of a preprocessor 
     variable that will be defined before the run starts. A specific value can be assigned with the
	 syntax <SPAN style="font-family:monospace">-d VARIABLENAME=VALUE</SPAN>. The default value is 1.
</DD>
<DT><STRONG>-D</STRONG></DT>
<DD>Same as -d.
</DD>
<DT><STRONG>-f</STRONG></DT>
<DD>Output goes only to log file.
</DD>
<DT><STRONG>-F</STRONG></DT>
<DD>Output only to log file. Further like -L or -ll.
</DD>
<DT><STRONG>-h</STRONG></DT>
<DD>Wait for some key to be touched before finishing the run.
     Basically only for some old window based systems.
</DD>
<DT><STRONG>-I</STRONG></DT>
<DD>Next argument/option is the path of a directory for 
     include, procedure and subroutine files.
</DD>
<DT><STRONG>-l</STRONG></DT>
<DD>Make a regular log file.
</DD>
<DT><STRONG>-ll</STRONG></DT>
<DD>Make a log file without intermediate statistics.
</DD>
<DT><STRONG>-L</STRONG></DT>
<DD>Same as -ll.
</DD>
<DT><STRONG>-M</STRONG></DT>
<DD>Put the PID (process identifier) in the name of the temporary 
     files. This makes for longer names, but gives a better guarantee of 
     uniqueness. If a file with the created name exists already it will be 
     overwritten. This option is for when several instances of FORM are 
     started at nearly the same time as can happen from minos or make (with 
     the make -j option).
</DD>
<DT><STRONG>-p</STRONG></DT>
<DD>Next argument/option is the path of a directory for 
     input, include, procedure and subroutine files.
</DD>
<DT><STRONG>-pipe</STRONG></DT>
<DD>Indicates that FORM is started up as the receiving 
     end of a pipe. Action will be taken to set up the proper communication 
     channels.
</DD>
<DT><STRONG>-q</STRONG></DT>
<DD>Quiet option. Only output expressions are printed.
</DD>
<DT><STRONG>-R</STRONG></DT>
<DD>Recover from a crash. See the checkpoint mechanism in 
     <A HREF="#checkpoints">4.1</A>.
</DD>
<DT><STRONG>-s</STRONG></DT>
<DD>Next argument/option is the path of a directory for a 
     setup file.
</DD>
<DT><STRONG>-si</STRONG></DT>
<DD>Same as -q.
</DD>
<DT><STRONG>-S</STRONG></DT>
<DD>Next argument/option is the name of a setup file.
</DD>
<DT><STRONG>-t</STRONG></DT>
<DD>Next argument/option is the path of a directory for temporary files.
</DD>
<DT><STRONG>-ts</STRONG></DT>
<DD>Next argument/option is the path of a directory for temporary sort 
     files.
</DD>
<DT><STRONG>-T</STRONG></DT>
<DD>Puts<A NAME="181"></A> FORM in a mode in which the maximum 
     totalsize is measured and printed at the end of the program. For more 
     information see the "On TotalSize;" statement&nbsp;<A HREF="#ontotalsize">7.107</A>.
</DD>
<DT><STRONG>-v</STRONG></DT>
<DD>Only the version will be printed. The program terminates 
     immediately after it.
</DD>
<DT><STRONG>-w</STRONG></DT>
<DD>This should be followed immediately by a number. The 
     number indicates the number of worker threads for TFORM. All other 
     versions of FORM ignore this parameter. It should be noted that TFORM 
     is a different program. For more information, please consult 
     chapter&nbsp;<A HREF="#parallel">18</A>.
</DD>
<DT><STRONG>-W</STRONG></DT>
<DD>Turn on the wall-clock time mode in the statistics. 
     See the `<SPAN  CLASS="texttt">On wtimestats</SPAN>' statement&nbsp;<A HREF="#substaon">7.107</A>.
</DD>
<DT><STRONG>-y</STRONG></DT>
<DD>Run only the preprocessor and dump its output.
</DD>
<DT><STRONG>-z</STRONG></DT>
<DD>The number following is a timelimit for the program in second.
</DD>
<DT><STRONG>-Z</STRONG></DT>
<DD>Removes the .str file on crash, whatever its contents. Under 
     ordinary circumstances at a crash a .str file will not be removed if 
     it has a nonzero content.
</DD>
</DL>

<P>
The log<A NAME="187"></A> file<A NAME="188"></A> is a file in which all 
output is collected, even when the output appears on the screen already. 
This makes it possible to follow the progress of the program and have a 
record of everything at the same time. The default name of the log file is 
identical to the name of the program without the extension <code>.frm</code> but 
with the extra extension <code>.log</code>.
Example:
<DIV class="CENTER">
</DIV><PRE>
     form -t /LocalDisk/mydir -l myformprogram
</PRE>
<DIV class="CENTER">
</DIV>
FORM will run the program in the file <code>myformprogram.frm</code>. Its output 
will both be written to the screen and into the file 
<code>myformprogram.log</code>. The temporary files (if any) will be made in the 
directory <code>/LocalDisk/mydir</code>. This last feature is very useful, 
because writing temporary files across a network can sometimes slow things 
down considerably.

<P>
The second way to pass parameters to FORM during startup is by means of 
environment<A NAME="193"></A> variables, assuming of course that 
the system supports them. The following variables are supported:
<DL>
<DT><STRONG>FORMPATH</STRONG></DT>
<DD><A NAME="195"></A> The directory in which FORM will look for 
procedures and header files, assuming it cannot find them in the current 
directory.
</DD>
<DT><STRONG>FORMTMP</STRONG></DT>
<DD><A NAME="196"></A> The directory in which FORM will make its 
temporary files<A NAME="197"></A>.
</DD>
<DT><STRONG>FORMTMPSORT</STRONG></DT>
<DD><A NAME="198"></A> The directory in which FORM will make 
its temporary sort files.
</DD>
<DT><STRONG>FORMSETUP</STRONG></DT>
<DD><A NAME="200"></A> The full path and name of a setup 
file<A NAME="201"></A>.
</DD>
</DL>
It should be noted that when a parameter is specified both in the command 
tail and in the environment the value of the command tail will be used.

<P>
The third way to pass parameters at startup is by means of a setup 
file<A NAME="203"></A>. 
One of the first things FORM does is to locate such a startup file. The 
procedure that is being followed for this is:

<UL>
<LI>If the command tail specifies a setup file, FORM will use this file, 
ignoring all other indications with respect to the setup file. This assumes 
of course that this file exists. If it does not exist FORM passes on to the 
next option.
</LI>
<LI>If the command tail specifies a path for the setup file, FORM will 
try to open the file "form.set" in this directory. If this cannot be done 
(by lack of rights or because the file does not exist) FORM passes on to 
the next option.
</LI>
<LI>Next FORM tries to open the file "form.set"<A NAME="205"></A> in the 
current directory.
</LI>
<LI>If all else fails, FORM will look for the 
environment parameter FORMSETUP and use its value as the name of a setup 
file.
</LI>
</UL>
If all the above attempts fail, FORM will not use a setup file. For more 
information about the setup file one should consult the corresponding 
chapter on page <A HREF="#setup">17</A>.

<P>

<H1><A ID="SECTION00300000000000000000"></A>
<A ID="ch-variables"></A>
<BR>
Variables
</H1>

<P>
The objects of symbolic manipulations are expressions<A NAME="245"></A>. 
Expressions are built up from terms<A NAME="246"></A> and terms are composed of 
variables. FORM knows several types of variables, each 
of which has special rules assigned to it. The types of variables are 
symbols, vectors, indices, functions, sets, and expressions. In addition 
there are tensors and tables which are special functions, preprocessor 
variables<A NAME="248"></A> (see chapter&nbsp;<A HREF="#preprocessor">3</A>),
and there are dollar variables<A NAME="250"></A> (see 
chapter&nbsp;<A HREF="#dollars">6</A>). The expressions are used either in the definition 
of an expression or in the right hand side of an expression or a 
substitution. When an expression is used in the right hand side of another 
expression or a substitution, it will be replaced by its contents at the 
first opportunity. Therefore an expression will never occur as a variable 
in the output of other expressions and we will ignore their potential 
presence in the remainder of this chapter. Similarly preprocessor variables 
and  dollar variables will be replaced immediately when they are 
encountered.

<P>
The right hand side of an expression can consist of symbols, vectors, 
indices, functions and elements of a set. All these objects have to be 
declared before they can be used. The rules 
connected to each of these types of variables are described in the 
sections below.

<P>

<H1><A ID="SECTION00310000000000000000">
Names</A>
</H1>

<P>
There are two types of names<A NAME="253"></A>. Regular 
names<A NAME="254"></A> consist of alphabetic and numeric characters 
with the condition that the first character must be alphabetic. FORM is 
case sensitive with respect to names. In addition there are <B>formal 
names</B>. These names start with the character <code>[</code> and end with a 
matching character <code>]</code>. In between there can be any characters that 
are not intercepted by the preprocessor. This allows the use of variables 
like <code>[x+a]</code>. Using formal names can improve the readability of 
programs very much, while at the same time giving the user the benefits of 
the greater speed. The use of denominators<A NAME="257"></A> that are 
composite (like <code>1/(x+a)</code>) is usually rather costly in time. Often 
<code>1/[x+a]</code> is equally readable, while leading to the same results. Note 
however that the variable <code>[x+a]</code> will have to be declared properly. 
On the other hand: FORM may not have to know about x and a. These formal 
names can also be used for the names of expressions, but they are not valid 
for the names of dollar variables and the names of 
preprocessor variables<A NAME="259"></A>.

<P>
Some names may contain special characters. All built in objects have for 
their last character an underscore<A NAME="260"></A> (_). 
Dotproducts<A NAME="261"></A> (the scalar product of two vectors) consist 
of two vectors separated either by a period or by a dollar sign. The dollar 
sign is used by FORM, when the output of the program has to be 
Fortran<A NAME="263"></A> compatible. The user can replace the dollar sign in 
the output by an arbitrary character by defining the variable 
"DotChar"<A NAME="264"></A> in the setup<A NAME="265"></A> file. How this is 
done is explained in chapter&nbsp;<A HREF="#setup">17</A>. In the input the user may apply 
either the notation with the period or the notation with the dollar. It is 
however recommended to use the period<A NAME="267"></A> because in future 
versions the notation with the dollar may be dropped.  The above 
conventions avoid the possibility of conflicts with reserved names, 
allowing the user full freedom when choosing names. 

<P>
The dollar sign is also used as the first character in the name of dollar 
variables<A NAME="268"></A>. The rest of the name should consist of 
alphanumeric characters of which the first should be alphabetic. The names 
of preprocessor variables<A NAME="269"></A> should also consist 
of alphanumeric characters of which the first should be alphabetic. Also 
here the ones that are defined by the system have a trailing 
underscore<A NAME="270"></A> (_) character.

<P>
With respect to the user defined names FORM is case sensitive. This 
means that the variables a and A are different objects. With respect to 
system defined objects FORM is case insensitive. Hence both d_ and D_ 
indicate the same Kronecker delta.

<P>
In many languages the use of the underscore<A NAME="273"></A> (_) 
character is also permitted in the definition of user defined names. In 
FORM this is NOT the case. Even though the earlier manuals `forbade' 
this specifically there was a bug in earlier versions that permitted it to 
some degree. And because people don't read manuals, there were those who 
used this character and even made it into a vital part of their naming 
conventions. This then broke when version 3 was introduced. It should be 
clear though that the underscore character is reserved for a completely 
different type of future use and hence nothing can be done about this. Just 
remember: it is never a good idea to use undocumented features without 
consulting with the development team first.

<P>
The complex conjugate<A NAME="275"></A> of a complex 
quantity is indicated by the character <code>#</code> appended to the name of the 
variable. In the current version of FORM not much is done with it. The 
latest approach is that it is seen as obsolete. If possible, please avoid 
using it.

<P>
The length of names<A NAME="277"></A> is not restricted in FORM. There 
is one exception to this rule: names of expressions cannot be longer than 
16 characters. Of course in practise there are physical limits on the size 
of names, posed by the size of the memory of the computer being used.

<P>

<H1><A ID="SECTION00320000000000000000">
Symbols</A>
</H1>

<P>
<A ID="sect-symbols"></A>Symbols<A NAME="281"></A> are plain objects that behave most like normal 
variables in hand manipulations. Many hand manipulations concern 
polynomial formulae of simple algebraic variables. FORM assumes that 
symbols commute with all other objects and have a power connected to 
them. This power is limited to an installation dependent maximum and 
minimum. A power outside this range will lead to an error message. The 
user may override this built in restriction by one of private design that
is more restrictive. Any power that falls outside the user defined range 
leads to the removal of the term that contains the variable with this 
power. Such a power restriction can be defined for 
each symbol separately.

<P>
Symbols can also have complex conjugation<A NAME="283"></A> 
properties. A symbol can be declared to be real, imaginary or complex. This 
property is only relevant, when the complex conjugation operator is used. 
This operator has not been implemented and currently there are no plans to 
do so. 

<P>
The syntax of the statement that defines symbols is given by (see also 
<A HREF="#substasymbols">7.140</A>): 
<PRE>
     S[ymbols]    name[#{R|I|C}][(min:max)];
</PRE>
Each variable is declared by the presence of its name in a 
symbol-statement. If the # symbol is appended, it should be followed by 
either the character C, I or R to indicate whether the variable is 
complex<A NAME="287"></A>, imaginary<A NAME="288"></A> or real<A NAME="289"></A>. The 
#R is not really necessary, as the type `real' is the default. It is not 
relevant whether the C, I, R are in upper or in lower case. A power 
restriction<A NAME="290"></A> is indicated with a range between 
regular parentheses. If one of the two numbers is not present, the default 
value is taken. This default value is installation dependent, but it is at 
least -10000 and 10000 respectively. Each symbol-statement can define more 
than one variable. In that case the variables have to be separated either 
by comma's or by blanks. Example:
<PRE>
     S    x,y,z,a#c,b#c,c#c,r(-5:5),s(:20),t#i(6:9);
</PRE>
In this statement x, y and z are normal real algebraic variables. The 
variables a, b and c are complex. This means that for each of these 
variables two entries are reserved in the property lists: one for the 
variable and one for its complex conjugate. The variable r has a power 
restriction: Any power outside the specified range will cause the term 
containing this power to be eliminated. This is particularly useful in 
power series expansions. The restrictions on s are such that there is 
no limitation on the minimum power of s &ndash;with the exception of the 
built in restrictions&ndash; but a term with a power of s that is larger 
than 20 is eliminated. The variable t is imaginary. This means that 
under complex conjugation it changes sign. Its power restrictions are 
somewhat uncommon. Any power outside the range 6 to 9 is eliminated. 
There is however one exception: a term that does not contain t to any 
power (<SPAN CLASS="MATH"><IMG STYLE="height: 2.14ex; vertical-align: -0.11ex; " SRC="img1.svg"
 ALT="$t^0$"></SPAN>) is not affected. 
<PRE>
    s     x(:10),y;
    L     F=y^7;
    id    y=x+x^2;
    print;
    .end

Time =       0.01 sec    Generated terms =          4
                F        Terms in output =          4
                         Bytes used      =         54

   F =
      x^7 + 7*x^8 + 21*x^9 + 35*x^10;
</PRE>
Note that all terms with a power greater than 10 do not even count 
as generated terms. They are intercepted immediately after the 
replacement, before any possible additional statements can be 
carried out.

<P>
There are several built in symbols<A NAME="295"></A>. They are:

<P>
i_<A NAME="296"></A>: it is defined by <code>i_^2 = -1</code> and this 
property is used by FORM to simplify terms. It is the only symbol that 
cannot be used as a dimension or a wildcard.

<P>
pi_<A NAME="298"></A>: a reserved variable which will eventually be 
used to indicate the variable <SPAN CLASS="MATH"><IMG STYLE="height: 1.21ex; vertical-align: -0.11ex; " SRC="img2.svg"
 ALT="$\pi$"></SPAN>.

<P>
coeff_<A NAME="299"></A>: this variable is automatically replaced 
by the coefficient of the current term.

<P>
num_<A NAME="300"></A>: this variable is automatically replaced by 
the numerator of the coefficient of the current term.

<P>
den_<A NAME="301"></A>: this variable is automatically replaced by 
the denominator of the coefficient of the current term.

<P>
extrasymbols_<A NAME="302"></A>: this symbol represents the 
number of extra symbols (see <A HREF="#sect-extrasymbols">2.11</A>).

<P>

<H1><A ID="SECTION00330000000000000000">
Vectors</A>
</H1>

<P>
<A ID="sect-vectors"></A>A vector<A NAME="306"></A> is an object with a single index<A NAME="307"></A>. This 
index represents a number that indicates which component of the vector is 
meant. Vectors have a dimension<A NAME="308"></A> connected to them which is 
the dimension of the vector space in which they are defined. In FORM 
this dimension is by default set to 4. If the user likes to change this 
default, this can be done with the `Dimension'-statement. The use of this 
command affects the dimension of all vectors and the default dimension of 
indices. Its syntax is (see also <A HREF="#substadimension">7.33</A>):
<PRE>
     Dimension number;
</PRE>
or
<PRE>
     Dimension symbol;
</PRE>
The number must be a number that fits inside a FORM word which is 
an installation dependent size, but it will be at least 32767. 
The number must be positive or zero. Negative values are illegal. 
If a symbol is specified, it must have been declared before. Any symbol 
may be used with the exception of i_<A NAME="316"></A>. 

<P>
The declaration of vectors (see <A HREF="#substavectors">7.159</A>) is rather 
straightforward:
<PRE>
     V[ector] name [,MoreNames];
</PRE>
The names of the vectors may be separated either by comma's or 
by blanks. Example: 
<PRE>
     V    p,q;
     I    mu,nu;
     L    F=p(mu)*q(nu);
</PRE>

<P>

<H1><A ID="SECTION00340000000000000000">
Indices</A>
</H1>

<P>
<A ID="sect-indices"></A>Indices<A NAME="324"></A><A NAME="325"></A> are objects that represent a number 
that is used as an integer argument for counting purposes. They are used 
mostly as the arguments of vectors or multidimensional arrays (or tensors). 
Their main property is that they have a dimension<A NAME="326"></A>. This 
dimension indicates what values the index can take. A four-dimensional 
index can usually take the values 1 to 4. A very important property of an 
index is found in the convention that it is assumed that an index that is 
used twice in the same term is summed over. This is called the 
Einstein<A NAME="327"></A> summation<A NAME="328"></A> convention. 
Hence the term p(mu)<SPAN CLASS="MATH"><IMG STYLE="height: 1.29ex; vertical-align: -0.11ex; " SRC="img3.svg"
 ALT="$*$"></SPAN>q(mu) is equivalent to the scalar product of the 
vectors p and q (which can also be written as p.q). 

<P>
There are of course also indices that should not be summed over. 
Such indices we call zero-dimensional. This is just a convention. 
To declare indices we use the statement (see also <A HREF="#substaindex">7.74</A>): 
<PRE>
     Index name[={number|symbol}]
                   [,othername[={number|symbol}]];
</PRE>
When the equals sign is used, this indicates the specification of a 
dimension. Indices that are not followed by an equals sign get the 
dimension that is currently the default dimension (see also 
<A HREF="#substadimension">7.33</A>)). The dimension can be either a number that is 
zero or positive (zero indicates that the summation convention does not 
apply for this index) or it can be any symbol with the exception of the 
symbol i_. The symbol must have been declared before. 

<P>
The most important use of the dimension of an index is the built in rule 
that a Kronecker<A NAME="333"></A> delta<A NAME="334"></A> with twice 
the same index is replaced by the dimension of this index, provided this 
index has a non-zero dimension. Therefore when mu is 4-dimensional, d_(mu,
mu) will be replaced by 4 and when nu is n-dimensional, d_(nu,nu) will be 
replaced by n. If rho is zero dimensional, the expression d_(rho,rho) is 
left untouched.

<P>
In addition to the symbolic indices there is a number of fixed 
indices<A NAME="335"></A> with a numeric<A NAME="336"></A> value. 
The values of these indices runs from zero to an installation dependent 
number (usually 127). Users who like a different maximum value should 
consult chapter&nbsp;<A HREF="#setup">17</A> about the setup parameters. The numeric indices 
are all assumed to have dimension zero, hence no summation is applied to 
them. This means that they can be used for vector components. It is 
therefore perfectly legal to use:
<PRE>
     V    p,q,r;
     L    F=p(1)*q(1)*r(1)+p(2)*q(2)*r(2);
</PRE>
When two numeric indices occur inside the same Kronecker delta, a value 
is substituted for this delta. Normally this value is one, when the two 
indices are identical and zero, when they are different. The value for 
the diagonal elements can be changed with the 
`FixIndex'-statement (see also <A HREF="#substafixindex">7.59</A>): 
<PRE>
     Fi[xIndex] number:value [,number:value];
</PRE>
This command assigns to d_(number,number) the given value. 
This value must fit inside a single FORM word. This means that this 
value can at least be in the range -32768 to +32767. For more 
details on the size of a FORM word one should consult the 
installation manual. 

<P>
In the case of summable indices<A NAME="345"></A> the use of three 
times the same index in the same term would cause problems. FORM will 
execute the contraction for the first pair it encounters, after which the 
third index is left. In the case of four or more indices the pairing for 
the contractions depends on the order in which the parts of the term are 
processed. Hence to the user the result may seem to be quasi random. 
Nothing can be done about this and the user should guard against such 
ambiguous notation<A NAME="347"></A>.

<P>
There is a special version of the index declarations that is used for 
traces<A NAME="348"></A> of gamma<A NAME="349"></A> 
matrices<A NAME="350"></A> in n dimensions. If an index is declared with
<PRE>
    Symbols n,epsilon;
    Index m=n:epsilon;
</PRE>
its dimension will be n and it is assumed that epsilon can be used for 
<SPAN CLASS="MATH"><IMG STYLE="height: 2.53ex; vertical-align: -0.69ex; " SRC="img4.svg"
 ALT="$(n-4)$"></SPAN> during the taking of the trace of a string of gamma matrices. It 
is also possible to use this notation in the dimension-statement. See 
also chapter&nbsp;<A HREF="#gammaalgebra">14</A> on the gamma matrices.

<P>

<H1><A ID="SECTION00350000000000000000">
Functions</A>
</H1>

<P>
<A ID="sect-functions"></A>There are two classes of functions<A NAME="356"></A>: <B>commuting 
functions</B> which commute automatically with all other objects, and <B>non-commuting functions</B> which do not necessarily commute with other 
non-commuting functions. An object is declared to be a 
commuting<A NAME="359"></A> function<A NAME="360"></A> with the 
`cfunction' command. Of this command the first two characters are 
mandatory, the others optional. An object is declared to be a 
non-commuting<A NAME="361"></A> function<A NAME="362"></A> 
with the `function' command. Here only the f is mandatory. The declaration 
of a function knows one option. This option concerns the complexity 
properties of the function. It is indicated by a # following the name, 
after which one of the characters R, I, C specifies whether the function is 
real<A NAME="363"></A>, imaginary<A NAME="364"></A> or complex<A NAME="365"></A>. The 
declaration that a function is real is unnecessary as `real' is the default 
property. Example:
<PRE>
     CF   fa,fb,fc;
     F    ga,gb,gc#c;
</PRE>
In this example the functions fa, fb, fc are commuting and the 
functions ga, gb and gc are not necessarily commuting. In addition the 
function gc is complex. More about functions and their conventions 
is explained in chapter&nbsp;<A HREF="#functions">8</A>.

<P>
Within the commutation classes there are several types of special 
functions. Currently these are tensors<A NAME="369"></A> and 
tables<A NAME="370"></A>. The tables are described in section&nbsp;<A HREF="#substatable">7.142</A> 
and in chapter&nbsp;<A HREF="#tablebase">12</A>.

<P>
Tensors<A NAME="373"></A> are special functions. Their arguments can be 
indices and vectors only. When an argument is a vector, it is assumed that 
this vector has been put in this position as the result of an 
Einstein<A NAME="374"></A> summation<A NAME="375"></A>, i.e., there 
used to be an index in this position, but the index was contracted with the 
index of the vector. Hence FORM assumes that there is a linearity 
property with respect to such vectors. Tensors are declared with one of the 
following statements (see also pages&nbsp;<A HREF="#substatensors">7.144</A>,
<A HREF="#substantensors">7.102</A>, <A HREF="#substactensors">7.27</A>):
<PRE>
    T[ensors] t1;
    CT[ensors] t2;
    NT[ensors] t3;
</PRE>
The type `ntensor' indicates a non-commuting tensor, while the other two 
types indicate commuting tensors. Note that the 'T' is a 
commuting tensor, while the 'F' indicates a non-commuting function. In 
addition to the above declarations one may add the same complexity 
properties that can be added for functions. This is currently not very 
useful though as there exists no complex conjugation 
operator yet. Internally a tensor is a function with special properties. 
Hence when function properties are discussed, usually these properties 
refer also to tensors, unless the type of the arguments would not allow 
the operations or arguments specified.

<P>

<H1><A ID="SECTION00360000000000000000">
Sets</A>
</H1>

<P>
<A ID="sect-sets"></A>A set<A NAME="384"></A> is a (non-empty) collection of variables that should 
all be of the same type. This type can be symbols, vectors, indices or 
functions. A set has a name which can be used to refer to 
it, and this name may not coincide with any of the other names in the 
program. A set is declared by giving its name, followed by a 
colon<A NAME="385"></A>, after which the elements of the set are listed. The first 
element determines the type of all the elements of the set. All 
elements must have been declared as variables before the set-statement. 
There can be only one set per statement. Example (see also 
<A HREF="#substaset">7.129</A>): 
<PRE>
     s    xa, xb, xc, xd, ya, x, y;
     i    mu, nu, rho;
     set exxes: xa, xb, xc, xd;
     set yyy: xc, xd, xb, ya;
     set indi:  mu, nu, rho, 1, 2, 3;
     set xandy: xa, ya;
</PRE>
We see here that a single symbol (xa) can belong to more than one set. 
Also the fixed indices (1, 2 and 3) can be elements 
of a set of indices and the numbers that can be powers can also be 
members of a set of symbols (usually -9999 to + 9999). If this can cause 
confusion, FORM will give a warning and interpret the set as a 
set of symbols.

<P>
In addition to the user defined sets there are some built in sets with a 
special meaning. These are:
<DL>
<DT><STRONG>int_</STRONG></DT>
<DD><A NAME="391"></A> This is a set of symbols. It refers to all integer numbers 
	that fit inside a FORM word.
</DD>
<DT><STRONG>pos_</STRONG></DT>
<DD><A NAME="393"></A> This is a set of symbols. They are the positive integers that 
    fit inside a FORM word.
</DD>
<DT><STRONG>pos0_</STRONG></DT>
<DD><A NAME="395"></A> A set of symbols. They are all non-negative integers that 
fit inside a FORM word.
</DD>
<DT><STRONG>neg_</STRONG></DT>
<DD><A NAME="397"></A>  A set of symbols. They are all negative integers that 
fit inside a FORM word.
</DD>
<DT><STRONG>neg0_</STRONG></DT>
<DD><A NAME="399"></A>  A set of symbols. They are all non-positive integers that 
fit inside a FORM word.
</DD>
<DT><STRONG>symbol_</STRONG></DT>
<DD><A NAME="401"></A> The set of all formal symbols. It excludes integers, 
    numbers and whole function arguments.
</DD>
<DT><STRONG>fixed_</STRONG></DT>
<DD><A NAME="402"></A> The set of all fixed indices.
</DD>
<DT><STRONG>index_</STRONG></DT>
<DD><A NAME="403"></A> The set of all indices.
</DD>
<DT><STRONG>vector_</STRONG></DT>
<DD><A NAME="404"></A> The set of all (auto)declared vectors.
</DD>
<DT><STRONG>number_</STRONG></DT>
<DD><A NAME="405"></A> The set of all rational numbers.
</DD>
<DT><STRONG>even_</STRONG></DT>
<DD><A NAME="406"></A> This is a set of symbols. It refers to all even integer numbers 
	that fit inside a FORM word.
</DD>
<DT><STRONG>odd_</STRONG></DT>
<DD><A NAME="408"></A> This is a set of symbols. It refers to all odd integer numbers 
	that fit inside a FORM word.
</DD>
<DT><STRONG>dummyindices_</STRONG></DT>
<DD><A NAME="410"></A> This is a set of indices. It refers to all 
	indices of the type Nm_? (m a positive integer) that were obtained by
    summing over indices with a sum statement<A NAME="411"></A> <A HREF="#substasum">7.138</A>.
</DD>
</DL>

<P>
Sets can be used during wildcarding<A NAME="414"></A>. When x is a symbol, 
the notation x? indicates `any symbol'. This is sometimes more than we 
want. In the case that we would like `any symbol that belongs to the set 
exxes' we would write x?exxes which is an unique notation as usually 
the question mark cannot be followed by a name. There should be no blank 
between the question mark and the name of the set. The object x?indi 
would result in a type mismatch error, if x is a symbol and indi a set of 
indices. 

<P>
This use of wildcards belonging to sets can be extended even more: 
The notation x?exxes?yyy means that x should belong to the set exxes, and
its replacement should be the corresponding element of set yyy. At first 
this notation looks unnecessarily complicated. The statement 
<PRE>
     id   x?exxes?yyy = x;
</PRE>
should have the much simpler syntax
<PRE>
     id   exxes = yyy;
</PRE>
This last notation cannot be maintained, when the patterns are more 
complicated, hence it has been omitted altogether.

<P>
When things become really complicated<A NAME="419"></A>, the sets can be 
used as kind of an array. They can be used with a fixed array index 
(running from 1 for the first element). When they have a symbolic argument 
(must be a symbol), they are either in the right hand side of an 
id-statement and the symbol must be replaced by a number by means of a 
wildcard substitution or in the left hand side and the symbol is 
automatically seen as a wildcard. The set must still follow the question 
mark of a wildcard. An example will clarify the above:
<PRE>
    s a1,a2,a3,b1,b2,b3,x,n;
    f g1,g2,g3,g;
    set aa:a1,a2,a3;
    set bb:b1,b2,b3;
    set gg:g1,g2,g3;
   
    id  g(x?aa[n]) = gg[n](bb[n]) + bb[2]*n;
</PRE>
The n in the left hand side is automatically a symbol wildcard. x must 
match an element in aa and n takes its number. In the right hand side 
<code>gg[n]</code> becomes an array element, when the n is substituted. The 
same holds for <code>bb[n]</code>. The element <code>bb[2]</code> is immediately 
replaced by b2, so there is rarely profit by using this, unless the 
preprocessor had something to do with the construction of this 
quantity. As should be clear from the above: the array elements are 
indicated with straight braces<A NAME="422"></A>. 

<P>
Another use of sets is in the select  
option<A NAME="423"></A> of the id-statement. This is discussed in 
chapter&nbsp;<A HREF="#pattern">5</A> on pattern<A NAME="425"></A> matching. 

<P>
Neither the array properties of the sets nor the select option of the 
id-statement can be used in conjunction with the built in sets. These 
sets are not supposed to have a finite number of indices.

<P>
Apart from the above sets that were formally declared and used by name 
there is a second way to use sets. These sets are called <B>implicitly 
declared sets<A NAME="426"></A></B>. They are declared at the 
position that they are used and their use defines their contents. The 
elements of the set should be enclosed by a pair of curly 
brackets<A NAME="427"></A> and the set is placed at the position where 
otherwise the name of the set would be used:
<PRE>
    Symbols a1,a2,a3,b1,b2,b3,x,n;
    CFunctions g1,g2,g3,g;
    Local expr =
        g(a1)+g(a2)+g(a3)+g(x);
    id,g(x?{a1,a2,a3}[n]) = {g1,g2,g3}[n]({b1,b2,b3}[n]);
    print;
    .end

   expr =
      g1(b1) + g2(b2) + g3(b3) + g(x);
</PRE>
Such a set exists internally only till the end of the module in which it 
is used. It can be used at all positions where named sets can be used. 
Hence they can also be used, when the array properties of sets are 
considered.

<P>
The preprocessor has to be able to distinguish these sets from strings for 
its calculator<A NAME="430"></A> (see 
chapter&nbsp;<A HREF="#preprocessor">3</A>). Usually this is no problem, because any 
regular name contains at least one character that is not accepted by this 
calculator. If the only elements in the set are numeric the 
comma<A NAME="432"></A> will tell the preprocessor that it is a set and the 
calculator should not be used. This leaves the case of a set with a single 
numeric element. By placing a comma either before or after it the use of 
the calculator is vetoed. For the interpretation of the set this makes no 
difference.

<P>
When it is possible to demand an object to be inside a 
set<A NAME="433"></A>, it should also be possible to demand that an object 
be outside a set<A NAME="434"></A>. This is done with the `?!' operator 
instead of the `?' operator. The extra exclamation<A NAME="435"></A> mark 
is like a `not' operator. It can be used only, when its use makes sense. 
Hence it cannot be used in conjunction with the array properties of sets 
and together with the select option of the id-statement. So its only use is 
in patterns of the type
<PRE>
    x?!setname
    x?!{a,b,c}
</PRE>
as is done in
<PRE>
    id  x^n?!{,-1} = x^(n+1)/(n+1);
</PRE>
There is a variation of the second type that is not possible with named 
sets<A NAME="440"></A>:
<PRE>
    Symbols a,b,x,y,z;
    CFunction f;
    
    id  f(x?!{a,y?,z?})*f(y?!{b,x?,z?})*f(z?!{x?,y?})
            =  .........
</PRE>
In this complicated pattern the z is easiest: It is not allowed to be equal 
to the objects that will be substituted for the wildcards x and y. The 
symbol x cannot be equal to the wildcards y and z, but in addition it 
should not be equal to a. A similar condition holds for y. One could argue 
that at least one of these conditions is superfluous from the strictly 
logical viewpoint. It depends however on the order of the declarations in 
how FORM runs through the pattern, so it would require some trying to 
see which `not' specifications are superfluous. If for instance the first 
function is matched first, there is still no assignment for z. This means 
that the z? in the set cannot be used yet and hence it places no 
restrictions on x. Therefore it is the x? in the last function that causes 
x and z to be different. If on the other hand the last function would be 
matched first, we need the z? in the set of the first function. From the 
strict logical viewpoint, FORM could go back over the pattern and still 
make the appropriate rejections, but this would cost too much extra time. 
As one can see, it is safer to specify both.

<P>

<H1><A ID="SECTION00370000000000000000">
The autodeclare conventions</A>
</H1>

<P>
As we have seen above, all variables that are introduced by the user have 
to be declared. As such FORM is a strong<A NAME="447"></A> typing 
language. This isn't always handy. Hence it is possible to introduce some 
rules about the automatic declaration of classes of variables. This is done 
with the AutoDeclare<A NAME="448"></A> statement (see also 
<A HREF="#substaautodeclare">7.10</A>). If we use the statements
<PRE>
     AutoDeclare Symbol x,tt;
     AutoDeclare CFunction f,t;
</PRE>
any object encountered by the compiler of which the name starts with the 
character x will automatically be declared as a symbol. Also objects of 
which the name starts with the characters tt will be declared as symbols. 
Objects of which the name starts with the characters f or t, but not with 
the string tt, and that have not yet been declared will be declared 
automatically as commuting functions. As one can see, in the case of 
potential conflicts<A NAME="452"></A> (like with t and tt) the more 
restrictive one takes precedence. This is independent of the order of the 
AutoDeclare statements. One disadvantage of the use of the AutoDeclare 
statement is that one looses a certain amount of control over the order of 
declaration of the variables, as now they will be declared in the order in 
which they occur in the statements. The order of the declaration determines 
the ordering of the objects in the output.

<P>

<H1><A ID="SECTION00380000000000000000">
Name lists</A>
</H1>

<P>
<A ID="sect-namelists"></A>Sometimes it is necessary to see how FORM has interpreted a set
of declarations. It can also be that declarations were made in an unlisted 
include file and that the user wants to know what variables have been 
defined. The lists<A NAME="456"></A> of active variables<A NAME="457"></A> 
can be printed with the statement
<PRE>
     On names;
</PRE>
This statement sets a flag that causes the listing of all name tables and 
default properties that are active at the moment that the compiler has 
finished compiling the current module and all modules after. The printing 
is just before the algebra processor takes over for the execution of the 
module &ndash; assuming that no error condition exists. If the `On names' is 
specified in a module that ends with a .global-instruction, the name lists 
will be printed at the end of each module, as printing the name lists will 
then be the default option. If one likes to switch this flag off, this can 
be done with the statement
<PRE>
     Off names;
</PRE>
which prohibits the printing of the name lists in the current module and 
all modules following.

<P>

<H1><A ID="SECTION00390000000000000000">
Dummy indices</A>
</H1>

<P>
<A ID="sect-dummies"></A>Sometimes indices<A NAME="464"></A> are to be summed over but due to the 
evaluation procedures some terms contain the index mu and other terms 
contain the index nu. There is a command to sum over indices in such a way 
that FORM recognizes that the exact name of the index is irrelevant. 
This is the `sum'-statement (see also <A HREF="#substasum">7.138</A>):<PRE>
   i  mu,nu;
   f  f1,f2;
   L  F=f1(mu)*f2(mu)+f1(nu)*f2(nu);
   sum  mu;
   sum  nu;
   print;
   .end
</PRE>
At first the expression contains two terms. After the summations FORM 
recognizes the terms as identical. In the output we see the term: 
<PRE>
   2*f1(N1_?)*f2(N1_?)
</PRE>
The <code>N1_?</code> are dummy indices. 
The dimension of these dummy indices is the current 
default dimension<A NAME="472"></A> as set with the last 
dimension-statement. This may look like it is a restriction, but in 
practice it is possible to declare the default dimension to have one 
value in one module, take some sums, and do some more operations, and 
then give the default dimension another value in the next module. It should 
be realized however that then the dimension of the already existing dummy 
indices may change with it.

<P>
The scheme that is used to renumber<A NAME="473"></A> the 
indices<A NAME="474"></A> in a term is quite 
involved. It will catch nearly all possibilities, but in order to avoid 
to try all <SPAN CLASS="MATH"><IMG STYLE="height: 1.82ex; vertical-align: -0.11ex; " SRC="img5.svg"
 ALT="$n!$"></SPAN> permutations, when there are n pairs of dummy indices, 
FORM does not try everything. It is possible to come up with examples 
in which the scheme is not perfect. It is left as a 
challenge for the reader to find such an example. In the case that the 
scheme isn't sufficient one can use the Renumber statement (see 
<A HREF="#substarenumber">7.124</A>) to force a complete renumbering. As this involves 
n! attempts in which n is the number of different dummy indices, this can 
become time consuming.

<P>
These dummy indices can be used to solve a well known problem in the 
automatic summation of indices. This problem occurs, when summed indices 
are found inside a subexpression that is raised to a power:
<PRE>
    Index mu,nu;
    CFunctions f,g;
    Vectors p,q;
    Local F = (f(mu)*g(mu))^2;
    sum mu;
    id f(nu?) = p(nu);
    id g(nu?) = q(nu);
    print;
    .end

   F =
      p.p*q.q;
</PRE>
Clearly the answer is not what we had in mind, when we made the program. 
There is an easy way out:
<PRE>
    Index mu,nu;
    Symbol x;
    CFunctions f,g;
    Vectors p,q;
    Local F = x^2;
    repeat;
        id,once,x = f(mu)*g(mu);
        sum mu;
    endrepeat;
    id f(nu?) = p(nu);
    id g(nu?) = q(nu);
    print;
    .end

   F =
      p.q^2;
</PRE>
This time things went better, because each sum-statement moves an index 
mu to a new dummy index.

<P>
There are some extra problems connected to dummy indices. Assume that we 
have the expression F which contains
<PRE>
     F = f(N1_?,N2_?)*f(N2_?,N1_?);
</PRE>
and next we have the module
<PRE>
     Indices mu,nu,rho,si;
     Vectors p1,p2,p3,v;
     Tensor g;
     Local G = e_(mu,nu,rho,si)*g(mu,nu,p1,v)*g(rho,si,p2,v);
     sum mu,nu,rho,si;
     Multiply F^3;
     id  v = e_(p1,p2,p3,?);
     print;
     .end

   G =
      f(N1_?,N2_?)*f(N2_?,N1_?)*f(N3_?,N4_?)*f(N4_?,N3_?)*
      f(N5_?,N6_?)*f(N6_?,N5_?)*g(N7_?,N8_?,p1,N9_?)*
      g(N10_?,N11_?,p2,N12_?)*e_(p1,p2,p3,N9_?)*
      e_(p1,p2,p3,N12_?)*e_(N7_?,N8_?,N10_?,N11_?);
</PRE>
Here the situation with the dummy indices becomes rather messy, and all 
earlier versions of FORM were not prepared for this. Their answer could be:
<PRE>
    G =
      f(N1_?,N2_?)*f(N1_?,N2_?)*f(N1_?,N2_?)*f(N2_?,N1_?)*
      f(N2_?,N1_?)*f(N2_?,N1_?)*g(N1_?,N2_?,p2,N3_?)*
      g(N4_?,N5_?,p1,N6_?)*e_(p1,p2,p3,N3_?)*
      e_(p1,p2,p3,N6_?)*e_(N1_?,N2_?,N4_?,N5_?);
</PRE>
which is clearly not what the program is supposed to give. In the current 
version we have made the tracing of the dummy indices and the renumbering 
of them at the proper moment a lot better. It is however not complete as a 
complete implementation might severely influence the speed of execution at 
some points. The scheme is complete for the inclusion of local and global 
expressions. On the other hand it doesn't work for the contents of dollar 
variables<A NAME="488"></A>. Neither does it work for dummy indices 
introduced in user defined code as in
<PRE>
     id  x^n? = (f(N1_?)*g(N1_?))^n;
</PRE>
For the latter case we showed a workaround above. Anyway there is a certain 
ambiguity here. Just imagine we write
<PRE>
     id  x^n? = f(N1_?)^n*g(N1_?)^n;
</PRE>
Formally it is exactly the same, but what we mean is far from clear. For 
the dollar variables we considered the contracted dummy indices rare enough 
that it doesn't merit sacrificing speed. And then there is one more little 
caveat<A NAME="493"></A>. Global expressions that were stored with older 
versions of FORM than version 3.2, but are read with version 3.2 or later 
would have a problem if the expression were to contain dummy indices. The 
newer version of the .sav files<A NAME="495"></A> will contain information 
about the dummy indices. FORM can still read the old versions but will 
have to `invent' information by assuming that there are no dummy indices. 
If there are expressions with such dummy indices the best is to copy the 
expressions to a new expression and let the copying be followed by a .sort. 
That should set things straight. A final remark: if an elegant solution is 
found with which the above cases could be made to work without the penalty 
in execution time, it will be built in in the future.

<P>

<H1><A ID="SECTION003100000000000000000">
Kronecker delta's</A>
</H1>

<P>
<A ID="sect-kroneckerdelta"></A>The built in object d_ represents the Kronecker<A NAME="499"></A> 
delta<A NAME="500"></A>. Even though this 
object looks a little bit like a tensor, internally it isn't treated as 
such. Actually it has its own data type. It must have exactly two arguments 
and these arguments should be either indices or vectors. A d_ with at 
least one vector is immediately replaced, either by a vector with an index 
(if there is one vector and one index) or by a dotproduct (when there are 
two vectors). If a Kronecker delta contains an index that occurs also at 
another position in the same term, and if that index is summable, and if 
the index occurs as the index of a vector, inside a tensor, inside another 
d_ or as the argument of a function, and the object inside which it occurs 
is not inside the argument of a function itself (unless the d_ is inside 
the same argument) then the Einstein<A NAME="501"></A> 
summation<A NAME="502"></A> convention is used and the 
d_ is eliminated, while the second occurrence of the index is replaced by 
the other index in the d_ (Are you still with us?). When a 
Kronecker delta has two identical indices and these indices are summable, 
the d_ is replaced by the dimension of the index. If they are fixed 
indices, the d_ is replaced by one, unless this value has been altered 
with the fixindex-statement. Some examples of Kronecker delta's are given 
in section&nbsp;<A HREF="#fund">8.7</A>.

<P>

<H1><A ID="SECTION003110000000000000000">
Extra Symbols</A>
</H1>

<P>
<A ID="sect-extrasymbols"></A><A ID="extrasymbols"></A>Starting with version 4.0 FORM is equipped with a mechanism to replace
non-symbol objects by internally generated symbols. These are called the 
extra symbols. Their numbering starts at maximum number allowed for 
internal objects and then counts down. Hence their ordering will be 
opposite to what might otherwise be expected. It is possible to control 
their representation when they are to be printed in the output. For this 
there is the ExtraSymbols (<A HREF="#substaextrasymbols">7.53</A>) statement. The 
definitions of the extra symbols can be made visible with the %X option in 
the #write preprocessor instruction.

<P>
Extra symbols can be introduced by the user with the ToPolynomial statement 
(<A HREF="#substatopolynomial">7.148</A>). This statement replaces all objects that are 
not numbers or symbols to positive powers by extra symbols. This may be 
needed for some new manipulations and can also be very handy for output 
that is to be treated by for instance a FORTRAN or C compiler. The 
FromPolynomial statement replaces the extra symbols again by their original 
meaning.

<P>
<PRE>
    Vector p,q,p1,p2;
    CFunction f;
    CFunction Dot,InvDot;
    Symbol x,x1,x2;
    Set pdot:p,q;
    Off Statistics;
    Local F = x+x^2+1/x+1/x^2+f(x1)+f(x2)*p.q*x+f(x2)/p.q^2;
    id  p1?pdot.p2?pdot = Dot(p1,p2);
    id  1/p1?pdot.p2?pdot = InvDot(p1,p2);
    Print;
    .sort

   F =
      x^-2 + x^-1 + x + x^2 + f(x1) + f(x2)*Dot(p,q)*x + f(x2)*InvDot(p,q)^2;

    ExtraSymbols,array,Y;
    Format DOUBLEFORTRAN;
    ToPolynomial;
    Print;
    .sort

      F =
     &amp; Y(1) + Y(1)**2 + Y(2) + Y(5)**2*Y(3) + x + x*Y(4)*Y(3) + x**2

    #write &lt;sub.f&gt; "      SUBROUTINE sub(Y)"
    #write &lt;sub.f&gt; "*"
    #write &lt;sub.f&gt; "*      Compute the extra symbols. Generated on `DATE_'"
    #write &lt;sub.f&gt; "*"
    #write &lt;sub.f&gt; "      REAL*8 Y(`EXTRASYMBOLS_')"
    #write &lt;sub.f&gt; "      REAL*8 Dot,InvDot"
    #write &lt;sub.f&gt; "      Dot(p1,p2)=p1(1)*p2(1)-p1(2)*p2(2)-p1(3)*p2(3)\
                                                              -p1(4)*p2(4)"
    #write &lt;sub.f&gt; "      InvDot(p1,p2)=1.D0/(Dot(p1,p2))"
    #write &lt;sub.f&gt; "*"
    #write &lt;sub.f&gt; "*        We still have to add definitions here."
    #write &lt;sub.f&gt; "*        And we have to import all the variables."
    #write &lt;sub.f&gt; "*"
    #write &lt;sub.f&gt; "%X"
    #write &lt;sub.f&gt; "*"
    #write &lt;sub.f&gt; "      RETURN"
    #write &lt;sub.f&gt; "      END"
    ExtraSymbols,underscore,Z;
    Format Normal;
    Format 80;
    Print;
    .end

   F =
      Z1_ + Z1_^2 + Z2_ + Z5_^2*Z3_ + x + x*Z4_*Z3_ + x^2;

    FromPolynomial;
    Print;
    .end

   F =
      x^-2 + x^-1 + x + x^2 + f(x1) + f(x2)*Dot(p,q)*x + f(x2)*InvDot(p,q)^2;
</PRE>
In the ExtraSymbols statement we say that we want the extra symbols to be 
presented as an array with the name Y. The alternative is a set of symbols 
with names ending in an underscore, but that would not make the FORTRAN 
compiler very happy. Then we convert the expression to symbols. As one can 
see, everything got converted to elements of an array Y which are treated 
as symbols. After we have written the file sub.f (notice that 
EXTRASYMBOLS_ is a built in symbol indicating the number of extra symbols) 
we change the representation to the (default) notation with an underscore 
and the character Z. The contents of the file sub.f are:
<PRE>
      SUBROUTINE sub(Y)
*
*      Compute the extra symbols. Generated on Sat Apr  2 20:40:33 2011
*
      REAL*8 Y(5)
      REAL*8 Dot,InvDot
      Dot(p1,p2)=p1(1)*p2(1)-p1(2)*p2(2)-p1(3)*p2(3)-p1(4)*p2(4)
      InvDot(p1,p2)=1.D0/(Dot(p1,p2))
*
*        We still have to add definitions here.
*        And we have to import all the variables.
*
      Y(1)=x**(-1)
      Y(2)=f(x1)
      Y(3)=f(x2)
      Y(4)=Dot(p,q)
      Y(5)=InvDot(p,q)

*
      RETURN
      END
</PRE>
As one can see, with very little effort this routine can be made into a 
proper subroutine that computes all elements of the array Y which can then 
be used for computing the expression F.

<P>

<H1><A ID="SECTION003120000000000000000">
Restrictions</A>
</H1>

<P>
There is a restriction<A NAME="515"></A> on the total number of 
variables<A NAME="516"></A> that FORM can handle. For the 
number of symbols, vectors, indices, functions and sets together the exact 
number depends on the type of computer. For a computer with a 32-bits 
processor this number is 32768. This includes the built in objects. 
Individual types of variables (like symbols) are usually restricted to 
about 8000. For a 
computer with a 64-bits processor the maximum has been set arbitrarily at 
2000000000. In addition there are restrictions on the total amount of 
memory<A NAME="518"></A> needed by FORM to maintain an 
administration of all these variables. These restrictions are set by the 
memory allocator of the computer on which FORM is running.

<P>

<H1><A ID="SECTION003130000000000000000">
Some common bugs</A>
</H1>

<P>
There is a type of error<A NAME="522"></A><A NAME="523"></A> by the user (including at 
times the author) that is so common that it deserves mentioning here. 
Consider the code:
<PRE>
     Symbol x1,x2
     Index m1,m2;
</PRE>
As a statement it is perfectly legal<A NAME="526"></A>, but it may produce 
rather funny errors at a later stage when we try to use m1 or m2. 
Inspection with the `On names;' statement shows that we have the symbols 
x1,x2,Index,m1,m2. This is most likely not what the user wanted. Closer 
inspection shows that we forgot the semicolon at the end of the symbol 
statement. We should have had:
<PRE>
     Symbol x1,x2;
     Index m1,m2;
</PRE>
This is the most common error for which FORM cannot give a direct error 
message (it is after all a legal statement). Hence when faced with 
mysterious errors or error messages, one could have a good look by using 
the `On names' statement. Maybe it shows something, and if not, one has to 
look for other causes.

<P>

<H1><A ID="SECTION00400000000000000000"></A>
<A ID="preprocessor"></A>
<BR>
The preprocessor
</H1>

<P>
The preprocessor<A NAME="723"></A> is a program segment that reads and 
edits<A NAME="724"></A> the input, after which the processed input is offered to 
the compiler<A NAME="725"></A> part of FORM. When a module<A NAME="726"></A> 
instruction is encountered by the preprocessor, the compilation is halted 
and the module is executed. The compiler buffers are cleared and FORM  
will continue with the next module. The preprocessor acts almost purely on 
character strings. As such it does not know about the algebraic properties 
of the objects it processes. Additionally the preprocessor also filters out 
the commentary<A NAME="727"></A>.

<P>
The commands for the preprocessor are called instructions. Preprocessor 
instructions start with the character # as the first non-blank character 
in a line. After this there are several possibilities.
<DL>
<DT><STRONG>#:</STRONG></DT>
<DD><A NAME="729"></A> Special syntax for setup parameters at the beginning 
of the program. See the chapter on the setup parameters.
</DD>
<DT><STRONG>#<SPAN CLASS="MATH"><IMG STYLE="height: 1.75ex; vertical-align: -0.30ex; " SRC="img6.svg"
 ALT="$-$"></SPAN>, #<SPAN CLASS="MATH"><IMG STYLE="height: 1.75ex; vertical-align: -0.30ex; " SRC="img7.svg"
 ALT="$+$"></SPAN></STRONG></DT>
<DD><A NAME="730"></A><A NAME="731"></A> Turns the listing of the input off or 
on.
</DD>
<DT><STRONG>#name</STRONG></DT>
<DD><A NAME="732"></A> Preprocessor command. The syntax of the various 
commands will be discussed below.
</DD>
<DT><STRONG>#$name</STRONG></DT>
<DD><A NAME="733"></A> Giving a value to a dollar variable in the 
preprocessor. See chapter <A HREF="#dollars">6</A> on dollar variables.
</DD>
</DL>

<P>

<H1><A ID="SECTION00410000000000000000"></A>
<A ID="preprovariables"></A>
<BR>
The preprocessor variables
</H1>

<P>
In order to help in the edit<A NAME="738"></A> function the preprocessor is 
equipped with variables<A NAME="739"></A> that can be defined 
or redefined by the user or by other preprocessor actions. Preprocessor 
variables have regular names that are composed of strings of alphanumeric 
characters of which the first one must be alphabetic. When they are defined 
one just uses this name. When they are used the name should be enclosed 
between a backquote<A NAME="740"></A> and a quote<A NAME="741"></A> as if these 
were some type of brackets. Hence `a2r' is the reference to a regular 
preprocessor variable. Preprocessor variables contain strings of 
characters. No interpretation is given to these strings. The 
backquote/quote pairs can be nested. Hence `a`i'r' will result in the 
preprocessor variable `i' to be substituted first. If this happens to be 
the string "2", the result after the first substitution would be `a2r' and 
then FORM would look for its string value.

<P>
The use of the backquotes is different from the earlier versions of FORM. 
There the preprocessor variables would be enclosed in a pair of quotes and 
no nesting<A NAME="742"></A> was possible. FORM still understands this old 
notation because it does not lead to ambiguities. The user is however 
strongly advised to use the new notation with the backquotes, because in 
future versions the old<A NAME="743"></A> notation may not be recognized 
any longer.

<P>
FORM has a number of built in preprocessor variables. They are:

<P>
<DL>
<DT><STRONG>VERSION_</STRONG></DT>
<DD>The current version<A NAME="745"></A> as the 4 in 
                4.3.
</DD>
<DT><STRONG>SUBVERSION_</STRONG></DT>
<DD>The sub-version<A NAME="747"></A> as the 3 in 
                4.3.
</DD>
<DT><STRONG>NAME_</STRONG></DT>
<DD>The name<A NAME="749"></A> of the program file.
</DD>
<DT><STRONG>DATE_</STRONG></DT>
<DD>The date<A NAME="750"></A> of the current run.
</DD>
<DT><STRONG>CMODULE_</STRONG></DT>
<DD>The number<A NAME="751"></A> of the current module.
</DD>
<DT><STRONG>SHOWINPUT_</STRONG></DT>
<DD>If input listing<A NAME="752"></A> is on: 1, if off: 0.
</DD>
<DT><STRONG>EXTRASYMBOLS_</STRONG></DT>
<DD>The current number of extra symbols<A NAME="753"></A>
       (see <A HREF="#substaextrasymbols">7.53</A>).
</DD>
<DT><STRONG>OLDNUMEXTRASYMBOLS_</STRONG></DT>
<DD>The number of extra symbols<A NAME="755"></A>
            before the current optimization started (see chapter <A HREF="#optimization">10</A>).
</DD>
<DT><STRONG>OPTIMMINVAR_</STRONG></DT>
<DD>The number of the first extra symbol<A NAME="757"></A> needed
               for the current optimization (see chapter <A HREF="#optimization">10</A>).
</DD>
<DT><STRONG>OPTIMMAXVAR_</STRONG></DT>
<DD>The number of the last extra symbol<A NAME="759"></A> needed
               for the current optimization (see chapter <A HREF="#optimization">10</A>).
</DD>
<DT><STRONG>OPTIMSCHEME_</STRONG></DT>
<DD>The best Horner scheme<A NAME="761"></A> found 
               for the current optimization (see chapter&nbsp;<A HREF="#optimization">10</A>).
</DD>
<DT><STRONG>OPTIMVALUE_</STRONG></DT>
<DD>The number of arithmetic operations<A NAME="763"></A> 
               in the resulting expression for the current optimization 
               (see chapter&nbsp;<A HREF="#optimization">10</A>).
</DD>
<DT><STRONG>PID_</STRONG></DT>
<DD>The process identifier (PID) <A NAME="765"></A> <A NAME="766"></A> of
               the running process. In P<SMALL>AR</SMALL>FORM (<A HREF="#parform">18.2</A>), it represents
               the PID of the master process in order to ensure that all the
               processes in a job use the same number. A recovered session from
               a checkpoint (<A HREF="#checkpoints">4.1</A>) keeps using the PID of the
               crushed session.
</DD>
<DT><STRONG>STOPWATCH_</STRONG></DT>
<DD>Same as `TIMER_'.
</DD>
<DT><STRONG>SYSTEMERROR_</STRONG></DT>
<DD>The return value of the last #system<A HREF="#presystem">3.58</A>
               command when invoked with the -e<A NAME="771"></A> option.
</DD>
<DT><STRONG>TIME_</STRONG></DT>
<DD>The running time<A NAME="772"></A> till the moment of call in the string format
               with a decimal point and two digits after the decimal point. 
               This is the same format as in the statistics.
</DD>
<DT><STRONG>TIMER_</STRONG></DT>
<DD>The running time<A NAME="773"></A> since the last reset in milliseconds. Hence, 
               unlike `time_' this value can be used in the preprocessor 
               calculator and in numerical compares in #if instructions.
               See also the #reset (see <A HREF="#prereset">3.48</A>) instruction.
</DD>
<DT><STRONG>NUMACTIVEEXPRS_</STRONG></DT>
<DD>The number of the currently active expressions.
</DD>
<DT><STRONG>ACTIVEEXPRNAMES_</STRONG></DT>
<DD>The list of the currently active expression names 
               separated by commas. This can be passed to #do lvar={...} 
               instruction&nbsp;(<A HREF="#predo">3.19</A>) like: 
<PRE>
    #do e = {`activeexprnames_'}
        #ifdef `e'
            Local `e' = `e' + something;
        #endif
    #enddo
</PRE>
</DD>
</DL>

<P>
If FORM cannot find a preprocessor variable, because it has 
neither been defined by the user, nor is it one of the built in variables, 
it will look in the systems environment<A NAME="779"></A> to see whether 
there is an environment variable by that name. If this is the case its 
string value will be substituted.

<P>
Preprocessor variables can have arguments and thereby become 
macro's. One should consult the description of the #define&nbsp;<A HREF="#predefine">3.18</A> 
instruction about the delayed substitution feature to avoid the value of 
the preprocessor variables in the macro would be substituted immediately 
during the definition. Hence proper use is
<PRE>
    #define EXCHANGE(x,y) "Multiply replace_(`~x',`~y',`~y',`~x');"
</PRE>

<P>
FORM has the following built in macro's:
<DL>
<DT><STRONG>TOLOWER_(string)</STRONG></DT>
<DD>in which the character string in the argument is 
converted to lower case. After this it will become input.
</DD>
<DT><STRONG>TOUPPER_(string)</STRONG></DT>
<DD>in which the character string in the argument is 
converted to upper case. After this it will become input.
</DD>
</DL>
It is anticipated that some more macro's will become available to allow for 
the editing of names of variables.

<P>

<H1><A ID="SECTION00420000000000000000"></A>
<A ID="calculator"></A>
<BR>
The preprocessor calculator
</H1>

<P>
Sometimes a preprocessor<A NAME="788"></A> variable 
should be interpreted as a number and some arithmetic<A NAME="789"></A> 
should be done with it. For this FORM is equipped with what is called the 
preprocessor calculator<A NAME="790"></A>. When the input reading device 
encounters a left curly<A NAME="791"></A> bracket<A NAME="792"></A> 
<code>{</code>, it will read till the matching right curly bracket <code>}</code> and 
then test whether the characters (after substitution of preprocessor 
variables) can be interpreted as a numerical expression. If it is not a 
valid numerical expression the whole string, including the curly brackets, 
will be passed on to the later stages of the program. If it is a numerical 
expression, it will be evaluated, and the whole string, including the curly 
brackets, will be replaced by a textual representation of the result. 
Example:
<PRE>
    Local F`i' = F{`i'-1}+F{`i'-2};
</PRE>
If the preprocessor variable i has the value 11, the calculator makes this 
into
<PRE>
    Local F11 = F10+F9;
</PRE>
Valid numerical expressions can contain the characters
<PRE>
   0 1 2 3 4 5 6 7 8 9 + - * / % ( ) { } &amp; | ^ !
</PRE>
The use of parentheses is as in regular arithmetic. The curly 
brackets fulfil the same role, as one can nest these brackets of course. 
Operators are:
<DL>
<DT><STRONG><SPAN CLASS="MATH"><IMG STYLE="height: 1.75ex; vertical-align: -0.30ex; " SRC="img7.svg"
 ALT="$+$"></SPAN></STRONG></DT>
<DD>Regular addition<A NAME="800"></A>.
</DD>
<DT><STRONG><SPAN CLASS="MATH"><IMG STYLE="height: 1.75ex; vertical-align: -0.30ex; " SRC="img6.svg"
 ALT="$-$"></SPAN></STRONG></DT>
<DD>Regular subtraction<A NAME="801"></A>.
</DD>
<DT><STRONG><SPAN CLASS="MATH"><IMG STYLE="height: 1.29ex; vertical-align: -0.11ex; " SRC="img8.svg"
 ALT="$\ast$"></SPAN></STRONG></DT>
<DD>Regular multiplication<A NAME="802"></A>.
</DD>
<DT><STRONG><SPAN CLASS="MATH"><IMG STYLE="height: 2.53ex; vertical-align: -0.69ex; " SRC="img9.svg"
 ALT="$/$"></SPAN></STRONG></DT>
<DD>Regular (integer) division<A NAME="803"></A>.
</DD>
<DT><STRONG><SPAN CLASS="MATH"><IMG STYLE="height: 2.08ex; vertical-align: -0.24ex; " SRC="img10.svg"
 ALT="$\%$"></SPAN></STRONG></DT>
<DD>The remainder<A NAME="804"></A> after (integer) division as in 
the language C<A NAME="805"></A>.
</DD>
<DT><STRONG><SPAN CLASS="MATH"><IMG STYLE="height: 1.82ex; vertical-align: -0.11ex; " SRC="img11.svg"
 ALT="$\&amp;$"></SPAN></STRONG></DT>
<DD>And<A NAME="806"></A> operator. This is a bitwise operator.
</DD>
<DT><STRONG><SPAN CLASS="MATH"><IMG STYLE="height: 2.53ex; vertical-align: -0.69ex; " SRC="img12.svg"
 ALT="$\vert$"></SPAN></STRONG></DT>
<DD>Or<A NAME="807"></A> operator. This is a bitwise or.
</DD>
<DT><STRONG><SPAN CLASS="MATH"><IMG STYLE="height: 1.50ex; vertical-align: -0.11ex; " SRC="img13.svg"
 ALT="$\wedge$"></SPAN></STRONG></DT>
<DD>Exponent<A NAME="808"></A> operator.
</DD>
<DT><STRONG><SPAN CLASS="MATH"><IMG STYLE="height: 1.82ex; vertical-align: -0.11ex; " SRC="img14.svg"
 ALT="$!$"></SPAN></STRONG></DT>
<DD>Factorial<A NAME="809"></A>. This is a postfix operator.
</DD>
<DT><STRONG><SPAN CLASS="MATH"><IMG STYLE="height: 2.08ex; vertical-align: -0.24ex; " SRC="img15.svg"
 ALT="$\wedge\%$"></SPAN></STRONG></DT>
<DD>A postfix <SPAN CLASS="MATH"><IMG STYLE="height: 2.59ex; vertical-align: -0.56ex; " SRC="img16.svg"
 ALT="${}^2\!\log$"></SPAN>. This means that it 
takes<A NAME="811"></A> the <SPAN CLASS="MATH"><IMG STYLE="height: 2.59ex; vertical-align: -0.56ex; " SRC="img16.svg"
 ALT="${}^2\!\log$"></SPAN> of the object to the left of it.
</DD>
<DT><STRONG><SPAN CLASS="MATH"><IMG STYLE="height: 2.53ex; vertical-align: -0.69ex; " SRC="img17.svg"
 ALT="$\wedge/$"></SPAN></STRONG></DT>
<DD>A postfix square<A NAME="813"></A> root. This means that 
it takes the square root of the object to the left of it.
</DD>
</DL>
Note that all arithmetic<A NAME="815"></A> is done over the integers and 
that there is a finite range. On 32<A NAME="816"></A> bit systems this range 
will be <SPAN CLASS="MATH"><IMG STYLE="height: 2.33ex; vertical-align: -0.30ex; " SRC="img18.svg"
 ALT="$2^{31}-1$"></SPAN> to <SPAN CLASS="MATH"><IMG STYLE="height: 2.33ex; vertical-align: -0.30ex; " SRC="img19.svg"
 ALT="$-2^{31}$"></SPAN>, while on 64<A NAME="819"></A> bit systems 
this will be  <SPAN CLASS="MATH"><IMG STYLE="height: 2.33ex; vertical-align: -0.30ex; " SRC="img20.svg"
 ALT="$2^{63}-1$"></SPAN> to <SPAN CLASS="MATH"><IMG STYLE="height: 2.33ex; vertical-align: -0.30ex; " SRC="img21.svg"
 ALT="$-2^{63}$"></SPAN>. In particular this means that 
<code>{13^/}</code> becomes <code>3</code>. The preprocessor calculator is only meant 
for some simple counting and organization of the program flow. Hence there 
is no large degree of sophistication. Very important is that the 
comma<A NAME="822"></A> character is not a legal character for the preprocessor 
calculator. This can be used to avoid some problems. Suppose one needs to 
make a substitution of the type:
<PRE>
    id f(x?!{0}) = 1/x;
</PRE>
in which the value zero should be excluded from the pattern matching (see 
dynamical<A NAME="825"></A> sets in chapter <A HREF="#pattern">5</A> on pattern 
matching). This would not work, because the preprocessor would make this 
into
<PRE>
    id f(x?!0) = 1/x;
</PRE>
which is illegal syntax. Hence the proper trick is to write
<PRE>
    id f(x?!{,0}) = 1/x;
</PRE>
With the comma the preprocessor will leave this untouched, and hence now 
the set is passed properly.

<P>
Good use of the preprocessor calculator can make life much easier for 
FORM. For example the following statements
<PRE>
    id  f(`i') = 1/(`i'+1);
    id  f(`i') = 1/{`i'+1};
</PRE>
are quite different in nature. In the first statement the compiler gets an 
expression with a composite denominator. The compiler never tries to 
simplify expressions by doing algebra on them. Sometimes this may not be 
optimal, but there are cases in which it would cause wrong results (in 
particular when noncommuting and commuting functions are mixed and 
wildcards are used). Hence the composite denominator has to be worked out 
during run time for each term separately. The second statement has the 
preprocessor work out the sum and hence the compiler gets a simple fraction 
and less time will be needed during running. Note that
<PRE>
    id  f(`i') = {1/(`i'+1)};
</PRE>
would most likely not produce the desired result, because the preprocessor 
calculator works only over the integers. Hence, unless i is equal to zero 
or -2, the result would be zero (excluding of course the fatal error when i 
is equal to -1).

<P>

<H1><A ID="SECTION00430000000000000000"></A>
<A ID="tripledot"></A>
<BR>
The triple dot operator
</H1>

<P>
The last<A NAME="837"></A> stage of the actions of the preprocessor involves the 
triple dot operator. It indicates a repeated pattern as in <code>a1+...+a4</code> 
which would expand into <code>a1+a2+a3+a4</code>. This operator is used in two 
different ways. First the most general way:
<PRE>
    &lt;pattern1&gt;operator1...operator2&lt;pattern2&gt;
</PRE>
in which the less<A NAME="840"></A> than and greater<A NAME="841"></A> 
than signs serve as boundaries for the patterns. The operators can be any 
pair of the following:
<DL>
<DT><STRONG>+ +</STRONG></DT>
<DD><A NAME="843"></A> Repetitions will be separated by plus signs.
</DD>
<DT><STRONG>&ndash; &ndash;</STRONG></DT>
<DD><A NAME="844"></A> Repetitions will be separated by minus signs.
</DD>
<DT><STRONG>+ &ndash;</STRONG></DT>
<DD><A NAME="845"></A> Repetitions will be separated by alternating signs. 
First will be plus.
</DD>
<DT><STRONG>&ndash; +</STRONG></DT>
<DD><A NAME="846"></A> Repetitions will be separated by alternating signs. 
First will be minus.
</DD>
<DT><STRONG><SPAN CLASS="MATH"><IMG STYLE="height: 1.29ex; vertical-align: -0.11ex; " SRC="img22.svg"
 ALT="$\ast\ \ast$"></SPAN></STRONG></DT>
<DD><A NAME="847"></A> Repetitions will be separated by <SPAN CLASS="MATH"><IMG STYLE="height: 1.29ex; vertical-align: -0.11ex; " SRC="img8.svg"
 ALT="$\ast$"></SPAN>.
</DD>
<DT><STRONG>/ /</STRONG></DT>
<DD><A NAME="848"></A> Repetitions will be separated by /.
</DD>
<DT><STRONG>, ,</STRONG></DT>
<DD><A NAME="849"></A> Repetitions will be separated by comma's.
</DD>
<DT><STRONG>: :</STRONG></DT>
<DD><A NAME="850"></A> Repetitions will be separated by <I>single</I> dots.
</DD>
</DL>
For such a pair of operators FORM will inspect the patterns<A NAME="853"></A> 
and see whether the differences between the two patterns are just numbers. 
If the differences are numbers and the absolute value of the difference of 
each matching pair is always the same (a difference of zero is allowed too; 
it leads to no action for the pair), then FORM will expand the pattern, 
running from the first to the last in increments of one. For each pair the 
counter can either run up or run down, depending on whether the number in 
the first pattern is greater or less than the number in the second pattern. 
Example:
<PRE>
    Local F = &lt;a1b6(c3)&gt;-...+&lt;a4b3(c6)&gt;;
</PRE>
leads to
<PRE>
    Local F = a1b6(c3)-a2b5(c4)+a3b4(c5)-a4b3(c6);
</PRE>
The second form is a bit simpler. It recognizes that there are special 
cases that can be written in a more intuitive way. If there is only a 
single number to be varied, and it is the end of the pattern, and the rest 
of the patterns consists only of alphanumeric characters of which the first 
is an alphabetic character, we do not need the less than/greater than 
combination. This is shown in
<PRE>
    Symbol a1,...,a12;
</PRE>
There is one extra exception. The variables used this way may have a 
question mark after them to indicate that they are wildcards:
<PRE>
    id  f(a1?,...,a4?) = g(a1,...,a4,a1+...+a4);
</PRE>
This construction did not exist in earlier versions of FORM (version 1 and 
version 2). There one needed the #do<A NAME="862"></A> instruction for many of 
the above constructions, creating code that was very hard to read. The 
<code>...</code> operator should improve the readability of the programs very 
much.

<P>

<H1><A ID="SECTION00440000000000000000"></A>
<A ID="preadd"></A>
<BR>
#add
</H1>

<P>
Syntax:

<P>
#add object: "string"

<P>
See chapter <A HREF="#dictionaries">13</A> on dictionaries.

<P>
Adds words to an open dictionary.

<P>

<H1><A ID="SECTION00450000000000000000"></A>
<A ID="preaddseparator"></A>
<BR>
#addseparator
</H1>

<P>
Syntax:

<P>
#addseparator character

<P>
See also #rmseparator (<A HREF="#prermseparator">3.51</A>),
            #call (<A HREF="#precall">3.10</A>), #do (<A HREF="#predo">3.19</A>)

<P>
Adds a character<A NAME="871"></A> to the list of permissible 
separator characters for arguments of #call or #do instructions. By 
default the two characters that are permitted are the comma and the 
character <code>|</code>. Blanks, tabs and double quotes are ignored. Note that 
the comma must be specified between double quotes as in
<PRE>
  #addseparator ","
</PRE>

<P>

<H1><A ID="SECTION00460000000000000000"></A>
<A ID="preappend"></A>
<BR>
#append
</H1>

<P>
Syntax:

<P>
#append <SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img23.svg"
 ALT="$&lt;$"></SPAN>filename<SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img24.svg"
 ALT="$&gt;$"></SPAN>

<P>
See also write (<A HREF="#prewrite">3.64</A>),
            close (<A HREF="#preclose">3.13</A>), create (<A HREF="#precreate">3.16</A>),
            remove (<A HREF="#preremove">3.47</A>)

<P>
Opens<A NAME="880"></A> the named file for writing. The file will 
be positioned at the end. The next #write<A NAME="881"></A> instruction will 
add to it.

<P>

<H1><A ID="SECTION00470000000000000000"></A>
<A ID="preappendpath"></A>
<BR>
#appendpath
</H1>

<P>
Syntax:

<P>
#appendpath pathname

<P>
See also prependpath&nbsp;(<A HREF="#preprependpath">3.41</A>)

<P>
Appends the given path relative to the current file to the end of
the FORM path<A NAME="885"></A>.

<P>

<H1><A ID="SECTION00480000000000000000"></A>
<A ID="prebreak"></A>
<BR>
#break
</H1>

<P>
Syntax:

<P>
#break

<P>
See also switch (<A HREF="#preswitch">3.57</A>),
        endswitch (<A HREF="#preendswitch">3.26</A>),
        case (<A HREF="#precase">3.11</A>),
        default (<A HREF="#predefault">3.17</A>)

<P>
If the<A NAME="892"></A> lines before were not part of the control 
flow (<I>i.e.</I> these lines are used for the later stages of the program), 
this instruction is ignored. If they are part of the control flow, the flow 
will continue after the matching #endswitch<A NAME="894"></A> 
instruction. The #break instruction must of course be inside the range of 
a #switch<A NAME="895"></A>/#endswitch construction.

<P>

<H1><A ID="SECTION00490000000000000000"></A>
<A ID="prebreakdo"></A>
<BR>
#breakdo
</H1>

<P>
Syntax:

<P>
#breakdo [<SPAN style="font-family:monospace">&lt;</SPAN>number<SPAN style="font-family:monospace">&gt;</SPAN>]

<P>
See also #do (<A HREF="#predo">3.19</A>) and #enddo (<A HREF="#preenddo">3.22</A>)

<P>
The #breakdo<A NAME="902"></A> instruction allows one to jump out 
of a #do loop. If a (nonzero integer) number is specified it indicates the 
number of loops the program should terminate. Control will continue after 
the #enddo instruction of the number of loops indicated by `number'. 
The default value is one. If the value is zero the statement has no effect.

<P>

<H1><A ID="SECTION004100000000000000000"></A>
<A ID="precall"></A>
<BR>
#call
</H1>

<P>
Syntax:

<P>
#call procname(var1,...,varn)

<P>
See also procedure (<A HREF="#preprocedure">3.43</A>), endprocedure
(<A HREF="#preendprocedure">3.25</A>)

<P>
This instruction<A NAME="907"></A> calls the 
procedure<A NAME="908"></A> with the name procname. The result is that FORM 
looks for this procedure, first in its procedure 
buffers<A NAME="909"></A> (for procedures that were defined in the 
regular text stream as explained under the #procedure<A NAME="910"></A> 
instruction), then it looks for a file by the name procname.prc in the 
current directory, and if it still has not found the procedure, it looks in 
the directories indicated by the path<A NAME="911"></A> variable in either the setup 
file or at the start of the program (see chapter <A HREF="#setup">17</A> on the setup 
file). Next it looks for the -p option in the command that started FORM 
(see the chapter on running FORM). If this -p option has not been used FORM 
will see whether there is an environment variable by the name 
FORMPATH<A NAME="913"></A>. The directories indicated there will be searched 
for the file procname.prc. If FORM cannot find the file, there will be an 
error message and execution will be stopped immediately.

<P>
Once the procedure has been located, FORM reads the whole file and then 
determines whether the number of parameters is identical in the 
#call<A NAME="914"></A> instruction and the #procedure<A NAME="915"></A> 
instruction. A difference is a fatal error.

<P>
The parameter field consists of strings, separated by commas. If a string 
contains a comma, this comma should be preceded by a 
backslash<A NAME="916"></A> character (<code>\</code>). If a string should contain 
a linefeed<A NAME="917"></A>, one should `escape' this linefeed by putting a 
backslash and continue on the next line.

<P>
Before version 3 of FORM the syntax was different. The parentheses 
were curly brackets and the separators the symbol <code>|</code>. This was made 
to facilitate the use of strings that might contain commas. In practise 
however, this turned out to be far from handy. In addition the new 
preprocessor calculator is a bit more active and hence an instruction of 
the type
<PRE>
    #call test{1}
</PRE>
will now be intercepted by the preprocessor calculator<A NAME="920"></A> 
and changed into
<PRE>
    #call test1
</PRE>
Because there are many advantages to the preprocessor calculator treating 
the parameters of the procedures before they are called (in the older 
versions it did not do this), the notation has been changed. FORM still 
understands the old notation, provided that there is no conflict with the 
preprocessor calculator. Hence
<PRE>
    #call test{1|a}
    #call test{1,a}
    #call test(1|a)
    #call test(1,a)
</PRE>
are all legal and give the same result, but only the last notation will 
work in future versions of FORM.

<P>
Nowadays also the use of the argument field wildcard (see chapter 
<A HREF="#pattern">5</A> on pattern matching) is allowed as in the 
regular functions:
<PRE>
    #define a "1"
    #define bc2 "x"
    #define bc3 "y"
    #define b "c`~a'"
    #procedure hop(c,?d);
    #redefine a "3"
    #message This is the call: `c',`?d'
    #endprocedure
    
    #redefine a "2"
    #message This is b: `b'
~~~This is b: c2
    
    #call hop(`b`!b&rdquo;`!b'`b'`!b'`b',`~a',`b',`a')
~~~This is the call: xc2c3c2c3,3,c3,2
    
    .end
</PRE>
We also see here that the rules about delayed substitution (see also the 
#define<A NAME="928"></A> instruction in section <A HREF="#predefine">3.18</A>) apply. The 
use of `!b' cancels the delayed substitution that is asked for in the 
definition of b.

<P>
The default extension for procedure files is .prc<A NAME="930"></A>, but it is 
possible to change this. There are two different ways: One is with the 
#procedureExtension<A NAME="931"></A> instruction in section 
<A HREF="#preprocedureextension">3.44</A>. The other is via the setup (see the chapter on 
the setup file, chapter <A HREF="#setup">17</A>).

<P>

<H1><A ID="SECTION004110000000000000000"></A>
<A ID="precase"></A>
<BR>
#case
</H1>

<P>
Syntax:

<P>
#case string

<P>
See also switch (<A HREF="#preswitch">3.57</A>),
        endswitch (<A HREF="#preendswitch">3.26</A>),
        break (<A HREF="#prebreak">3.8</A>),
        default (<A HREF="#predefault">3.17</A>)

<P>
The lines after the #case<A NAME="940"></A> instruction will be used 
if either this is the first #case<A NAME="941"></A> instruction of which the 
string matches the string in the #switch<A NAME="942"></A> instruction, or 
the control flow was already using the lines before this #case instruction 
and there was no #break<A NAME="943"></A> instruction (this is called 
fall-through). The control flow will include lines either until the next 
matching #break instruction, or until the matching 
#endswitch<A NAME="944"></A> instruction.

<P>

<H1><A ID="SECTION004120000000000000000"></A>
<A ID="preclearoptimize"></A>
<BR>
#clearoptimize
</H1>

<P>
Syntax:

<P>
#clearoptimize

<P>
See the chapter about optimization <A HREF="#optimization">10</A>

<P>

<H1><A ID="SECTION004130000000000000000"></A>
<A ID="preclose"></A>
<BR>
#close
</H1>

<P>
Syntax:

<P>
#close <SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img23.svg"
 ALT="$&lt;$"></SPAN>filename<SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img24.svg"
 ALT="$&gt;$"></SPAN>

<P>
See also write (<A HREF="#prewrite">3.64</A>), append (<A HREF="#preappend">3.6</A>),
            create (<A HREF="#precreate">3.16</A>), remove (<A HREF="#preremove">3.47</A>)

<P>
This instruction closes<A NAME="954"></A> the file<A NAME="955"></A> 
by the given name, if such a file had been opened by the previous 
#write<A NAME="956"></A> instruction. Normally FORM closes all such files at 
the end of execution. Hence the user would not have to worry about this. 
The use of a subsequent #write instruction with the same file name will 
remove the old contents and hence start basically a new file. There are 
times that this is useful.

<P>

<H1><A ID="SECTION004140000000000000000"></A>
<A ID="preclosedictionary"></A>
<BR>
#closedictionary
</H1>

<P>
Syntax:

<P>
#closedictionary

<P>
See chapter <A HREF="#dictionaries">13</A> on dictionaries.

<P>
Either closes an open dictionary (<A HREF="#preopendictionary">3.37</A>) or stops 
using the dictionary (<A HREF="#preusedictionary">3.63</A>) that is currently used for output 
translation.

<P>

<H1><A ID="SECTION004150000000000000000"></A>
<A ID="precommentchar"></A>
<BR>
#commentchar
</H1>

<P>
Syntax:

<P>
#commentchar character

<P>
The specified<A NAME="964"></A> character should be a single 
non-whitespace character. There may be white space (blanks and/or tabs) 
before or after it. The character will take over the role of the comment 
character. <I>i.e.</I> any line that starts with this character in column 1 
will be considered commentary<A NAME="966"></A>. This feature was provided 
because output of some other algebra programs could put the multiplication 
sign in column 1 in longer expressions.

<P>
The default commentary character is <SPAN CLASS="MATH"><IMG STYLE="height: 1.29ex; vertical-align: -0.11ex; " SRC="img8.svg"
 ALT="$\ast$"></SPAN>.

<P>

<H1><A ID="SECTION004160000000000000000"></A>
<A ID="precreate"></A>
<BR>
#create
</H1>

<P>
Syntax:

<P>
#append <SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img23.svg"
 ALT="$&lt;$"></SPAN>filename<SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img24.svg"
 ALT="$&gt;$"></SPAN>

<P>
See also write (<A HREF="#prewrite">3.64</A>),
            close (<A HREF="#preclose">3.13</A>), append (<A HREF="#preappend">3.6</A>),
            remove (<A HREF="#preremove">3.47</A>)

<P>
Opens the named<A NAME="973"></A> file for writing. If the file 
existed already, its previous contents will be lost. The next 
#write<A NAME="974"></A> instruction will add to it. In principle this 
instruction is not needed, because the #write instruction would create the 
file if it had not been opened yet at the moment of writing.

<P>

<H1><A ID="SECTION004170000000000000000"></A>
<A ID="predefault"></A>
<BR>
#default
</H1>

<P>
Syntax:

<P>
#default

<P>
See also switch (<A HREF="#preswitch">3.57</A>),
        endswitch (<A HREF="#preendswitch">3.26</A>),
        case (<A HREF="#precase">3.11</A>),
        break (<A HREF="#prebreak">3.8</A>)

<P>
Control<A NAME="981"></A> flow continues after this instruction if 
there is no #case<A NAME="982"></A> instruction of which the string matches 
the string in the #switch<A NAME="983"></A> instruction. Control flow also 
continues after this instruction, if the lines before were included and 
there was no #break<A NAME="984"></A> instruction to stop the control flow 
(fall-through). Control flow will stop either when a matching #break 
instruction is reached, or when a matching #endswitch<A NAME="985"></A> 
is encountered. In the last case of course control flow will continue after 
the #endswitch instruction.

<P>

<H1><A ID="SECTION004180000000000000000"></A>
<A ID="predefine"></A>
<BR>
#define
</H1>

<P>
Syntax:

<P>
#define name "string"

<P>
See also redefine (<A HREF="#preredefine">3.46</A>), undefine 
(<A HREF="#preundefine">3.62</A>)

<P>
in which name<A NAME="990"></A> refers to the name of the 
preprocessor<A NAME="991"></A> 
variable<A NAME="992"></A> to be defined and the contents of the 
string will form the value of the variable. The double quotes are mandatory 
delimiters of the string.

<P>
The use of the #define<A NAME="993"></A> instruction creates a new instance 
of the preprocessor variable with the given name. This means that the old 
instance<A NAME="994"></A> remains. If for some reason the later instance 
becomes undefined (see for instance #undefine), the older instance will be 
the one that is active. If the old definition is to be overwritten, one 
should use the #redefine<A NAME="995"></A> instruction.

<P>
As of version 3.2 preprocessor variables can also have arguments as in the 
C<A NAME="996"></A> language. Hence

<P>
#define var(a,b) "(`<code>~</code>a'+`<code>~</code>b'+`c')"

<P>
is allowed. The parameters should be referred to inside a pair of `' as 
with all preprocessor variables. A special feature is the socalled 
delayed<A NAME="997"></A> 
substitution<A NAME="998"></A>. With macro's like the above the 
question is always <I CLASS="slanted">when</I> a preprocessor variable will be substituted. 
Take for instance
<PRE>
    #define c "3"
    #define var1(a,b) "(`~a'+`~b'+`c')"
    #define var2(a,b) "(`~a'+`~b'+`~c')"
    #redefine c "4"
    Local F1 = `var1(1,2)';
    Local F2 = `var2(1,2)';
    Print;
    .end

   F1 =
      6;

   F2 =
      7;
</PRE>
The parameter c will be substituted immediately when var1 is defined. In 
var2 it will be only substituted when var2 is used. It should be clear that 
a and b should also be used in the delayed fashion because they do not 
exist yet at the moment of the definition of var1 and var2. Notice also 
that the whole macro<A NAME="1002"></A>, with its arguments should be placed 
between the backquote and the quote. Another example can be found with the 
#call<A NAME="1003"></A> instruction. See section <A HREF="#precall">3.10</A>

<P>

<H1><A ID="SECTION004190000000000000000"></A>
<A ID="predo"></A>
<BR>
#do
</H1>

<P>
Syntax:

<P>
#do lvar = i1,i2

<P>
#do lvar = i1,i2,i3

<P>
#do lvar = <SPAN CLASS="MATH"><IMG STYLE="height: 2.53ex; vertical-align: -0.69ex; " SRC="img25.svg"
 ALT="$\{$"></SPAN>string1<SPAN CLASS="MATH"><IMG STYLE="height: 2.53ex; vertical-align: -0.69ex; " SRC="img12.svg"
 ALT="$\vert$"></SPAN>...<SPAN CLASS="MATH"><IMG STYLE="height: 2.53ex; vertical-align: -0.69ex; " SRC="img12.svg"
 ALT="$\vert$"></SPAN>stringn<SPAN CLASS="MATH"><IMG STYLE="height: 2.53ex; vertical-align: -0.69ex; " SRC="img26.svg"
 ALT="$\}$"></SPAN>

<P>
#do lvar = <SPAN CLASS="MATH"><IMG STYLE="height: 2.53ex; vertical-align: -0.69ex; " SRC="img25.svg"
 ALT="$\{$"></SPAN>string1,...,stringn<SPAN CLASS="MATH"><IMG STYLE="height: 2.53ex; vertical-align: -0.69ex; " SRC="img26.svg"
 ALT="$\}$"></SPAN>

<P>
#do lvar = nameofexpression

<P>
See also enddo (<A HREF="#preenddo">3.22</A>)

<P>
The #do<A NAME="1008"></A> instruction<A NAME="1009"></A> needs a matching 
#enddo<A NAME="1010"></A> instruction. All code in-between these two 
instructions will be read as many times as indicated in the parameter field 
of the #do instruction. The parameter lvar is a preprocessor variable of 
which the value is determined by the other parameters. Inside the loop it 
should be referred to by enclosing its name between a backquote/quote pair 
as is usual for preprocessor variables. The various possible parameter 
fields have the following meaning:
<DL>
<DT><STRONG>#do lvar = i1,i2</STRONG></DT>
<DD>The parameters i1 and i2 should be integers or 
names of dollar expressions that evaluate into integers. The 
first time in the loop lvar will get the value of i1 (as a string) and each 
next time its value will be one greater (translated into a string again). 
The last time in the loop the value of lvar will be the greatest integer 
that is less or equal to i2. If i2 is less than i1, the loop is skipped 
completely. If i2 is the name of a dollar variable, each time the control 
reaches the end of the loop the dollar variable is evaluated and the 
current value is used.
</DD>
<DT><STRONG>#do lvar = i1,i2,i3</STRONG></DT>
<DD>The parameters i1,i2 and i3 should be integers 
or names of dollar expressions that evaluate into integers. 
The first time in the loop lvar will get the value of i1 (as a string) and 
each next time its value will be incremented by adding i3 (translated into 
a string again). If i3 is positive, the last value of lvar will be the one 
for which lvar+i3 is greater than i2. If i2 is less than i1, the loop is 
skipped completely. If i3 is negative the last value of lvar will be the 
one for which lvar+i3 is less than i2. If i3 is zero there will be an 
error. If i2 or i3 are the names of a dollar variable, each time the control 
reaches the end of the loop the dollar variable(s) is/are evaluated and the 
current value is used.
</DD>
<DT><STRONG>#do lvar = <SPAN CLASS="MATH"><IMG STYLE="height: 2.53ex; vertical-align: -0.69ex; " SRC="img25.svg"
 ALT="$\{$"></SPAN>string1<SPAN CLASS="MATH"><IMG STYLE="height: 2.53ex; vertical-align: -0.69ex; " SRC="img12.svg"
 ALT="$\vert$"></SPAN>...<SPAN CLASS="MATH"><IMG STYLE="height: 2.53ex; vertical-align: -0.69ex; " SRC="img12.svg"
 ALT="$\vert$"></SPAN>stringn<SPAN CLASS="MATH"><IMG STYLE="height: 2.53ex; vertical-align: -0.69ex; " SRC="img26.svg"
 ALT="$\}$"></SPAN></STRONG></DT>
<DD>The first time in the 
loop the value of lvar is the string indicated by string1, the next time 
will be string2 etc till the last time when it will be stringn. This is 
called a listed<A NAME="1012"></A> loop<A NAME="1013"></A>. The notation 
with the <SPAN CLASS="MATH"><IMG STYLE="height: 2.53ex; vertical-align: -0.69ex; " SRC="img12.svg"
 ALT="$\vert$"></SPAN> is an old notation which is still accepted. The new notation 
uses a comma instead.
</DD>
<DT><STRONG>#do lvar = <SPAN CLASS="MATH"><IMG STYLE="height: 2.53ex; vertical-align: -0.69ex; " SRC="img25.svg"
 ALT="$\{$"></SPAN>string1,...,stringn<SPAN CLASS="MATH"><IMG STYLE="height: 2.53ex; vertical-align: -0.69ex; " SRC="img26.svg"
 ALT="$\}$"></SPAN></STRONG></DT>
<DD>The first time in the loop 
the value of lvar is the string indicated by string1, the next time will be 
string2 etc till the last time when it will be stringn. This is called a 
listed<A NAME="1014"></A> loop<A NAME="1015"></A>.
</DD>
<DT><STRONG>#do lvar = expression</STRONG></DT>
<DD>The loop variable will take one by one for 
its value all the terms of the given expression. This is protected against 
changing the expression inside the loop by making a copy of the expression 
inside the memory. Hence one should be careful with very big expressions. 
An expression that is zero gives a loop over zero terms, hence the loop is 
never executed.
</DD>
</DL>
The first two types of #do instructions are called 
numerical<A NAME="1017"></A> loops<A NAME="1018"></A>. In the 
parameters of numerical loops the preprocessor calculator<A NAME="1019"></A> 
is invoked automatically. One should make sure not to use a leading <SPAN CLASS="MATH"><IMG STYLE="height: 2.53ex; vertical-align: -0.69ex; " SRC="img25.svg"
 ALT="$\{$"></SPAN> 
for the first numerical parameter in such a loop. This would be interpreted 
as belonging to a listed loop.

<P>
After a loop has been finished, the corresponding preprocessor variable 
will be undefined. This means that if there is a previous preprocessor 
variable by the same name, the value of the #do instruction will be used 
inside the loop, and afterwards the old value will be active again.

<P>
It is allowed to overwrite the value of a preprocessor #do instruction 
variable. This can be very useful to create the equivalent of a repeat loop 
that contains .sort instructions as in
<PRE>
    #do i = 1,1
        id,once,x = y+2;
        if ( count(x,1) &gt; 0 ) redefine i "0";
        .sort
    #enddo
</PRE>
A few remarks are necessary here. The redefine<A NAME="1022"></A> statement 
(see section <A HREF="#substaredefine">7.122</A>) should be before the last 
.sort<A NAME="1024"></A> inside the loop, because the #do instruction is part of 
the preprocessor. Hence the value of i is considered before the module is 
executed. This means that if the redefine would be after the .sort, two 
things would go wrong: First the loop would be terminated before the 
redefine would ever make a chance of being executed. Second the statement 
would be compiled in the expectation that there is a variable i, but then 
the loop would be terminated. Afterwards, when the statement is being 
executed it would refer to a variable that does not exist any longer. 

<P>
If one wants to make a loop over the externals of the brackets of an 
expression only, one needs to do some work. Assume we have the expression F 
and we want to loop over the brackets in x and y:
<PRE>
    L   FF = F;
    Bracket x,y;
    .sort
    CF acc,acc2;
    Skip F;
    Collect acc,acc2;
    id  acc(x?) = 1;
    id  acc2(x?)= 1;
    B   x,y;
    .sort
    Skip F;
    Collect acc;
    id  acc(x?) = 1;
    .sort
    #do i = FF
    L   G = F[`i'];
        .
        .
    #enddo
</PRE>
Notice that we have to do the collect<A NAME="1027"></A> trick twice because 
the first time the bracket could be too long for one term. The second time 
that restriction doesn't exist because besides the x and the y there are 
only integer coefficients.

<P>

<H1><A ID="SECTION004200000000000000000"></A>
<A ID="preelse"></A>
<BR>
#else
</H1>

<P>
Syntax:

<P>
#else

<P>
See also if (<A HREF="#preif">3.31</A>),
            endif (<A HREF="#preendif">3.23</A>),
            elseif (<A HREF="#preelseif">3.21</A>),
            ifdef (<A HREF="#preifdef">3.32</A>),
            ifndef (<A HREF="#preifndef">3.33</A>)

<P>
This instruction<A NAME="1035"></A> is used inside a 
#if<A NAME="1036"></A>/#endif<A NAME="1037"></A> construction. The code that follows 
it until the #endif instruction will be read if the condition of the #if 
instruction (and of none of the corresponding #elseif<A NAME="1038"></A> 
instructions) is not true. If any of these conditions is true, this code is 
skipped. The reading is stopped after the matching #endif is encountered 
and continued after this matching #endif instruction.

<P>

<H1><A ID="SECTION004210000000000000000"></A>
<A ID="preelseif"></A>
<BR>
#elseif
</H1>

<P>
Syntax:

<P>
#elseif ( condition )

<P>
See also if (<A HREF="#preif">3.31</A>),
            endif (<A HREF="#preendif">3.23</A>),
            else (<A HREF="#preelse">3.20</A>)

<P>
The syntax<A NAME="1044"></A> of the condition is identical to the 
syntax for the condition in the #if<A NAME="1045"></A> instruction. The #elseif 
instruction can occur between an #if and an #endif<A NAME="1046"></A> 
instruction, before a possible matching #else<A NAME="1047"></A> instruction. 
The code after this condition till the next #elseif instruction, or till a 
#else instruction or till a #endif instruction, whatever comes first, 
will be read if the condition in the #elseif instruction is true and none 
of the conditions in matching previous #if or #elseif instructions were 
true. The reading is stopped after the matching #elseif/#else/#endif is 
encountered and continued after the matching #endif instruction.

<P>
Example
<PRE>
    #if ( `i' == 2 )
        some code
    #elseif ( `i' == 3 )
        more code
    #elseif ( `j' &gt;= "x2y" )
        more code
    #else
        more code
    #endif
</PRE>

<P>

<H1><A ID="SECTION004220000000000000000"></A>
<A ID="preenddo"></A>
<BR>
#enddo
</H1>

<P>
Syntax:

<P>
#enddo

<P>
See also do (<A HREF="#predo">3.19</A>)

<P>
Used to<A NAME="1053"></A> terminate<A NAME="1054"></A> a preprocessor 
do<A NAME="1055"></A> loop. See the #do<A NAME="1056"></A> instruction.

<P>

<H1><A ID="SECTION004230000000000000000"></A>
<A ID="preendif"></A>
<BR>
#endif
</H1>

<P>
Syntax:

<P>
#endif

<P>
See also if (<A HREF="#preif">3.31</A>),
            else (<A HREF="#preelse">3.20</A>),
            elseif (<A HREF="#preelseif">3.21</A>),
            ifdef (<A HREF="#preifdef">3.32</A>),
            ifndef (<A HREF="#preifndef">3.33</A>)

<P>
Used to terminate<A NAME="1064"></A> a #if<A NAME="1065"></A>, 
#ifdef<A NAME="1066"></A> or #ifndef<A NAME="1067"></A> construction. 
Reading will continue after it.

<P>

<H1><A ID="SECTION004240000000000000000"></A>
<A ID="preendinside"></A>
<BR>
#endinside
</H1>

<P>
Syntax:

<P>
#endinside

<P>
See also #inside (<A HREF="#preinside">3.35</A>)

<P>
Used to<A NAME="1071"></A> terminate a #inside construction in 
the preprocessor. For more details, see the #inside<A NAME="1072"></A> 
instruction.

<P>

<H1><A ID="SECTION004250000000000000000"></A>
<A ID="preendprocedure"></A>
<BR>
#endprocedure
</H1>

<P>
Syntax:

<P>
#endprocedure

<P>
See also procedure (<A HREF="#preprocedure">3.43</A>), call
(<A HREF="#precall">3.10</A>)

<P>
Each procedure<A NAME="1077"></A> must be terminated by an 
#endprocedure<A NAME="1078"></A> instruction. If the procedure resides 
in its own file, the #endprocedure will cause the closing of the file. 
Hence any text that is in the file after the #endprocedure instruction 
will be ignored.

<P>
When control reaches the #endprocedure instruction, all (local) 
preprocessor variables<A NAME="1079"></A> that were defined 
inside the procedure and all parameters of the call of the procedure will 
become undefined.

<P>

<H1><A ID="SECTION004260000000000000000"></A>
<A ID="preendswitch"></A>
<BR>
#endswitch
</H1>

<P>
Syntax:

<P>
#endswitch

<P>
See also switch (<A HREF="#preswitch">3.57</A>),
        case (<A HREF="#precase">3.11</A>),
        break (<A HREF="#prebreak">3.8</A>),
        default (<A HREF="#predefault">3.17</A>)

<P>
This instruction marks the end<A NAME="1086"></A> of a 
#switch<A NAME="1087"></A> construction. After none or one of the cases of 
the #switch construction has been included in the control flow, reading 
will continue after the matching #endswitch instruction. Each #switch 
needs a #endswitch, unless a .end instruction is encountered first.

<P>

<H1><A ID="SECTION004270000000000000000"></A>
<A ID="preexchange"></A>
<BR>
#exchange
</H1>

<P>
Syntax:

<P>
#exchange expr1,expr2

<P>
#exchange $var1,$var2

<P>
Exchanges<A NAME="1090"></A> the names of two 
expressions<A NAME="1091"></A>. This means that the contents of the 
expressions remain where they are. Hence the order in which the expressions 
are processed remains the same, but the name under which one has to refer 
to them has been changed.

<P>
In the variety with the dollar variables<A NAME="1092"></A> the contents of 
the variables are exchanged. This is not much work, because dollar 
variables reside in memory and hence only two pointers to the contents have 
to be exchanged (and some extra information about the contents).

<P>
This instruction can be very useful when sorting expressions or dollar 
variables by their contents.

<P>

<H1><A ID="SECTION004280000000000000000"></A>
<A ID="preexternal"></A>
<BR>
#external
</H1>

<P>
Syntax:

<P>
#external ["prevar"] systemcommand

<P>
Starts the command<A NAME="1095"></A> in the background, 
connecting to its standard<A NAME="1096"></A><A NAME="1097"></A> 
input<A NAME="1098"></A> and output<A NAME="1099"></A>. By default, 
the #external command has no controlling terminal, the standard error stream 
is redirected to <code>/dev/null</code> and the command is run in a subshell in a 
new session and in a new process group (see the preprocessor instruction 
<code>#setexternalattr</code>).

<P>
The optional parameter &ldquo;prevar&rdquo; is the name of a preprocessor variable 
placed between double quotes. If it is present, the &ldquo;descriptor&rdquo; (small 
positive integer number) of the external command is stored into this 
variable and can be used for references to this external command (if there 
is more than one external command running simultaneously).

<P>
The external command that is started last becomes the &ldquo;current&rdquo; (active) 
external command.  All further instructions 
#fromexternal<A NAME="1100"></A> and #toexternal<A NAME="1101"></A> 
deal with the current external command.

<P>

<H1><A ID="SECTION004290000000000000000"></A>
<A ID="prefactdollar"></A>
<BR>
#factdollar
</H1>

<P>
Syntax:

<P>
#factdollar $-variable

<P>
See also the chapters on polynomials <A HREF="#polynomials">11</A> and 
$-variables <A HREF="#dollars">6</A>

<P>
The #factdollar<A NAME="1106"></A> instruction causes the 
factorization of the indicated $-variable. After this instruction and 
until the $-variable is redefined there will be two versions of the 
variable: one is the original unfactorized version and the other is a list 
of factors. If the name of the variable is $a the factors can be accessed 
as <!-- MATH
 $\$a[1],\cdots,\$a[n]$
 -->
<SPAN CLASS="MATH"><IMG STYLE="height: 2.53ex; vertical-align: -0.69ex; " SRC="img27.svg"
 ALT="$\$a[1],\cdots,\$a[n]$"></SPAN>. The total number of factors is given by 
<SPAN CLASS="MATH"><IMG STYLE="height: 2.53ex; vertical-align: -0.69ex; " SRC="img28.svg"
 ALT="$\$a[0]$"></SPAN>. These factors can also be treated as preprocessor variables by 
putting them between quotes as in `<SPAN CLASS="MATH"><IMG STYLE="height: 2.53ex; vertical-align: -0.69ex; " SRC="img29.svg"
 ALT="$\$a[2]$"></SPAN>'.

<P>

<H1><A ID="SECTION004300000000000000000"></A>
<A ID="prefromexternal"></A>
<BR>
#fromexternal
</H1>

<P>
Syntax:

<P>
#fromexternal[<SPAN CLASS="MATH"><IMG STYLE="height: 1.75ex; vertical-align: -0.30ex; " SRC="img30.svg"
 ALT="$+-$"></SPAN>] ["[$]varname" [maxlength]]

<P>
Appends<A NAME="1109"></A> the output of the current external 
command to the FORM program. The semantics differ depending on the optional 
arguments. After the external command sends the prompt<A NAME="1110"></A>, FORM 
will continue with a next line after the line containing the #fromexternal 
instruction. The prompt string is not appended. The optional <SPAN CLASS="MATH"><IMG STYLE="height: 1.75ex; vertical-align: -0.30ex; " SRC="img7.svg"
 ALT="$+$"></SPAN> or <SPAN CLASS="MATH"><IMG STYLE="height: 1.75ex; vertical-align: -0.30ex; " SRC="img6.svg"
 ALT="$-$"></SPAN> sign 
after the name has influence on the listing of the content. The varieties 
are:

<P>
#fromexternal[<SPAN CLASS="MATH"><IMG STYLE="height: 1.75ex; vertical-align: -0.30ex; " SRC="img30.svg"
 ALT="$+-$"></SPAN>]

<P>
The semantics is similar to the #include<A NAME="1111"></A> 
instruction but folders are not supported. 

<P>
#fromexternal[<SPAN CLASS="MATH"><IMG STYLE="height: 1.75ex; vertical-align: -0.30ex; " SRC="img30.svg"
 ALT="$+-$"></SPAN>] "[$]varname"

<P>
is used to read the text from the running external command into 
the preprocessor variable varname, or into the dollar variable $varname if 
the name of the variable starts with the dollar sign &ldquo;$&rdquo;.

<P>
#fromexternal[<SPAN CLASS="MATH"><IMG STYLE="height: 1.75ex; vertical-align: -0.30ex; " SRC="img30.svg"
 ALT="$+-$"></SPAN>] "[$]varname" maxlength

<P>
is used to read the text from the running external command into 
the preprocessor (or dollar) variable varname. Only the first maxlength 
characters are stored.

<P>

<H1><A ID="SECTION004310000000000000000"></A>
<A ID="preif"></A>
<BR>
#if
</H1>

<P>
Syntax:

<P>
#if ( condition )

<P>
See also endif (<A HREF="#preendif">3.23</A>),
            else (<A HREF="#preelse">3.20</A>),
            elseif (<A HREF="#preelseif">3.21</A>),
            ifdef (<A HREF="#preifdef">3.32</A>),
            ifndef (<A HREF="#preifndef">3.33</A>)

<P>
The #if<A NAME="1119"></A> instruction should be accompanied by a 
matching #endif<A NAME="1120"></A> instruction. In addition there can be 
between the #if and the #endif some #elseif<A NAME="1121"></A> instructions 
and/or a single #else<A NAME="1122"></A> instruction. The condition is a 
logical variable that is true if its value is not equal to zero, and false 
if its value is zero. Hence it is allowed to use
<PRE>
    #if `i'
        statements
    #endif
</PRE>
provided that i has a value which can be interpreted as a number. If there 
is just a string that cannot be seen as a logical<A NAME="1125"></A> condition 
or a number it will be interpreted as false. The regular syntax of the 
simple condition is
<PRE>
    #if `i' == st2x
        statements
    #endif
</PRE>
or
<PRE>
    #if ( `i' == st2x )
        statements
    #endif
</PRE>
in which the compare is a numerical compare if both strings can be seen as 
numbers, while it will be a string compare if at least one of the two 
cannot be seen as a numerical object. One can also use more complicated 
conditions as in
<PRE>
    #if ( ( `i' &gt; 5 ) &amp;&amp; ( `j' &gt; `i' ) )
</PRE>
These are referred to as composite conditions. The possible operators are
<DL>
<DT><STRONG><SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img24.svg"
 ALT="$&gt;$"></SPAN></STRONG></DT>
<DD>Greater than, either in numerical or in lexicographical sense.
</DD>
<DT><STRONG><SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img23.svg"
 ALT="$&lt;$"></SPAN></STRONG></DT>
<DD>Less than, either in numerical or in lexicographical sense.
</DD>
<DT><STRONG><SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img31.svg"
 ALT="$&gt;=$"></SPAN></STRONG></DT>
<DD>Greater than or equal to, either in numerical or in 
lexicographical sense.
</DD>
<DT><STRONG><SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img32.svg"
 ALT="$&lt;=$"></SPAN></STRONG></DT>
<DD>Less than or equal to, either in numerical or in 
lexicographical sense.
</DD>
<DT><STRONG><SPAN CLASS="MATH"><IMG STYLE="height: 1.06ex; vertical-align: -0.11ex; " SRC="img33.svg"
 ALT="$==$"></SPAN> or <SPAN CLASS="MATH"><IMG STYLE="height: 1.06ex; vertical-align: -0.11ex; " SRC="img34.svg"
 ALT="$=$"></SPAN></STRONG></DT>
<DD>Equal to.
</DD>
<DT><STRONG><SPAN CLASS="MATH"><IMG STYLE="height: 1.82ex; vertical-align: -0.11ex; " SRC="img35.svg"
 ALT="$!=$"></SPAN></STRONG></DT>
<DD>Not equal to.
</DD>
<DT><STRONG><SPAN CLASS="MATH"><IMG STYLE="height: 1.82ex; vertical-align: -0.11ex; " SRC="img36.svg"
 ALT="$\&amp;\&amp;$"></SPAN></STRONG></DT>
<DD>Logical and operator to combine conditions.
</DD>
<DT><STRONG><SPAN CLASS="MATH"><IMG STYLE="height: 2.53ex; vertical-align: -0.69ex; " SRC="img37.svg"
 ALT="$\vert\vert$"></SPAN></STRONG></DT>
<DD>Logical or operator to combine conditions.
</DD>
</DL>

<P>
If the condition evaluates to true, the lines after the #if instruction 
will be read until the first matching #elseif instruction, or a #else 
instruction or a #endif instruction, whatever comes first. After such an 
instruction is encountered input reading stops and continues after the 
matching #endif instruction.

<P>
Like with the regular if-statement (see <A HREF="#substaif">7.71</A>), there are some special 
functions that allow the asking of questions about objects. These are

<P>
<TABLE   STYLE="width:136;">
<TR><TD>exists()
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>The argument of exists<A NAME="1523"></A> is the name of an 
expression or a $-variable. This function then returns one if this object 
exists, cq. has been defined. Otherwise it returns zero. </TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:136;">
<TR><TD>isdefined()
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>The argument of isdefined<A NAME="1536"></A> is the name of a 
preprocessor variable. This function then returns one if this object 
has been defined. Otherwise it returns zero. Technically <SPAN  CLASS="texttt">#ifdef `VAR'</SPAN> 
and 
<SPAN  CLASS="texttt">#if ( isdefined(VAR) )</SPAN> are the same. The isdefined function 
allows for greater flexibility in composite conditions.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:136;">
<TR><TD>isfactorized()
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>The argument of isfactorized<A NAME="1551"></A> is the 
name of an expression or a $-variable. This function then returns one if 
the object has been factorized. Otherwise it returns zero. </TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:136;">
<TR><TD>isnumerical()
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>The argument of isnumerical<A NAME="1564"></A> is the 
name of an expression or a $-variable. This function then returns one if 
the object contains a single term that is purely numerical in nature. 
Otherwise it returns zero. </TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:136;">
<TR><TD>maxpowerof()
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>The argument of maxpowerof<A NAME="1577"></A> is the name 
of a symbol. This function then evaluates into the maximum power of that 
symbol as it has been declared. If no maximum power has been set in the 
declaration of the symbol, the general maximum power for symbols is 
returned (see <A HREF="#substasymbols">7.140</A>).</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:136;">
<TR><TD>minpowerof()
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>The argument of minpowerof<A NAME="1591"></A> is the name 
of a symbol. This function then evaluates into the minimum power of that 
symbol as it has been declared. If no minimum power has been set in the 
declaration of the symbol, the general minimum power for symbols is 
returned (see <A HREF="#substasymbols">7.140</A>).</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:136;">
<TR><TD>sizeof()
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>The argument of termsin<A NAME="1605"></A> is the name of an 
expression or a $-variable. This function then evaluates into the number 
of FORMwords in that expression or variable.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:136;">
<TR><TD>termsin()
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>The argument of termsin<A NAME="1619"></A> is the name of an 
expression or a $-variable. This function then evaluates into the number 
of terms in that expression.</TD></TR>
</TABLE>
    <BR>

<P>

<H1><A ID="SECTION004320000000000000000"></A>
<A ID="preifdef"></A>
<BR>
#ifdef
</H1>

<P>
Syntax:

<P>
#ifdef `prevar'

<P>
See also if (<A HREF="#preif">3.31</A>),
            endif (<A HREF="#preendif">3.23</A>),
            else (<A HREF="#preelse">3.20</A>),
            ifndef (<A HREF="#preifndef">3.33</A>)

<P>
If the named<A NAME="1177"></A> preprocessor variable has been 
defined the condition is true, else it is false. For the rest the 
instruction behaves like the #if<A NAME="1178"></A> instruction.

<P>
An alternative is to use the isdefined object inside the #if instruction.

<P>

<H1><A ID="SECTION004330000000000000000"></A>
<A ID="preifndef"></A>
<BR>
#ifndef
</H1>

<P>
Syntax:

<P>
#ifndef `prevar'

<P>
See also if (<A HREF="#preif">3.31</A>),
            endif (<A HREF="#preendif">3.23</A>),
            else (<A HREF="#preelse">3.20</A>),
            ifdef (<A HREF="#preifdef">3.32</A>)

<P>
If the named<A NAME="1185"></A> preprocessor variable has been 
defined the condition is false, else it is true. For the rest the 
instruction behaves like the #if<A NAME="1186"></A> instruction.

<P>

<H1><A ID="SECTION004340000000000000000"></A>
<A ID="preinclude"></A>
<BR>
#include
</H1>

<P>
Syntax:

<P>
#include[<SPAN CLASS="MATH"><IMG STYLE="height: 1.75ex; vertical-align: -0.30ex; " SRC="img38.svg"
 ALT="$-+$"></SPAN>] filename

<P>
#include[<SPAN CLASS="MATH"><IMG STYLE="height: 1.75ex; vertical-align: -0.30ex; " SRC="img38.svg"
 ALT="$-+$"></SPAN>] filename # foldname

<P>
The named<A NAME="1189"></A> file is searched for and opened. 
Reading<A NAME="1190"></A> continues from this file until its end. Then the 
file will be closed and reading continues after the #include instruction. 
If a foldname<A NAME="1191"></A> is specified, FORM will only read the 
contents of the first fold<A NAME="1192"></A> it encounters in the given file that 
has the specified name.

<P>
The file is searched for in the current directory, then in the path 
specified in the path<A NAME="1193"></A> variable in the setup file or at the 
beginning of the program (see chapter <A HREF="#setup">17</A> on the setup file). Next 
it will look in the path specified in the -p option when FORM is started 
(see the chapter on running FORM). If this option has not been used, FORM 
will look for the environment variable FORMPATH<A NAME="1195"></A>. If this 
variable exists it will be interpreted as a path and FORM will search the 
indicated directories for the given file. If none is found there will be an 
error message and execution will be halted.

<P>
The optional <SPAN CLASS="MATH"><IMG STYLE="height: 1.75ex; vertical-align: -0.30ex; " SRC="img7.svg"
 ALT="$+$"></SPAN> or <SPAN CLASS="MATH"><IMG STYLE="height: 1.75ex; vertical-align: -0.30ex; " SRC="img6.svg"
 ALT="$-$"></SPAN> sign after the name has influence on the listing of the 
contents of the file. A <SPAN CLASS="MATH"><IMG STYLE="height: 1.75ex; vertical-align: -0.30ex; " SRC="img6.svg"
 ALT="$-$"></SPAN> sign will have the effect of a #<SPAN CLASS="MATH"><IMG STYLE="height: 1.75ex; vertical-align: -0.30ex; " SRC="img6.svg"
 ALT="$-$"></SPAN> instruction 
during the reading of the file. A plus sign will have the effect of a #<SPAN CLASS="MATH"><IMG STYLE="height: 1.75ex; vertical-align: -0.30ex; " SRC="img7.svg"
 ALT="$+$"></SPAN> 
instruction during the reading of the file.

<P>
A fold is defined by a starting line of the format:
<PRE>
    *--#[ name :
</PRE>
and a closing line of the format
<PRE>
    *--#] name :
</PRE>
in which the first character is actually the current 
commentary<A NAME="1200"></A> character (see the #commentchar instruction). 
All lines between two such lines are considered to be the contents of the 
fold. If FORM decides that it needs this fold, it will read these contents 
and put them in its input stream. More about folds is explained in the 
manual of the STedi editor which is also provided in the FORM 
distribution.

<P>

<H1><A ID="SECTION004350000000000000000"></A>
<A ID="preinside"></A>
<BR>
#inside
</H1>

<P>
Syntax:

<P>
#inside $var1 [more $variables]

<P>
See also #endinside (<A HREF="#preendinside">3.24</A>)

<P>
Used to<A NAME="1204"></A> execute a few statements on the contents 
of one or more dollar variables (see <A HREF="#dollars">6</A>) during compilation time.
Although this is a preprocessor instruction one can use the 
triple dot operator provided one uses the generic version with the <SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img39.svg"
 ALT="$&lt;&gt;$"></SPAN>.

<P>
The statements in the scope of the #inside / #endinside 
construction must be regular executable statements. They may not contain 
end-of-module instructions like the .sort instruction. It is allowed to use 
dollar variables, procedures and preprocessor do loops and if's, but it is 
not allowed to nest the #inside / #endinside constructions.

<P>

<H1><A ID="SECTION004360000000000000000"></A>
<A ID="premessage"></A>
<BR>
#message
</H1>

<P>
Syntax:

<P>
#message themessagestring

<P>
This instruction places a message<A NAME="1208"></A> in the output 
that is clearly marked as such. It is printed with an initial three 
characters in front as in
<PRE>
    Symbols a,b,c;
    #message Simple example;
~~~Simple example;
    Local F = (a+b+c)^10;
    .end

Time =       0.00 sec    Generated terms =         66
                F        Terms in output =         66
                         Bytes used      =       1138
</PRE>
Note that the semicolon<A NAME="1211"></A> is not needed and if present is 
printed as well. If one needs messages without this clear marking, one 
should use the #write<A NAME="1212"></A> instruction.

<P>

<H1><A ID="SECTION004370000000000000000"></A>
<A ID="preopendictionary"></A>
<BR>
#opendictionary
</H1>

<P>
Syntax:

<P>
#opendictionary name

<P>
See chapter <A HREF="#dictionaries">13</A> on dictionaries.

<P>
Opens a dictionary and makes it ready for adding words to it. If 
the dictionary does not exist yet, it will be created.

<P>

<H1><A ID="SECTION004380000000000000000"></A>
<A ID="preoptimize"></A>
<BR>
#optimize
</H1>

<P>
Syntax:

<P>
#optimize nameofoneexpression

<P>
See the chapter about optimization <A HREF="#optimization">10</A>

<P>

<H1><A ID="SECTION004390000000000000000"></A>
<A ID="prepipe"></A>
<BR>
#pipe
</H1>

<P>
Syntax:

<P>
#pipe systemcommand

<P>
See also system (<A HREF="#presystem">3.58</A>)

<P>
This<A NAME="1222"></A> forces a system command to be executed by the 
operating system. The complete string (excluding initial blanks or tabs) is 
passed to the operating system. Next FORM will intercept the output of 
whatever is produced and read that as input. Hence, whenever output is 
produced FORM will take action, and it will wait when no output is ready. 
After the command has been finished, FORM will continue with the next line. 
This instruction has only been implemented on systems that support 
pipes<A NAME="1223"></A>. This is mainly UNIX<A NAME="1224"></A> and derived systems. 
Note that this instruction also introduces operating system dependent code. 
Hence it should be used with great care.

<P>

<H1><A ID="SECTION004400000000000000000"></A>
<A ID="prepreout"></A>
<BR>
#preout
</H1>

<P>
Syntax:

<P>
#preout ON

<P>
#preout OFF

<P>
Turns<A NAME="1227"></A> listing of the output of the preprocessor 
to the compiler on or off. Example:
<PRE>
    #PreOut ON
    S   a1,...,a4;
 S,a1,a2,a3,a4
    L   F = (a1+...+a4)^2;
 L,F=(a1+a2+a3+a4)^2
    id  a4 = -a1;
 id,a4=-a1
    .end

Time =       0.00 sec    Generated terms =         10
                F        Terms in output =          3
                         Bytes used      =         52
</PRE>

<P>

<H1><A ID="SECTION004410000000000000000"></A>
<A ID="preprependpath"></A>
<BR>
#prependpath
</H1>

<P>
Syntax:

<P>
#prependpath pathname

<P>
See also appendpath&nbsp;(<A HREF="#preappendpath">3.7</A>)

<P>
Prepends the given path relative to the current file to the beginning
of the FORM path<A NAME="1233"></A>.

<P>

<H1><A ID="SECTION004420000000000000000"></A>
<A ID="preprinttimes"></A>
<BR>
#printtimes
</H1>

<P>
Syntax:

<P>
#printtimes

<P>
Prints<A NAME="1236"></A> the current execution time and real 
time in the same way as done at the end of the program. Helps in monitoring 
the real time passed in TFORM jobs.
Example:
<PRE>
    #Printtimes
  423.59 sec + 5815.88 sec: 6239.47 sec out of 1215.29 sec
</PRE>

<P>

<H1><A ID="SECTION004430000000000000000"></A>
<A ID="preprocedure"></A>
<BR>
#procedure
</H1>

<P>
Syntax:

<P>
#procedure name(var1,...,varn)

<P>
See also endprocedure (<A HREF="#preendprocedure">3.25</A>), call
(<A HREF="#precall">3.10</A>)

<P>
Name<A NAME="1243"></A> is the name of the 
procedure<A NAME="1244"></A>. It will be referred to by this name. If the 
procedure resides in a separate file the name of the file should be 
name.prc and the #procedure instruction should form the first line of the 
file. The # should be the first character of the file. The parameter field 
is optional. If there are no parameters, the procedure should also be 
called without parameters (see the #call instruction). The parameters 
(here called var1 to varn) are preprocessor variables and hence they should 
be referred to between a backquote<A NAME="1245"></A>/quote<A NAME="1246"></A> pair 
as in `var1' to `varn'. If there exist already variables with such names 
when the procedure is called, the new definition comes on top of the old 
one. Hence in the procedure (and procedures called from it, unless the same 
problems occurs there too, as would be the case with recursions) the new 
definition is used, and it is released again when control returns from the 
procedure. After that the old definition will be in effect again.

<P>
If the procedure is included in the regular input stream, FORM will read 
the text of the procedure until the #endprocedure<A NAME="1247"></A> 
instruction and store it in a special buffer. When the procedure is called, 
FORM will read the procedure from this buffer, rather than from a file. In 
systems where file transfer is slow (very busy server with a slow network) 
this may be faster, especially when many small procedures are called.

<P>
One way to make libraries<A NAME="1248"></A><A NAME="1249"></A> that 
contain many procedures and maybe more code is to put all procedures into 
one header (.h) file and include this file at the beginning of the program 
with a #include<A NAME="1250"></A> instruction. This way one has all 
procedures load and one knows for sure that it are the proper procedures as 
it guards against the inadvertently picking up of procedures from other 
directories. It also makes for fewer files and hence makes for better 
housekeeping.

<P>

<H1><A ID="SECTION004440000000000000000"></A>
<A ID="preprocedureextension"></A>
<BR>
#procedureextension
</H1>

<P>
Syntax:

<P>
#procedureextension string

<P>
See also #call (<A HREF="#precall">3.10</A>)

<P>
The default<A NAME="1254"></A> extension of procedures 
is .prc<A NAME="1255"></A> in FORM. It is however possible that this clashes with 
the extensions used by other programs like the Grace<A NAME="1256"></A> system 
(Yuasa et al, Prog. Theor. Phys. Suppl. 138(2000)18 ). In that case it is 
possible to change the extension of the procedures in the current program. 
This is either done via the setup (page <A HREF="#setup">17</A>) or by the 
#procedureextension instruction of the preprocessor. The new string 
replaces the string prc, used by default. For the new string the following 
restrictions hold:

<OL>
<LI>The first character must be alphabetic
</LI>
<LI>No whitespace characters (blanks and/or tabs) are allowed
</LI>
</OL>
For the rest any characters can be used.

<P>
The new extension will remain valid either till the next 
#procedureextension instruction or to the next .clear<A NAME="1260"></A> 
instruction (page <A HREF="#instrclear">4</A>), whatever comes first.

<P>

<H1><A ID="SECTION004450000000000000000"></A>
<A ID="preprompt"></A>
<BR>
#prompt
</H1>

<P>
Syntax:

<P>
#prompt [newprompt]

<P>
Sets a new prompt<A NAME="1264"></A> for the current external 
command (if present) and all further (newly started) external commands.

<P>
If newprompt is an empty string, the default prompt (an empty line) will be 
used.

<P>
The prompt<A NAME="1265"></A> is a line consisting of a single prompt string. By 
default, this is an empty string.

<P>

<H1><A ID="SECTION004460000000000000000"></A>
<A ID="preredefine"></A>
<BR>
#redefine
</H1>

<P>
Syntax:

<P>
#redefine name "string"

<P>
See also define (<A HREF="#predefine">3.18</A>), undefine 
(<A HREF="#preundefine">3.62</A>)

<P>
in which<A NAME="1270"></A> name refers to the name of the 
preprocessor<A NAME="1271"></A> 
variable<A NAME="1272"></A> to be redefined. The contents of the 
string will be its new value. If no variable of the given name exists yet, 
the instruction will be equivalent to the #define<A NAME="1273"></A> 
instruction.

<P>

<H1><A ID="SECTION004470000000000000000"></A>
<A ID="preremove"></A>
<BR>
#remove
</H1>

<P>
Syntax:

<P>
#remove <SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img23.svg"
 ALT="$&lt;$"></SPAN>filename<SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img24.svg"
 ALT="$&gt;$"></SPAN>

<P>
See also write (<A HREF="#prewrite">3.64</A>), append (<A HREF="#preappend">3.6</A>),
            create (<A HREF="#precreate">3.16</A>), close (<A HREF="#preclose">3.13</A>)

<P>
Deletes<A NAME="1280"></A> the named file from the system. Under 
UNIX<A NAME="1281"></A> this would be equivalent to the instruction
<PRE>
    #system rm filename
</PRE>
and under MS-DOS<A NAME="1284"></A> oriented systems like Windows<A NAME="1285"></A> 
it would be equivalent to
<PRE>
    #system del filename
</PRE>
The difference with the #system<A NAME="1288"></A> instruction is that the 
#remove<A NAME="1289"></A> instruction does not depend on the particular 
syntax of the operating system. Hence the #remove instruction can always 
be used.

<P>

<H1><A ID="SECTION004480000000000000000"></A>
<A ID="prereset"></A>
<BR>
#reset
</H1>

<P>
Syntax:

<P>
#reset [<SPAN style="font-family:monospace">&lt;</SPAN>keyword<SPAN style="font-family:monospace">&gt;</SPAN>]

<P>
See also `TIMER_' preprocessor variable.

<P>
Currently the only keywords that are allowed are timer and 
stopwatch. They have the same effect, which is to reset the timer for the 
`timer_' (or `stopwatch_) preprocessor variable (see <A HREF="#preprovariables">3.1</A>).

<P>

<H1><A ID="SECTION004490000000000000000"></A>
<A ID="prereverseinclude"></A>
<BR>
#reverseinclude
</H1>

<P>
Syntax:

<P>
#reverseinclude[<SPAN CLASS="MATH"><IMG STYLE="height: 1.75ex; vertical-align: -0.30ex; " SRC="img38.svg"
 ALT="$-+$"></SPAN>] filename

<P>
#reverseinclude[<SPAN CLASS="MATH"><IMG STYLE="height: 1.75ex; vertical-align: -0.30ex; " SRC="img38.svg"
 ALT="$-+$"></SPAN>] filename # foldname

<P>
This instruction is identical to the #include <A HREF="#preinclude">3.34</A> 
instruction, with the exception that the statements and instructions in the 
file are read in reverse order. This can be useful at times when code is 
generated in a particular order in a file and one would like to 'undo' this 
code. It is somewhat related to the effects of the debugflag option 
(<A HREF="#optimdebugflag">10.0.1</A>) in the optimization options of the format statement 
<A HREF="#optimization">10</A>.

<P>
There are a few limitations. If, for instance, linefeeds or semicolons 
occur inside preprocessor variables, the reading routines cannot see this. 
Additionally unfinished strings (unmatched double quotes) will result in 
a fatal error. On the other hand the fold structure remains preserved.

<P>

<H1><A ID="SECTION004500000000000000000"></A>
<A ID="prermexternal"></A>
<BR>
#rmexternal
</H1>

<P>
Syntax:

<P>
#rmexternal [n]

<P>
Terminates<A NAME="1302"></A> an external command. The integer 
number n must be either the descriptor of a running external command, or 0.

<P>
If n is 0, then all external programs will be terminated.

<P>
If n is not specified, the current external command will be terminated.

<P>
The action of this instruction depends on the attributes of the external 
channel (see the #setexternalattr<A NAME="1303"></A> (section 
<A HREF="#setexternalcommunication">19.5</A>) instruction). By default, the instruction 
closes the commands' IO channels, sends a KILL<A NAME="1305"></A> signal to 
every process in its process group and waits for the external command to be 
finished.

<P>

<H1><A ID="SECTION004510000000000000000"></A>
<A ID="prermseparator"></A>
<BR>
#rmseparator
</H1>

<P>
Syntax:

<P>
#rmseparator character

<P>
See also #addseparator (<A HREF="#preaddseparator">3.5</A>),
            #call (<A HREF="#precall">3.10</A>), #do (<A HREF="#predo">3.19</A>)

<P>
Removes a character<A NAME="1311"></A> from the list of permissible 
separator characters for arguments of #call or #do instructions. By 
default the two characters that are permitted are the comma and the 
character <code>|</code>. Blanks, tabs and double quotes are ignored. Note that 
the comma must be specified between double quotes as in
<PRE>
  #rmseparator ","
</PRE>

<P>

<H1><A ID="SECTION004520000000000000000"></A>
<A ID="presetexternal"></A>
<BR>
#setexternal
</H1>

<P>
Syntax:

<P>
#setexternal n

<P>
Sets<A NAME="1316"></A> the &ldquo;current&rdquo; external command. The 
instructions #toexternal<A NAME="1317"></A> and 
#fromexternal<A NAME="1318"></A> deal with the current external 
command.  The integer number n must be the descriptor of a running external 
command.

<P>

<H1><A ID="SECTION004530000000000000000"></A>
<A ID="presetexternalattr"></A>
<BR>
#setexternalattr
</H1>

<P>
Syntax:

<P>
#setexternalattr list_of_attributes

<P>
sets<A NAME="1321"></A> attributes for <EM>newly started</EM> 
external commands. Already running external commands are not affected. The 
list of attributes is a comma separated list of pairs attribute=value, 
e.g.:
<PRE>
   #setexternalattr shell=noshell,kill=9,killall=false
</PRE>
Possible attributes are:
<DL>
<DT><STRONG>kill<A NAME="1326"></A></STRONG></DT>
<DD>specifies the signal to be sent to the external command 
either before the termination of the FORM program or by the preprocessor 
instruction <code>#rmexternal</code>. By default this is 9 (
SIGKILL<A NAME="1327"></A>). Number 0 means that no signal will be sent.
</DD>
<DT><STRONG>killall<A NAME="1328"></A></STRONG></DT>
<DD>Indicates whether the kill signal will be sent to the whole 
group or only to the initial process. Possible values are &ldquo;<code>true</code>&rdquo; 
and &ldquo;<code>false</code>&rdquo;. By default, the kill signal will be sent to the
whole group.
</DD>
<DT><STRONG>daemon<A NAME="1329"></A></STRONG></DT>
<DD>Indicates whether the command should be &ldquo;daemonized&rdquo;, i.e. 
the initial process will be passed to the init process and will belong
to the new process group in the new session.  
Possible values are &ldquo;<code>true</code>&rdquo; and &ldquo;<code>false</code>&rdquo;. By default, 
&ldquo;<code>true</code>&rdquo;.
</DD>
<DT><STRONG>shell<A NAME="1330"></A></STRONG></DT>
<DD>specifies which shell<A NAME="1331"></A> is used to run a
command. (Starting an external command in a subshell permits to
start not only executable files but also scripts<A NAME="1332"></A> and 
pipelined<A NAME="1333"></A> jobs. The disadvantage is that there is no 
way to detect failure upon startup since usually the shell is started 
successfully.) By default this is &ldquo;<code>/bin/sh -c</code>&rdquo;.  If set 
<code>shell=noshell</code>, the command will be stared by the instruction 
#external<A NAME="1334"></A> directly but not in a subshell, so the command 
should be a name of the executable file rather than a system command. The 
instruction #external will duplicate the actions of the shell in searching 
for an executable file if the specified file name does not contain a slash 
(/) character.  The search path is the path specified in the environment by 
the PATH<A NAME="1335"></A> variable.  If this variable isn't specified, the 
default path &ldquo;<code>:/bin:/usr/bin</code>&rdquo;
is used.
</DD>
<DT><STRONG>stderr<A NAME="1336"></A></STRONG></DT>
<DD>specifies a file to redirect the standard<A NAME="1337"></A> error 
stream to. By default it is &ldquo;<code>/dev/null</code>&rdquo;. If set 
<code>stderr=terminal</code>, no redirection occurs.
</DD>
</DL>
Only attributes that are explicitly mentioned are changed, all others remain 
unchanged. Note, changing attributes should be done with care. For example,
<PRE>
   #setexternalattr daemon=false
</PRE>
starts a command in the subshell within the current process group with
default attributes kill=9 and killall=true.
The instruction #rmexternal<A NAME="1341"></A> sends the
KILL<A NAME="1342"></A> signal to the wholegroup, which means that also 
FORM itself will be killed.

<P>

<H1><A ID="SECTION004540000000000000000"></A>
<A ID="presetrandom"></A>
<BR>
#setrandom
</H1>

<P>
Syntax:

<P>
#setrandom number

<P>
See also random_ (<A HREF="#funrandom">8.56</A>) and ranperm_ (<A HREF="#funranperm">8.57</A>)

<P>
The #setrandom<A NAME="1347"></A> instruction initializes the 
random number generator 
random_&nbsp;<A HREF="#funrandom">8.56</A><A NAME="1349"></A><A NAME="1350"></A>. The 
number that is used as a seed can have the length of two words in FORM. 
This means that on a 32-bits computer it can be an (unsigned) 32-bits 
integer and on a 64-bits computer it can be an (unsigned) 64 bits integer. 
If there is no #setrandom instruction the random number generator is 
initialized in a built in standard way. The #setrandom instruction also 
initializes the random number generators of the workers when one uses TFORM 
or ParFORM. They are initialized with different seeds that are derived in a 
non-trivial way from the seed given by the user and the number of the 
worker.

<P>

<H1><A ID="SECTION004550000000000000000"></A>
<A ID="preshow"></A>
<BR>
#show
</H1>

<P>
Syntax:

<P>
#show [preprocessorvariablename[s]]

<P>
If no names<A NAME="1353"></A> are present, the contents of all 
preprocessor variables<A NAME="1354"></A> will be printed to the 
regular output. If one or more preprocessor variables are specified 
(separated by comma's), only their contents will be printed. The 
preprocessor variables should be represented by their name only. No 
enclosing backquote/quote should be used, because that would force a 
substitution of the preprocessor variable before the instruction gets to 
see the name. Example:
<PRE>
    #define MAX "3"
    Symbols a1,...,a`MAX';
    L F = (a1+...+a`MAX')^2;
    #show
#The preprocessor variables:
0: VERSION_ = "3"
1: SUBVERSION_ = "2"
2: NAMEVERSION_ = ""
3: DATE_ = "Wed Feb 28 08:43:20 2007"
4: NAME_ = "testpre.frm"
5: CMODULE_ = "1"
6: MAX = "3"
    .end

Time =       0.00 sec    Generated terms =          6
                F        Terms in output =          6
                         Bytes used      =        102
</PRE>
We see that the variable MAX has indeed the value 3. There are six 
additional variables which have been defined by FORM itself. Hence the 
trailing underscore which cannot be used in user defined names. The current 
version of FORM is shown in the variable VERSION_<A NAME="1357"></A> and the 
name of the current program is given in the variable NAME_<A NAME="1358"></A>. 
For more about the system defined preprocessor variables see 
<A HREF="#preprovariables">3.1</A>.

<P>
There is another preprocessor variable that does not show in the listings. 
Its name is SHOWINPUT_<A NAME="1360"></A>. This variable has the value one 
if the listing of the input is on and the value zero if the listing of the 
input is off.

<P>

<H1><A ID="SECTION004560000000000000000"></A>
<A ID="preskipextrasymbols"></A>
<BR>
#skipextrasymbols
</H1>

<P>
Syntax:

<P>
#skipextrasymbols positivenumber

<P>
See also ExtraSymbols&nbsp;(<A HREF="#substaextrasymbols">7.53</A>) and the chapter 
on optimization&nbsp;(<A HREF="#optimization">10</A>).

<P>
This instructions adds a number of dummy extra 
symbols<A NAME="1365"></A> to the list of extra 
symbols&nbsp;(<A HREF="#substaextrasymbols">7.53</A>). This can be used when several 
optimizations are done on an expression in such a way that the extra 
symbols of previous optimizations are still present. Normally the number 
space for them is erased in a #clearoptimize instruction. This can be 
avoided with a sequence like
<PRE>
	#skipextrasymbols,{`optimmaxvar_'-`optimminvar_'+1}
</PRE>
In this case the numbering of the next optimization will start after the 
last extra symbol of the previous optimization.
One should realize however that the definitions of the extra symbols are 
not kept once the new optimization is started or once a #clearoptimize 
instruction is issued. Example:
<PRE>
   #-
   S   a,b,c,d,e;
   L   F = (a+b+c+d+3*e)^3;
   B   b;
   .sort
   ExtraSymbols,array,w;
   Format O3,stats=ON;
   #optimize F
   #write &lt;&gt; "  %4O"
   .sort
   #SkipExtraSymbols,{`optimmaxvar_'-`optimminvar_'+1}
   id  b = b+1;
   Print +f;
   B   b;
   .end
</PRE>
Because the O3 format is still active, the final printing uses the 
optimization as well. If the #SkipExtraSymbols instruction would have been 
omitted, the numbering would start again from one, while the rhs. of their 
definitions would contain the old extra symbols. The result would be 
incorrect.

<P>

<H1><A ID="SECTION004570000000000000000"></A>
<A ID="preswitch"></A>
<BR>
#switch
</H1>

<P>
Syntax:

<P>
#switch string

<P>
See also endswitch (<A HREF="#preendswitch">3.26</A>),
        case (<A HREF="#precase">3.11</A>),
        break (<A HREF="#prebreak">3.8</A>),
        default (<A HREF="#predefault">3.17</A>)

<P>
the<A NAME="1377"></A> string could for instance be a preprocessor 
variable as in
<PRE>
    #switch `i'
</PRE>
The #switch<A NAME="1380"></A> instruction, together with 
#case<A NAME="1381"></A>, #break<A NAME="1382"></A>, #default<A NAME="1383"></A> 
and #endswitch<A NAME="1384"></A>, allows the user to conveniently make 
code for a number of cases that are distinguished by the value of a 
preprocessor variable. In the past this was only possible with the use of 
folds<A NAME="1385"></A> in the #include<A NAME="1386"></A> instruction and the 
corresponding include file<A NAME="1387"></A> (see <A HREF="#preinclude">3.34</A>). 
Because few people have an editor like STedi (see the FORM distribution 
site) that can handle the folds in a proper way, it was judged that the 
more common switch mechanism might be friendlier. The proper syntax of a 
complete construction would be
<PRE>
    #switch `par'
    #case 1
       some statements
    #break
    #case ax2
       other statements
    #break
    #default
       more statements
    #break
    #endswitch
</PRE>
The number of cases is not limited. The compare between the strings in the 
#switch instruction and in the #case instructions is as a text string. 
Hence numerical strings have no special meaning. If a #break instruction 
is omitted, control may go into another case. This is called 
fall-through<A NAME="1391"></A>. 
This is a way in which one can have the same statements for several cases. 
The #default instruction is not mandatory.

<P>
FORM will look for the first case of which the string matches the string 
in the #switch instruction. Input reading (control flow) starts after this 
#case instruction, and continues till either a #break instruction is 
encountered, or the #endswitch is met. After that input reading continues 
after the #endswitch instruction. If no case has a matching string, input 
reading starts after the #default instruction. If no #default instruction 
is found, input reading continues after the matching #endswitch 
instruction.

<P>
#switch constructions can be nested<A NAME="1392"></A>. They can be combined 
with #if<A NAME="1393"></A> constructions, #do<A NAME="1394"></A> instructions, etc. 
but they should obey normal nesting rules (as with nesting of 
brackets<A NAME="1395"></A> of different types).

<P>

<H1><A ID="SECTION004580000000000000000"></A>
<A ID="presystem"></A>
<BR>
#system
</H1>

<P>
Syntax:

<P>
#system [-e] systemcommand

<P>
See also pipe (<A HREF="#prepipe">3.39</A>)

<P>
This forces a system<A NAME="1399"></A> command to be executed by 
the operating system. The complete string (excluding initial blanks or 
tabs) is passed to the operating system. FORM will then wait until control 
is returned. Note that this instruction introduces operating system 
dependent code. Hence it should be used with great care.

<P>
Without the -e option execution of the Form program will halt if 
the system command returns an error. With the -e option the Form program 
will continue execution. The value of the return code of the system command 
can be found in the SYSTEMERROR_<A NAME="1400"></A> preprocessor variable.

<P>

<H1><A ID="SECTION004590000000000000000"></A>
<A ID="preterminate"></A>
<BR>
#terminate
</H1>

<P>
Syntax:

<P>
#terminate [exitcode]

<P>
This forces FORM to terminate<A NAME="1403"></A> execution 
immediately. If an exit code is given (an integer number), this will be the 
return value that FORM gives to the shell program from which it was run. If 
no return value is specified, the value -1 will be returned.

<P>

<H1><A ID="SECTION004600000000000000000"></A>
<A ID="pretimeoutafter"></A>
<BR>
#timeoutafter
</H1>

<P>
Syntax:

<P>
#timeoutafter <SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img23.svg"
 ALT="$&lt;$"></SPAN>Number of seconds<SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img24.svg"
 ALT="$&gt;$"></SPAN>

<P>
This instruction starts a timer. When the given time expires the 
current program will be terminated, unless the timer is reset before this 
time. Resetting the timer is dome with the "#timeoutafter 0" instruction.

<P>
The purpose of this instruction is to prevent runaway programs, because a 
given subpart takes much more time than it should. Example:
<PRE>
    .sort
	#timeoutafter 1000
	#call problematicprocedure
	.sort
	#timeoutafter 0
</PRE>
If one runs many diagrams with a make-like facility like minos, diagrams 
that behave in an unexpected way can be killed this way and minos can 
continue with the next diagram. Later one can see which diagrams caused 
problems and one may study what the problem was.

<P>

<H1><A ID="SECTION004610000000000000000"></A>
<A ID="pretoexternal"></A>
<BR>
#toexternal
</H1>

<P>
Syntax:

<P>
#toexternal "formatstring" <SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img23.svg"
 ALT="$&lt;$"></SPAN>,variables<SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img24.svg"
 ALT="$&gt;$"></SPAN>

<P>
Sends<A NAME="1410"></A> the output to the current external 
command. The semantics of the <code>"formatstring"</code> and the
<code>[,variables]</code> is the same as for the #write<A NAME="1411"></A> 
instruction, except for the trailing end-of-line symbol. In contrast to the 
#write instruction, the #toexternal instruction does not append any new 
line symbol to the end of its output.

<P>

<H1><A ID="SECTION004620000000000000000"></A>
<A ID="preundefine"></A>
<BR>
#undefine
</H1>

<P>
Syntax:

<P>
#undefine name

<P>
See also define (<A HREF="#predefine">3.18</A>), redefine 
(<A HREF="#preredefine">3.46</A>)

<P>
<A NAME="1416"></A> Name refers to the name of the 
preprocessor variable<A NAME="1417"></A> to be undefined. This 
statement causes the given preprocessor variable to be removed from the 
stack of preprocessor variables. If an earlier instance of this variable 
existed (other variable with the same name), it will become active again. 
There are various other ways by which preprocessor variables can become 
undefined. All variables belonging to a procedure are undefined at the end 
of a procedure, and so are all other preprocessor variables that were 
defined inside this procedure. The same holds for the preprocessor variable 
that is used as a loop parameter in the #do<A NAME="1418"></A> instruction.

<P>

<H1><A ID="SECTION004630000000000000000"></A>
<A ID="preusedictionary"></A>
<BR>
#usedictionary
</H1>

<P>
Syntax:

<P>
#usedictionary name
#usedictionary name (options)

<P>
See chapter <A HREF="#dictionaries">13</A> on dictionaries.

<P>
Starts using a dictionary for output translation.

<P>

<H1><A ID="SECTION004640000000000000000"></A>
<A ID="prewrite"></A>
<BR>
#write
</H1>

<P>
Syntax:

<P>
#write [<SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img23.svg"
 ALT="$&lt;$"></SPAN>filename<SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img24.svg"
 ALT="$&gt;$"></SPAN>] "formatstring" [,variables]

<P>
See also append (<A HREF="#preappend">3.6</A>),
            create (<A HREF="#precreate">3.16</A>), remove (<A HREF="#preremove">3.47</A>),
            close (<A HREF="#preclose">3.13</A>)

<P>
If there<A NAME="1428"></A> is no file specified, the output will be 
to the regular output<A NAME="1429"></A> channel. If a file is 
specified, FORM will look whether this file is open already. If it is open 
already, the specified output will be added to the file. If it is not open 
yet it will be opened. Any previous contents will be lost. This would be 
equivalent to using the #create<A NAME="1430"></A> instruction first. If 
output has to be added to an existing file, the #append<A NAME="1431"></A> 
instruction should be used first.

<P>
The format<A NAME="1432"></A> string is like a format string in the 
language C<A NAME="1433"></A>. This means 
that it is placed between double quotes. It will contain text that will be 
printed, and it will contain special character sequences for special 
actions. These sequences and the corresponding actions are:
<DL>
<DT><STRONG><SPAN CLASS="MATH"><IMG STYLE="height: 2.53ex; vertical-align: -0.69ex; " SRC="img40.svg"
 ALT="$\backslash$"></SPAN>n</STRONG></DT>
<DD>A newline<A NAME="1435"></A> character.
</DD>
<DT><STRONG><SPAN CLASS="MATH"><IMG STYLE="height: 2.53ex; vertical-align: -0.69ex; " SRC="img40.svg"
 ALT="$\backslash$"></SPAN>t</STRONG></DT>
<DD>A tab<A NAME="1436"></A> character.
</DD>
<DT><STRONG><SPAN CLASS="MATH"><IMG STYLE="height: 2.53ex; vertical-align: -0.69ex; " SRC="img40.svg"
 ALT="$\backslash$"></SPAN>"</STRONG></DT>
<DD>A double<A NAME="1437"></A> quote character.
</DD>
<DT><STRONG><SPAN CLASS="MATH"><IMG STYLE="height: 2.53ex; vertical-align: -0.69ex; " SRC="img40.svg"
 ALT="$\backslash$"></SPAN>b</STRONG></DT>
<DD>A backslash<A NAME="1438"></A> character.
</DD>
<DT><STRONG>%%</STRONG></DT>
<DD>The character %<A NAME="1439"></A>.
</DD>
<DT><STRONG>%</STRONG></DT>
<DD>If the last character in the string, it causes the omission of a 
linefeed<A NAME="1440"></A> at the end of the printing. Note that if this 
happens in the regular output (as opposed to a file) there may be 
interference with the listing of the input.
</DD>
<DT><STRONG>%$</STRONG></DT>
<DD>A dollar variable<A NAME="1441"></A>. The variable should be 
indicated in the list of variables. Each occurrence of %$ will look for 
the next variable.
</DD>
<DT><STRONG>%e</STRONG></DT>
<DD>An active expression<A NAME="1442"></A>. The expression should be 
indicated in the list of variables. Each occurrence of %e will look for 
the next variable. Unlike the output caused by the print statement the 
expression will be printed without its name and there will also be no 
<code>=</code> sign unless there is one in the format string of course. If the 
current output format is fortran<A NAME="1443"></A> output there is an extra option. After the 
name of the expression one should put between parentheses the name to be 
used when there are too many continuation cards.
</DD>
<DT><STRONG>%+e</STRONG></DT>
<DD>Like %e, but like the +s option in the Print 
statement<A HREF="#substaprint">7.113</A> where each term starts on a new line.
</DD>
<DT><STRONG>%E</STRONG></DT>
<DD>Like %e, but whereas the %e terminates the expression with a 
;, the %E does not give this trailing semicolon<A NAME="1445"></A>.
</DD>
<DT><STRONG>%+E</STRONG></DT>
<DD>Like %E, but like the +s option in the Print 
statement<A HREF="#substaprint">7.113</A> where each term starts on a new line.
</DD>
<DT><STRONG>%s</STRONG></DT>
<DD>A string<A NAME="1447"></A>. The string should be 
given in the list of variables and be enclosed between double quotes. Each 
occurrence of %s will look for the next variable in the list.
</DD>
<DT><STRONG>%f</STRONG></DT>
<DD>A file<A NAME="1448"></A>. The name of the file will be expected in the 
list of variables. The file is searched for in the current directory, then 
in path indicated by the path variable in the setup file or at the 
beginning of the file (see chapter <A HREF="#setup">17</A> on the setup file), then in 
the path specified in the -p option when FORM is started (see the chapter 
on running FORM). If this option has not been used, FORM will look for the 
environment variable FORMPATH<A NAME="1450"></A>. If this variable exists it 
will be interpreted as a path and FORM will search the indicated 
directories for the given file. If none is found there will be an error 
message and execution will be halted.
</DD>
<DT><STRONG>%X</STRONG></DT>
<DD>Forces the printing of the list of extra symbols 
(<A HREF="#sect-extrasymbols">2.11</A>) and their definitions<A NAME="1452"></A>.
</DD>
<DT><STRONG>%O</STRONG></DT>
<DD>Forces the printing of the definitions of the extra symbols in 
the buffer with the temporary variables from the previous optimization (see 
the chapter on optimizations <A HREF="#optimization">10</A>). 
</DD>
</DL>
If no special variables are asked for (by means of %$, %e, %E or %s) 
the list of variables will be ignored (if present). Example:
<PRE>
    Symbols a,b;
    L   F = a+b;
    #$a1 = a+b;
    #$a2 = (a+b)^2;
    #$a3 = $a1^3;
    #write " One power: %$\n Two powers: %$\n Three powers: %$\n%s"\
           ,$a1,$a2,$a3," The end"
 One power: b+a
 Two powers: b^2+2*a*b+a^2
 Three powers: b^3+3*a*b^2+3*a^2*b+a^3
 The end
    .end

Time =       0.00 sec    Generated terms =          2
                F        Terms in output =          2
                         Bytes used      =         32
</PRE>
We see that the writing occurs immediately after the #write<A NAME="1457"></A> 
instruction, because it is done by the preprocessor. Hence the output comes 
before the execution of the expression F.
<PRE>
    S   x1,...,x10;
    L   MyExpression = (x1+...+x10)^4;
    .sort
    Format Fortran;
    #write &lt;fun.f&gt; "      FUNCTION fun(x1,x2,x3,x4,x5,x6,x7,x8,x9,x10)"
    #write &lt;fun.f&gt; "      REAL x1,x2,x3,x4,x5,x6,x7,x8,x9,x10"
    #write &lt;fun.f&gt; "      fun = %e",MyExpression(fun)
    #write &lt;fun.f&gt; "      RETURN"
    #write &lt;fun.f&gt; "      END"
    .end
</PRE>
Some remarks are necessary here. Because the #write is a preprocessor 
instruction, the .sort<A NAME="1460"></A> is essential. Without it, the 
expression has not been worked out at the moment we want to write. The name 
of the expression is too long for fortran<A NAME="1461"></A>, and hence the 
output file will use a different name (in this case the name `fun' was 
selected). The output file looks like
<PRE>
      FUNCTION fun(x1,x2,x3,x4,x5,x6,x7,x8,x9,x10)
      REAL x1,x2,x3,x4,x5,x6,x7,x8,x9,x10
      fun = 24*x1*x2*x3*x4 + 24*x1*x2*x3*x5 + 24*x1*x2*x3*x6 + 24*x1*x2
     &amp; *x3*x7 + 24*x1*x2*x3*x8 + 24*x1*x2*x3*x9 + 24*x1*x2*x3*x10 + 12*
          .....
     &amp; x8 + 4*x6**3*x9 + 4*x6**3*x10 + x6**4 + 24*x7*x8*x9*x10 + 12*x7*
     &amp; x8*x9**2
      fun = fun + 12*x7*x8*x10**2 + 12*x7*x8**2*x9 + 12*x7*x8**2*x10 + 
     &amp; 4*x7*x8**3 + 12*x7*x9*x10**2 + 12*x7*x9**2*x10 + 4*x7*x9**3 + 4*
     &amp; x7*x10**3 + 12*x7**2*x8*x9 + 12*x7**2*x8*x10 + 6*x7**2*x8**2 + 
     &amp; 12*x7**2*x9*x10 + 6*x7**2*x9**2 + 6*x7**2*x10**2 + 4*x7**3*x8 + 
     &amp; 4*x7**3*x9 + 4*x7**3*x10 + x7**4 + 12*x8*x9*x10**2 + 12*x8*x9**2
     &amp; *x10 + 4*x8*x9**3 + 4*x8*x10**3 + 12*x8**2*x9*x10 + 6*x8**2*
     &amp; x9**2 + 6*x8**2*x10**2 + 4*x8**3*x9 + 4*x8**3*x10 + x8**4 + 4*x9
     &amp; *x10**3 + 6*x9**2*x10**2 + 4*x9**3*x10 + x9**4 + x10**4

      RETURN
      END
</PRE>
and each time after 19 continuation lines we have to break the expression 
and use the <code>fun = fun +</code> trick to continue.

<P>

<H1><A ID="SECTION004650000000000000000">
Some remarks</A>
</H1>
It should be noted that the various constructions like 
#do<A NAME="1465"></A>/#enddo<A NAME="1466"></A>, 
#procedure<A NAME="1467"></A>/#endprocedure<A NAME="1468"></A>, 
#switch<A NAME="1469"></A>/#endswitch<A NAME="1470"></A> and 
#if<A NAME="1471"></A>/#endif<A NAME="1472"></A> all 
create a certain environment. These environments cannot be interweaved. This 
means that one cannot make code of the type
<PRE>
     #do i = 1,5
      #if ( `MAX' &gt; `i' )
         id f(`i') = g`i'(x);
     #enddo
      some statements
     #do i = 1,5
      #endif
     #enddo
</PRE>
whether this could be considered useful or not. Similarly one cannot make a 
construction that might be very useful:
<PRE>
     #do i = 1,5
       #do j`i' = 1,3
     #enddo
       some statements
     #do i = 1,5
       #enddo
     #enddo
</PRE>
Currently the syntax does not allow this. This may change in the future.

<P>

<P>

<H1><A ID="SECTION00500000000000000000"></A>
<A ID="modules"></A>
<BR>
Modules
</H1>

<P>
Modules<A NAME="2569"></A> are the basic execution<A NAME="2570"></A> blocks. 
Statements<A NAME="2571"></A> are always part of a module, and they will be 
executed only when the module is executed. This is directly opposite to 
preprocessor instructions which are executed when they are encountered in 
the input stream.

<P>
Modules are terminated by a line that starts with a period<A NAME="2572"></A>. 
Such a line is called the module<A NAME="2573"></A> instruction. 
Once the module instruction has been recognized, the compilation of the 
module is terminated and the module will be executed. All active 
expressions will be processed one by one, term by term. When each term of 
an expression has been through all statements of the module, the combined 
results of all operations on all the terms of the expression will be sorted 
and the resulting expression will be sent to the output. This can be an 
intermediate file<A NAME="2574"></A>, or it can be some 
memory<A NAME="2575"></A>, depending on the size of the output. If the combined 
output of all active expressions is less than the parameter 
&ldquo;ScratchSize&rdquo;<A NAME="2576"></A>, the results stay in memory. ScratchSize 
is one of the setup parameters (see chapter <A HREF="#setup">17</A>).

<P>
A module consists in general of several types of statements:
<DL>
<DT><STRONG>Declarations<A NAME="2579"></A></STRONG></DT>
<DD>These are the declarations of 
variables.
</DD>
<DT><STRONG>Specifications<A NAME="2580"></A></STRONG></DT>
<DD>These tell what to do with 
existing expressions as a whole.
</DD>
<DT><STRONG>Definitions<A NAME="2581"></A></STRONG></DT>
<DD>These define new expressions.
</DD>
<DT><STRONG>Executable<A NAME="2582"></A> statements</STRONG></DT>
<DD>The operations 
on all active expressions.
</DD>
<DT><STRONG>OutputSpecifications<A NAME="2583"></A></STRONG></DT>
<DD>These specify the 
output representation.
</DD>
<DT><STRONG>End-of-module specifications<A NAME="2584"></A></STRONG></DT>
<DD>Extra settings that are for this module only.
</DD>
<DT><STRONG>Mixed statements<A NAME="2585"></A></STRONG></DT>
<DD>They can occur in various 
classes. Most notably the print statement.
</DD>
</DL>
Statements must occur in such an order that no statement follows a 
statement of a later category. The only exception is formed by the mixed 
statements, which can occur anywhere. This is different from earlier 
versions of FORM in which the order of the statements was not fixed. This 
did cause a certain amount of confusion about the workings of FORM.

<P>
There are several types of modules.
<DL>
<DT><STRONG>.sort<A NAME="2588"></A></STRONG></DT>
<DD><A ID="instrsort"></A> The general end-of-module. 
Causes execution of all active expressions, and prepares them for the next 
module.
</DD>
<DT><STRONG>.end<A NAME="2590"></A></STRONG></DT>
<DD><A ID="instrend"></A> Executes all active expressions 
and terminates the program.
</DD>
<DT><STRONG>.store<A NAME="2592"></A></STRONG></DT>
<DD><A ID="instrstore"></A> Executes all active 
expressions. Then it writes all active global expressions to an 
intermediate storage file<A NAME="2594"></A> and removes all other 
non-global expressions. Removes all memory of declarations except for those 
that were made before a .global instruction.
</DD>
<DT><STRONG>.global<A NAME="2595"></A></STRONG></DT>
<DD><A ID="instrglobal"></A> No execution of 
expressions. It just saves declarations made thus far from being erased by 
a .store instruction.
</DD>
<DT><STRONG>.clear<A NAME="2597"></A></STRONG></DT>
<DD><A ID="instrclear"></A> Executes all active 
expressions. Then it clears all buffers with the exception of the main 
input stream. Continues execution in the main input stream as if the 
program had started at this point. The only parameters that cannot be 
changed at this point are the setup parameters. They remain. By default 
also the clock<A NAME="2599"></A> is reset. If this is not desired this can be 
changed by means of the ResetTimeOnClear<A NAME="2600"></A> setup 
variable (see chapter <A HREF="#setup">17</A>).
</DD>
</DL>
Each program must be terminated by a .end instruction. If such an 
instruction is absent and FORM encounters an end-of-input it will issue a 
warning and generate a .end instruction.

<P>
Module instructions can contain a special commentary that will be printed 
in all statistics that are generated during the execution of the module. 
This special commentary is restricted to 24 characters (the statistics have 
a fixed format and hence there is only a limited amount of space 
available). This commentary is initiated by a colon and terminated by a 
semicolon. The characters between this colon and the semicolon are the 
special message, also called advertisement. Example
<PRE>
	.sort:Eliminate x;
</PRE>
would give in the statistics something like
<PRE>
Time =       0.46 sec    Generated terms =        360
                F        Terms in output =        360
            Eliminate x  Bytes used      =       4506
</PRE>
If the statistics are switched off, there will be no printing of this 
advertisement either.

<P>
For backwards compatibility there is still an obsolete<A NAME="2607"></A> 
mechanism to pass module options via the module instructions. This is a 
feature which will probably disappear in future versions of FORM. We do 
give the syntax to allow the user to identify the option properly and 
enable proper translation into the moduleoption<A NAME="2608"></A> 
statement (see <A HREF="#substamoduleoption">7.89</A>).
<PRE>
    .sort(PolyFun=functionname);
    .sort(PolyFun=functionname):advertisement;
</PRE>
causes the given function to be treated as a polynomial<A NAME="2612"></A> 
function. This means that its (single) argument would be treated as the 
coefficient of the terms. The action of FORM on individual terms is

<OL>
<LI>Ignore polynomial functions with more than one argument.
</LI>
<LI>If there is no polynomial function with a single argument, generate 
one with the argument 1.
</LI>
<LI>If there is more than one polynomial function 
with a single argument, multiply the arguments and replace these functions 
with a single polynomial function with the product of the arguments for a 
single argument.
</LI>
<LI>Multiply the argument of the polynomial function with the coefficient 
of the term. Replace the coefficient itself by one.
</LI>
</OL>
If, after this, two terms differ only in the argument of their polynomial 
function FORM will add the arguments and replace the two terms by a single 
term which is identical to the two previous terms except for that the 
argument of its polynomial function is the sum of their two arguments.

<P>
It should be noted that the proper placement of .sort<A NAME="2615"></A> 
instructions in a FORM program is an art by itself. Too many .sort 
instructions cause too much sorting, which can slow execution down 
considerably. It can also cause the writing of intermediate expressions 
which are much larger than necessary, if the next statements would cause 
great simplifications. Not enough .sort instructions can make that 
cancellations are postponed unnecessarily and hence much work will be done 
double. This can slow down execution by a big factor. First an example of a 
superfluous .sort:
<PRE>
    S	a1,...,a7;
    L	F = (a1+...+a7)^16;
    .sort

Time =      31.98 sec    Generated terms =      74613
                F        Terms in output =      74613
                         Bytes used      =    1904316
    id	a7 = a1+a2+a3;
    .end

Time =     290.34 sec
                F        Terms active    =      87027
                         Bytes used      =    2253572

Time =     295.20 sec    Generated terms =     735471
                F        Terms in output =      20349
                         Bytes used      =     538884
</PRE>
Without the sort the same program gives:
<PRE>
    S	a1,...,a7;
    L	F = (a1+...+a7)^16;
    id	a7 = a1+a2+a3;
    .end

Time =     262.79 sec
                F        Terms active    =      94372
                         Bytes used      =    2643640

Time =     267.81 sec    Generated terms =     735471
                F        Terms in output =      20349
                         Bytes used      =     538884
</PRE>
and we see that the sorting in the beginning is nearly completely wasted. 
Now a clear example of not enough .sort instructions. A common problem is 
the substitution of one power<A NAME="2620"></A> series into another. If 
one does this in one step one could have:
<PRE>
    #define MAX "36"
    S  j,x(:`MAX'),y(:`MAX');
    *
    *	Power series expansion of ln_(1+x)
    *
    L	F = -sum_(j,1,`MAX',sign_(j)*x^j/j);
    *
    *	Substitute the expansion of x = exp_(y)-1
    *
    id	x = x*y;
    #do j = 2,`MAX'+1
    id	x = 1+x*y/`j';
    #enddo
    Print;
    .end

Time =      76.84 sec    Generated terms =      99132
                F        Terms in output =          1
                         Bytes used      =         18

   F =
      y;
</PRE>
With an extra .sort inside the loop one obtains for the same program (after 
suppressing some of the statistics:
<PRE>
    #define MAX "36"
    S  j,x(:`MAX'),y(:`MAX');
    *
    *	Power series expansion of ln_(1+x)
    *
    L	F = -sum_(j,1,`MAX',sign_(j)*x^j/j);
    *
    *	Substitute the expansion of x = exp_(y)-1
    *
    id	x = x*y;
    #do j = 2,`MAX'+1
    id	x = 1+x*y/`j';
    .sort: step `j';

Time =       0.46 sec    Generated terms =        360
                F        Terms in output =        360
                 step 2  Bytes used      =       4506
    #enddo
           .
           .
           .
Time =       3.07 sec    Generated terms =          3
                F        Terms in output =          1
                step 37  Bytes used      =         18
    Print;
    .end

Time =       3.07 sec    Generated terms =          1
                F        Terms in output =          1
                         Bytes used      =         18

   F =
      y;
</PRE>
It is very hard to give general rules that are more specific than what has 
been said above. The user should experiment with the placements of the .sort 
before making a very large run. 

<P>

<H1><A ID="SECTION00510000000000000000"></A>
<A ID="checkpoints"></A>
<BR>
Checkpoints
</H1>

<P>
If<A NAME="2627"></A> FORM programs have to run for a long time, the 
reliability of the hardware(computer system or network) or of the software 
infrastructure becomes a critical issue. Program 
termination<A NAME="2628"></A> due to unforeseen failures may waste days or 
weeks of invested execution time. The checkpoint mechanism was introduced 
to protect long running FORM programs as good as possible from such 
accidental interruptions. With activated checkpoints FORM will save its 
internal state and data from time to time on the hard disk. This data then 
allows a recovery from a crash<A NAME="2629"></A>.

<P>
The checkpoint mechanism can be activated or deactivated by <SPAN style="font-family:monospace">On</SPAN><A NAME="2631"></A> and <SPAN style="font-family:monospace">Off</SPAN><A NAME="2633"></A> statements. If the user has 
activated checkpoints, recovery<A NAME="2634"></A> data will be written to disk 
at the end of a module execution. Options allow to influence the details of 
the saving mechanism. If a program is terminated during execution, FORM can 
be restarted with the <SPAN style="font-family:monospace">-R</SPAN> option and it will continue its execution at 
the last saved recovery point.

<P>
The syntax of the checkpoint activation and deactivation is
<PRE>
    On checkpoint [&lt;OPTIONS&gt;];
    Off checkpoint;
</PRE>

<P>
If no options are given, the recovery data will be saved at the end of every
module<A NAME="2638"></A>. If one gives a time<A NAME="2639"></A>
<PRE>
    On checkpoint &lt;NUMBER&gt;[&lt;UNIT&gt;];
</PRE>
the saving will only be done if the given time has passed after the last 
saving. Possible unit specifiers are <SPAN style="font-family:monospace">s, m, h, d</SPAN> and the number will 
then be interpreted as seconds, minutes, hours, or days, respectively. The 
default unit is seconds.

<P>
If one needs to run a script<A NAME="2643"></A> before or after the saving,
one can specify a script filename.
<PRE>
    On checkpoint runbefore="&lt;SCRIPTFILENAME&gt;";
    On checkpoint runafter="&lt;SCRIPTFILENAME&gt;";
    On checkpoint run="&lt;SCRIPTFILENAME&gt;";
</PRE>
The option <SPAN style="font-family:monospace">run</SPAN><A NAME="2647"></A> sets both the scripts to be run before and 
after saving.The scripts must have the executable flag set and they must 
reside in the execution path of the shell<A NAME="2648"></A> (unless the filename 
already contains the proper path).

<P>
The scripts receive the module number<A NAME="2649"></A> as an argument 
(accessible as $1 inside the script). The return value of the script 
running before the saving will be interpreted. If the script returns an 
error (non-zero return value), a message will be issued and the saving will 
be skipped. 

<P>
The recovery data will be written to files named <SPAN style="font-family:monospace">FORMrecv.*</SPAN> with 
various name extensions. If a file <SPAN style="font-family:monospace">FORMrecv.tmp</SPAN> exists, FORM will not 
run unless one gives it the recovery option<A NAME="2652"></A>
<SPAN style="font-family:monospace">-R</SPAN>. This is to prevent the unintentional loss of recovery data. If 
FORM terminates successfully, all the additional data files will be removed.

<P>
The additional recovery files will be created in the directory containing 
the scratch files.  The extra files will occupy roughly as much space as 
the scratch files<A NAME="2654"></A> and the save<A NAME="2655"></A> and 
hide files<A NAME="2656"></A> combined. This extra space must be made 
available, of course.

<P>
If recovery data exists and FORM is started with the <SPAN style="font-family:monospace">-R</SPAN> option, FORM 
will continue execution after the last module that successfully wrote the 
recovery data. All the command line parameters that have been given to the 
crashed FORM program<A NAME="2658"></A> must also be given to the 
recovering FORM program. The input files are not part of the recovery data 
and will be read in anew when recovering. Therefore it is strongly 
discouraged to change any of these files between saving and recovery.

<H1><A ID="SECTION00600000000000000000"></A>
<A ID="pattern"></A>
<BR>
Pattern matching
</H1>

<P>
Substitutions<A NAME="2733"></A><A NAME="2734"></A> are made in FORM  
by specifying a generic object that should be replaced by an expression. 
This generic object is called a pattern<A NAME="2735"></A>. Patterns that the 
user may already be familiar with are the regular expressions in many 
UNIX<A NAME="2736"></A> based systems or just a statement like <code>ls *.frm</code> to 
list only files of which the name ends in <code>.frm</code>. In this case the 
<code>*</code> is called a wildcard<A NAME="2737"></A> that can take any string 
value. In symbolic manipulation there will be wildcards also, but their 
nature will be different. They are also indicated in a different way.

<P>
In FORM wildcard variables are indicated by attaching a 
question<A NAME="2738"></A> mark (?) to the name of a variable. The type 
of the variable indicates what type of object we are looking for. Assume 
the following id<A NAME="2739"></A> statements:
<PRE>
    Functions f,g;
    Symbol x;

    id f(g?,x) = g(x,x);
</PRE>
In this statement g will match any function and hence all occurrences 
of f, in which the first argument is a function and the second argument is 
the symbol x, will match. In the right hand side the function g will be 
substituted by whatever identity g had to assume in the left hand side to 
make the match. Hence <code>f(f,x)</code> will be replaced by <code>f(x,x)</code>.

<P>
In general function wildcards<A NAME="2742"></A> can only match 
functions. Even though tensors are special functions, regular function 
wildcards cannot match tensors, and tensor wildcards cannot match 
functions. However commuting<A NAME="2743"></A> function wildcards can match 
noncommuting<A NAME="2744"></A> functions <I CLASS="slanted">et vice versa</I>.

<P>
Index<A NAME="2746"></A> wildcards can only match indices. The 
dimension of the indices is not relevant. Hence:
<PRE>
    id f(mu?,mu?) = 4;
</PRE>
would match both <code>f(ka,ka)</code> and <code>f(2,2)</code>. We will see later 
how to be more selective about such matches.

<P>
When the same wildcard occurs more than once in a pattern, it should be 
matched by the same object in all its occurrences. Hence the above pattern 
would not match <code>f(mu,nu)</code>.

<P>
There is one complication concerning the above rule of index wildcards only 
matching indices. FORM writes contractions with vectors in a special 
shorthand notation called Schoonschip<A NAME="2749"></A> notation. Hence 
<code>f(mu)*p(mu)</code> becomes <code>f(p)</code>. This means that the substitution
<PRE>
    id f(mu?)*g(nu?) = fg(mu,nu);
</PRE>
should also replace the term <code>f(p)*g(q)</code> by <code>fg(p,q)</code>. In this 
case it looks like the wildcard indices matched the vectors. This is 
however not the case, because if we take the previous pattern (with the 
<code>f(mu?,mu?)</code>), it is not going to match the term <code>f(p,p)</code>, 
because this term should be read as something of the type
<code>f(mu,nu)*p(mu)*p(nu)</code>
and that term does not fit the pattern <code>f(mu?,mu?)</code>.

<P>
Vector<A NAME="2752"></A> wildcards can match vectors, but they can 
also match vector-like expressions in function arguments. A vector-like 
expression is an expression in which all terms contain one single vector 
without indices, possibly multiplied by other objects like coefficients, 
functions or symbols. Hence
<PRE>
    id f(p?) = p.p;
</PRE>
would match <code>f(q)</code>, <code>f(2*q-r)</code> and <code>f(a*q+f(x)*r)</code>, if p, q 
and r are vectors, and a and x are symbols, and f is a function. It would 
not match <code>f(x)</code> and neither would it match <code>f(q*r)</code>, nor 
<code>f(a*q+x)</code>.

<P>
Wildcard<A NAME="2755"></A> symbols are the most flexible objects. They 
can match symbols, numbers and expressions that do not contain loose 
indices or vectors without indices. These last objects are called 
scalar<A NAME="2756"></A> objects. Hence wildcard symbols can match all 
scalar objects. In
<PRE>
    id x^n? = x^(n+1)/(n+1);
</PRE>
the wildcard symbol n would normally match a numerical integer power. In
<PRE>
    id f(x?) = x^2;
</PRE>
there would be a match with <code>f(y)</code>, with <code>f(1+2*y)</code> and with 
<code>f(p.p)</code>, but there would not be a match with <code>f(p)</code> if p is a 
vector.

<P>
There is one extra type of wildcards. This type is rather special. It 
refers to groups of function
arguments<A NAME="2761"></A><A NAME="2762"></A>. 
The number of arguments is not specified. These variables are indicated by 
a question mark followed by a name (just the opposite of the other wildcard 
variables), and in the right hand side they are also written with the 
leading question mark:
<PRE>
    id f(?name) = g(1,?name);
</PRE>
In this statement<A NAME="2765"></A> all occurrences of f with any number of 
arguments (including no arguments) will match. Hence <code>f(mu,nu)</code> will 
be replaced by <code>g(1,mu,nu)</code>. In the case that f is a regular function 
and g is a tensor, it is conceivable that the arguments in <code>?name</code> 
will not fit inside a tensor. For instance <code>f(x)</code>, with x a symbol, 
would match and FORM would try to put the symbol inside the tensor g. This 
would result in a runtime error. In general FORM will only accept arguments 
that are indices or single vectors for a substitution into a tensor. The 
object <code>?name</code> is called an <B>argument field wildcard</B>.

<P>
One should realize that the use of multiple argument field wildcards can 
make the pattern matching slow.
<PRE>
    id f(?a,p1?,?b,p2?,?c,p3?,?d)*g(?e,p3?,?f,p1?,?g,p2?,?h) = ....
</PRE>
may involve considerable numbers of tries, especially when there are many 
occurrences of f and g in a term. One should be very careful with this.

<P>
A complication is the pattern matching in functions with symmetry 
properties. In principle FORM has to try all possible permutations before 
it can conclude that a match does not occur. This can become rather time 
consuming when many wildcards are involved. FORM has a number of tricks 
built in, in an attempt to speed this up, but it is clear that for many 
cases these tricks are not enough. This type of pattern matching is one of 
the weakest aspects of `artificial intelligence' in general. It is hoped 
that in future versions it can be improved. For the moment the practical 
consequence is that argument field wildcards cannot be used in symmetric 
and antisymmetric functions. If one needs to make a generic replacement in 
a symmetric function one cannot use
<PRE>
    CFunction f(symmetric),g(symmetric);
    id  f(?a) = ....;
</PRE>
but one could try something like
<PRE>
    CFunction f(symmetric),ff,g(symmetric);
    id  f(x1?,...,x5?) = ff(x1,...,x5);
    id  ff(?a) = ...;
    id  ff(?a) = f(?a);
</PRE>
if f has for instance 5 arguments. If different numbers of arguments are 
involved, one may need more than one statement here or a statement with the 
replace_<A NAME="2773"></A> function:
<PRE>
    Multiply replace_(f,ff);
</PRE>
It just shows that one should at times be a bit careful with overuse of 
(anti)symmetric functions. Cyclic functions do not have this restriction.

<P>
When there are various possibilities for a match, FORM will just take the 
first one it encounters. Because it is not fixed how FORM searches for 
matches (in future versions the order of trying may be changed without 
notice) one should try to avoid ambiguities<A NAME="2776"></A> as in
<PRE>
    id f(?a,?b) = g(?a)*h(?b);
</PRE>
Of course the current search method is fully consistent (and starts with 
all arguments in <code>?a</code> and none in <code>?b</code> etc, but a future pattern 
matcher may do it in a different order.

<P>
When two argument field wildcards in the left hand side have the same name, 
a match will only occur, when they match the same objects. Hence
<PRE>
    id f(?a,?a) = g(?a);
</PRE>
will match <code>f(a,b,a,b)</code> or just <code>f</code> (in which case <code>?a</code> will 
have zero arguments), but it will not match <code>f(b,b,b)</code>.

<P>
Sometimes it is useful when a search can be restricted to a limited set of 
objects. For this FORM knows the concept of sets<A NAME="2781"></A>. If the name of 
a set is attached after the question mark, this is an indication for FORM 
to look only for matches in which the wildcard becomes one of the members 
of the set:
<PRE>
    Symbols a,a1,a2,a3,b,c;
    Set aa:a1,a2,a3;

    id f(a?aa) = ...
</PRE>
would match <code>f(a1)</code> but not <code>f(b)</code>. Sets can also be defined 
dynamically<A NAME="2784"></A> by enclosing the elements between curly 
brackets<A NAME="2785"></A> as in:
<PRE>
    Symbols a,a1,a2,a3,b,c;

    id f(a?{a1,a2,a3}) = ...
</PRE>
Sets<A NAME="2788"></A> of symbols can contain (small integer) numbers 
as well. Similarly sets<A NAME="2789"></A> of indices can contain fixed 
indices (positive numbers less than the value of fixindex<A NAME="2790"></A> 
(see the chapter on the setup <A HREF="#setup">17</A>). This means that some sets can 
be ambiguous<A NAME="2792"></A> in their nature.

<P>
Sometimes sets<A NAME="2793"></A> can be used as some type of 
array<A NAME="2794"></A>. In the case of
<PRE>
    Symbols a,a1,a2,a3,b,c,n;
    Set aa:a1,a2,a3;

    id f(a?aa[n]) = ...
</PRE>
not only does `a' have to be an element of the set aa, but if it is an 
element of that set, n will become the number of the element that has been 
matched. Hence for <code>f(a2)</code> the wildcard a would become <code>a2</code> and 
the wildcard n would become 2. These objects can be used in the 
right-hand side. One can also use sets in the right-hand side with an index 
like the n of the previous example:
<PRE>
    Symbols a,a1,a2,a3,b1,b2,b3,c,n;
    Functions f,g1,g2,g3;
    Set aa:a1,a2,a3;
    Set bb:b1,b2,b3;
    Set gg:g1,g2,g3;

    id f(a?aa[n]) = gg[n](bb[n]);
</PRE>
which would replace <code>f(a2)</code> by <code>g2(b2)</code>. One cannot do 
arithmetic<A NAME="2799"></A> with the number of the array element. 
Constructions like <code>bb[n+1]</code> are not allowed.

<P>
There is one more mechanism by which the array nature of sets can be used. 
In the statement (declarations as before)
<PRE>
    id f(a?aa?bb) = a*f(a);
</PRE>
a will have to be an element of the set aa, but after the matching it takes 
the identity of the corresponding<A NAME="2802"></A> element of 
the set bb. Hence <code>f(a2)</code> becomes after this statement 
<code>b2*f(b2)</code>.

<P>
Wildcards can also give their value directly to
$-variables<A NAME="2803"></A><A NAME="2804"></A> (see chapter
<A HREF="#dollars">6</A> about the $-variables). If a $-variable is attached to a
wildcard (if there is a set restriction, it should be after the set) the
$-variable will obtain the same contents as the wildcard, provided a match
occurs. If there is more than one match, the last match will be in the
$-variable.
<PRE>
    id f(a?$w) = f(a);
</PRE>
will put the match of a in <code>$w</code>. Hence in the case of <code>f(a2)</code> the 
$-variable will have the value <code>a2</code>. In the case of 
<code>f(a2)*f(a3)</code> the eventual value of <code>$w</code> depends on the order in 
which FORM does the matching. This is not specified and it would not be 
a good strategy to make programs that will depend on it. A future pattern 
matcher might do it differently! But one could do things like
<PRE>
    while ( match(f(a?$w)) );
        id f($w) = ....
        id g($w) = ....
    endwhile;
</PRE>
just to make sure with which match one is working.

<P>

<H1><A ID="SECTION00700000000000000000"></A>
<A ID="dollars"></A>
<BR>
The dollar variables
</H1>

<P>
In the older versions of FORM there were two types of variables: the 
preprocessor variables<A NAME="2862"></A> and the algebraic 
variables<A NAME="2863"></A>. The preprocessor 
variables are string variables that are used by the edit features of the 
preprocessor to prepare the input for the compiler part of FORM. The 
algebraic objects are the expressions and the various algebraic variables 
like the symbols, functions, vectors etc. There existed however very few 
possibilities to communicate from the algebraic level to the decision 
taking at the preprocessor level. This has changed dramatically with 
version 3 and the introduction of the dollar 
variables<A NAME="2864"></A>.

<P>
Dollar variables are basically (little) expressions that can be used to 
store various types of information. They can be used both as preprocessor 
objects as well as algebraic objects. They can also be defined and given 
contents both by the preprocessor and during execution on a term by term 
basis. Dollar variables are kept in memory. Hence it is important not to 
make them too big, because in that case performance might suffer.

<P>
What is a legal name for a dollar variable?
Dollar variables have a name that consists of a dollar sign (<code>$</code>) 
followed by an alphabetic character and then potentially more alphanumeric 
characters. Hence <code>$a</code> and <code>$var</code> and <code>$r4t78y0</code> are legal 
names and <code>$1a</code> is not a legal name. The variables do not have to be 
declared. However FORM will complain if a dollar variable is being used, 
before it has encountered a statement or an instruction in which the 
variable has been given a value. Hence giving a variable a value counts at 
the same time as a declaration.

<P>
What can be stored in a dollar variable?

<UL>
<LI>Algebraic expressions as in <code>$var = (a+b)^2;</code>
</LI>
<LI>Individual objects like indices, numbers, symbols.
</LI>
<LI>Zero.
</LI>
<LI>Parts of a term.
</LI>
<LI>Argument<A NAME="2866"></A> fields that consist of zero, one or 
more arguments.
</LI>
</UL>
Actually, the parts of a term are treated as a complete term and hence as a 
special case of an algebraic expression. Internally they are stored 
slightly differently for speed, but at the user level this should not be 
noticeable. Actually, with the exception of the argument fields, FORM can 
convert one type into the other and will try so, depending on the use that 
is made of the specific dollar variable. In the case that a variable is 
used in a way that should not be possible (like the content of a variable 
is a symbol, but it is used in a position where an index is expected) there 
will be a runtime<A NAME="2868"></A> error<A NAME="2869"></A>.

<P>
How is a variable used?

<UL>
<LI>As a preprocessor variable<A NAME="2871"></A>. This is done 
by putting the variable between a pair of `' as in <code>`$var'</code>. In this 
case the regular print routines of FORM make a textual 
representation<A NAME="2872"></A> of 
the variable as it exists at the moment that the preprocessor encounters 
this object, and this string is then substituted by the preprocessor as if 
it were the contents of a preprocessor variable.
</LI>
<LI>Like an expression during execution time. This would be the case in 
the statement
<PRE>
    id x = y + $var;
</PRE>
in which <code>$var</code> is substituted 
in a way that is similar to the substitution of a local expression <code>F</code> 
in the statement
<PRE>
    id x = y + F;
</PRE>
except for that the dollar variable is always stored in the CPU memory.
</LI>
<LI>As an algebraic object during execution time. This could be the case 
with any value of the variable that is not an expression. An example would 
be
<PRE>
    id f(?a) = f(?a,$var);
</PRE>
in which the dollar variable contains an 
argument field.
</LI>
<LI>As an algebraic object in a delayed substitution of a pattern or a 
special statement. This may need some clarification. If we have the 
statement
<PRE>
    id f($var) = anything;
</PRE>
the compiler does not substitute 
the current value of <code>$var</code>. The reason is that <code>$var</code> could have 
a different value for each term that runs into this statement, while the 
compiler compiles the statement only once. Hence FORM will substitute the 
value of <code>$var</code> only at the moment that it will attempt the pattern 
matching. This is called delayed<A NAME="2881"></A> 
substitution<A NAME="2882"></A>. If one likes the compiler to 
substitute a value, one can basically let the preprocessor take care of 
this by typing
<PRE>
    id f(`$var') = anything;
</PRE>
A similar delayed 
substitution takes place in statements of the type <code>Trace,$var;</code>.
</LI>
</UL>

<P>
How does one give a value to a dollar variable?

<UL>
<LI>In the preprocessor. This is done with an instruction of the type 
<code>#$var = 0;</code>. This is an instruction that can run over more than one 
line. The r.h.s. can be any algebraic expression. Specifically it can 
contain dollar variables or local/global expressions. Such 
expressions are worked out during the preprocessing. Hence this variable 
acquires a value immediately.
</LI>
<LI>During execution when control reaches a statement of the form 
<code>$var = expression;</code>. Again the r.h.s. can contain any normal 
algebraic expression including dollar variables and local/global 
expressions. The r.h.s. will be evaluated and the value will be assigned to 
<code>$var</code>. In the case that <code>$var</code> had already a value, the old 
value will be deleted and the new value will be `installed'.
</LI>
<LI>During execution when the dollar variable is assigned the value of a 
wildcard as in
<PRE>
    id f(x?$var) = whatever;
</PRE>
If the function <code>f</code> 
occurs more than once in a term, <code>$var</code> will have the value of the 
last match. In the case that the value of the first match is needed one can 
use the option `once' in the id-statement as in
<PRE>
    id,once,f(x?$var) = whatever;
</PRE>
In general one can paste the dollar variable to the end of any 
wildcard description. Hence one can use <code>id f(x?{1,2,3}$var) = ...;</code> 
and
<PRE>
    id f(x?set[n?$var1]$var2) = ...;
</PRE>
</LI>
</UL>
Note the difference between <code>#$a = 0;</code> and <code>$a = 0;</code>. One CANNOT 
make a wildcard<A NAME="2894"></A> construction for dollar variables 
themselves as in <code>id f($var?) = ...;</code>

<P>
Dollar variables CANNOT have arguments as in <code>$var(2)</code> or something 
equivalent. There is however a solution at the preprocessor level for this 
by defining individual variables <code>$var1</code> to <code>$varn</code> and then 
using <code>$var`i'</code> or <code>`$var`i&rdquo;</code> for some preprocessor variable 
<code>i</code>. The exception is the indication of factors when a dollar variable 
has been factorized (see the #factdollar instruction&nbsp;<A HREF="#prefactdollar">3.29</A> 
and the factdollar statement&nbsp;<A HREF="#substafactdollar">7.55</A>). This is explained 
later in this chapter and in the chapter about 
polynomials&nbsp;<A HREF="#polynomials">11</A>.

<P>
Printing dollar<A NAME="2898"></A> variables:

<UL>
<LI>In the preprocessor one can use the <code>#write</code> instruction
        (see <A HREF="#prewrite">3.64</A>).
</LI>
<LI>During execution one can use the Print statement (see 
        <A HREF="#substaprint">7.113</A>).
</LI>
</UL>
In both cases one should use the format<A NAME="2903"></A> string. The syntax is 
described in the chapters on these statements. The format descriptor of a 
dollar variable is <code>%$</code> and this looks after the format string for the 
next dollar variable. Of course one can also use the dollar variable as a 
preprocessor variable when printing/writing in the preprocessor.

<P>
Examples.

<P>
Counting terms:
<PRE>
    S	a,b;
    Off statistics;
    L	F = (a+b)^6;
    #$a = 0;
    $a = $a+1;
    Print "      &gt;&gt; After %t we have %$ term(s)",$a;
    #write "     &gt;# $a = `$a'"
     &gt;# $a = 0
    .sort
      &gt;&gt; After  + a^6 we have 1 term(s)
      &gt;&gt; After  + 6*a^5*b we have 2 term(s)
      &gt;&gt; After  + 15*a^4*b^2 we have 3 term(s)
      &gt;&gt; After  + 20*a^3*b^3 we have 4 term(s)
      &gt;&gt; After  + 15*a^2*b^4 we have 5 term(s)
      &gt;&gt; After  + 6*a*b^5 we have 6 term(s)
      &gt;&gt; After  + b^6 we have 7 term(s)
    #write "     &gt;# $a = `$a'"
     &gt;# $a = 7
    .end
</PRE>

<P>
Maximum power of x in an expression:
<PRE>
    S	x,a,b;
    Off statistics;
    L	F = (a+b)^4+a*(a+x)^3;
    .sort
    #$a = 0;
    if ( count(x,1) &gt; $a ) $a = count_(x,1);
    Print "      &gt;&gt; After %t the maximum power of x is %$",$a;
    #write "     &gt;# $a = `$a'"
     &gt;# $a = 0
    .sort
      &gt;&gt; After  + 3*x*a^3 the maximum power of x is 1
      &gt;&gt; After  + 3*x^2*a^2 the maximum power of x is 2
      &gt;&gt; After  + x^3*a the maximum power of x is 3
      &gt;&gt; After  + 4*a*b^3 the maximum power of x is 3
      &gt;&gt; After  + 6*a^2*b^2 the maximum power of x is 3
      &gt;&gt; After  + 4*a^3*b the maximum power of x is 3
      &gt;&gt; After  + 2*a^4 the maximum power of x is 3
      &gt;&gt; After  + b^4 the maximum power of x is 3
    #write "     &gt;# $a = `$a'"
     &gt;# $a = 3
    .end
</PRE>

<P>
Starting with version 4, FORM has the capability to factorize polynomials 
(see the chapter on polynomials&nbsp;<A HREF="#polynomials">11</A>). One type of objects 
that can be factorized is the dollar variables. The immediate question here 
is how to access the factors. As we mentioned before in this chapter, 
normally there is no direct way to use arguments for dollar variables. For 
the factors however we have a way of indexing the dollar variables as in 
<code>$var[1]</code>,...,<code>$var[n]</code> when there are n factors. The number of 
factors can be obtained as <code>$var[0]</code>. In the index field can only be 
(nonnegative integer) numbers, dollar variables or factors of dollar 
variables that evaluate into (nonnegative integer) numbers.
<PRE>
    Symbol x,y;
    CFunction f1,f2;
    Local F = f1(x^2+2*x*y+y^2)+f1(x^4-y^4);
    id  f1(x?$x) = f2(x);
    FactDollar,$x;
    Do $i = 1,$x[0];
      Print "In %t factor %$ is %$",$i,$x[$i];
    Enddo;
    .end
In  + f2(y^2 + 2*x*y + x^2) factor 1 is y + x
In  + f2(y^2 + 2*x*y + x^2) factor 2 is y + x
In  + f2( - y^4 + x^4) factor 1 is  - 1
In  + f2( - y^4 + x^4) factor 2 is y - x
In  + f2( - y^4 + x^4) factor 3 is y + x
In  + f2( - y^4 + x^4) factor 4 is y^2 + x^2
</PRE>

<P>
One thing to note is that the use of
<PRE>
     f(&lt;$x[1]&gt;,...,&lt;$x[$x[0]]&gt;)
</PRE>
is illegal. <code>$x[0]</code> will be inserted during execution time, while the 
expansion of the triple dot operator is done by the preprocessor. Hence we 
should use <code>`$x[0]'</code> but then <code>$x</code> must be known and factorized 
already at compile time.

<P>

<H1><A ID="SECTION00710000000000000000"></A>
<A ID="pardollars"></A>
<BR>
Dollar variables in a parallel environment
</H1>

<P>
When FORM is used for parallel<A NAME="2915"></A> processing, 
either by means of P<SMALL>AR</SMALL>FORM<A NAME="2916"></A> or by means of 
TFORM<A NAME="2917"></A>, there can be a problem with the dollar variables as in 
principle there is a central administration and dollar variables that are 
defined during running will in general have the last assigned value. In a 
parallel environment this can be nondeterministic<A NAME="2918"></A>. 
Look for instance at the following example:
<PRE>
    S   x,a,b;
    CF  f;
    L   F = f(a+b) + f(a+2*b);
    .sort
    id  f(x?$x) = f(x);
    Multiply,$x;
    Print;
    .end
</PRE>
Usually this program will give the 'correct' answer, but in principle one 
thread could define <code>$x</code> and then the next thread could overwrite this 
value before the first thread has used it. This is serious. Hence FORM 
will veto<A NAME="2921"></A> the use of multiple threads/processors for modules in 
which dollar variables obtain values during the execution of the program, 
unless the user can give FORM more information about the use of the 
dollar variables. In the above case the value of <code>$x</code> will be local to 
each term and hence to each thread<A NAME="2922"></A>. The value in previous 
terms is unimportant. We can tell this to FORM with a variety of the 
moduleoption<A NAME="2923"></A> statement (see <A HREF="#substamoduleoption">7.89</A>). 
This would be:
<PRE>
    S   x,a,b;
    CF  f;
    L   F = f(a+b) + f(a+2*b);
    .sort
    id  f(x?$x) = f(x);
    Multiply,$x;
    Print;
    ModuleOption,local,$x;
    .end
</PRE>
In this case FORM makes at the start of the execution of the module a 
copy of whatever value <code>$x</code> has at that moment for each 
thread/processor (in this case no value yet and hence it gets set to zero) 
and then each thread/processor uses its own copy during execution. After 
the module has been completed the local copies are removed and the original 
global value is accessible again. This way execution will be safe in a 
parallel environment.

<P>
There are more cases that FORM can handle in a parallel environment. 
These are also options in the moduleoption statement:
<PRE>
    ModuleOption,maximum,$a;
    ModuleOption,minimum,$b;
    ModuleOption,sum,$c;
</PRE>
Here we say that <code>$a</code> is accumulating a maximum numerical value, 
<code>$b</code> collects a minimum numerical value and <code>$c</code> is a numerical 
sum. In all three cases there is a central administration and the use of 
the variables has to be blocked for other threads/processors during the 
updating of the values. Sometimes that can be efficient, but in other 
programs that may actually make them slower. One should experiment. A 
sample program is given below:
<PRE>
    S   a1,...,a10;
    L   F = (a1+...+a10)^3;
    .sort
    #$c = 0;
    Print +f "&lt;%w&gt; %t";
    Multiply,(a1+...+a10);
    $c = $c+1;
    ModuleOption,sum,$c;
    .sort
    #message $c = `$c'
    #$max = 0;
    #$min = 10;
    if ( count(a1,1) &gt; $max ) $max = count_(a1,1);
    if ( count(a4,1) &lt; $min ) $min = count_(a4,1);
    ModuleOption,maximum,$max;
    ModuleOption,minimum,$min;
    .sort
    #message $max = `$max'
    #message $min = `$min'
    .end
</PRE>
The print statement is showing which thread is dealing with which term.

<P>

<H1><A ID="SECTION00800000000000000000"></A>
<A ID="statements"></A>
<BR>
Statements
</H1>

<P>

<H1><A ID="SECTION00810000000000000000"></A>
<A ID="substaabrackets"></A>
<BR>
abrackets, antibrackets
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Output control statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">ab[rackets][+][-] <SPAN style="font-family:monospace">&lt;</SPAN>list of names<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">antib[rackets][+][-] <SPAN style="font-family:monospace">&lt;</SPAN>list of names<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">bracket (<A HREF="#substabracket">7.11</A>) and the chapter on brackets 
     (<A HREF="#brackets">9</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
This statement<A NAME="2994"></A><A NAME="2995"></A> does the opposite of 
the bracket statement (see <A HREF="#substabracket">7.11</A>). In the bracket statement 
the variables that are mentioned are placed outside brackets and inside the 
brackets are all other objects. In the antibracket statement the variables 
in the list are the only objects that are not placed outside the brackets. 
For the rest of the syntax, see the bracket statement (section 
<A HREF="#substabracket">7.11</A>).
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION00820000000000000000"></A>
<A ID="substaalso"></A>
<BR>
also
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable Statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">a[lso] [options] <SPAN style="font-family:monospace">&lt;</SPAN>pattern<SPAN style="font-family:monospace">&gt;</SPAN> = 
         <SPAN style="font-family:monospace">&lt;</SPAN>expression<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">identify (<A HREF="#substaidentify">7.68</A>), idold (<A HREF="#substaidold">7.70</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
The also<A NAME="3011"></A> statement should follow either an 
id<A NAME="3012"></A> statement or another also statement. The action is that the 
pattern matching in the also statement takes place immediately after the 
pattern matching of the previous id statement (or also statement) and after 
possible matching patterns have been removed, but before the r.h.s. 
expressions are inserted. It is identical to the idold statement (see 
<A HREF="#substaidold">7.70</A>). Example:
<PRE>
    id    x = cosphi*x-sinphi*y;
    also  y = sinphi*x+cosphi*y;
</PRE>

<P>
The options are explained in the section on the id statement (see 
<A HREF="#substaidentify">7.68</A>). <BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION00830000000000000000"></A>
<A ID="substaantiputinside"></A>
<BR>
antiputinside
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">antiputinside <SPAN style="font-family:monospace">&lt;</SPAN>name of function<SPAN style="font-family:monospace">&gt;</SPAN> [,<SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img23.svg"
 ALT="$&lt;$"></SPAN>antibracket information<SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img24.svg"
 ALT="$&gt;$"></SPAN>];</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">PutInside (<A HREF="#substaputinside">7.119</A>)</TD>
</TR>
</TABLE>
<BR>
<BR>

<P>
This statement<A NAME="3027"></A> puts all parts of the term 
with the exception of the variables in the antibracket information inside a 
function argument. The function must be a regular function (hence no tensor 
or table which are special types of functions). The 
antibracket<A NAME="3028"></A> information should adhere to the syntax of 
the bracket statement (<A HREF="#substabracket">7.11</A>, <A HREF="#substaabrackets">7.1</A>) and all 
occurrences of all variables with the exception of the antibracket 
variables will be put inside the function. The coefficient will also be put 
inside the function.
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION00840000000000000000"></A>
<A ID="substaantisymmetrize"></A>
<BR>
antisymmetrize
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">an[tisymmetrize] <code>{</code><SPAN style="font-family:monospace">&lt;</SPAN>name of function/tensor<SPAN style="font-family:monospace">&gt;</SPAN>
         [<SPAN style="font-family:monospace">&lt;</SPAN>argument specifications<SPAN style="font-family:monospace">&gt;</SPAN>];<code>}</code></TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">symmetrize (<A HREF="#substasymmetrize">7.141</A>), cyclesymmetrize 
(<A HREF="#substacyclesymmetrize">7.28</A>), rcyclesymmetrize (<A HREF="#substarcyclesymmetrize">7.121</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
The argument specifications are explained in the section on the 
symmetrize statements (see <A HREF="#substasymmetrize">7.141</A>).
<P>
<BR>

<P>
The action of this statement<A NAME="3046"></A> is to 
anti-symmetrize the (specified) arguments of the functions that are 
mentioned. This means that the arguments are brought to `natural order' in 
the notation of FORM and each exchange of arguments or groups of arguments 
results in a minus sign in the coefficient of the term. The `natural order' 
may depend on the order of declaration of the variables. If two arguments 
or groups of arguments that are part in the anti-symmetrization are 
identical, the function is replaced by zero. <BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION00850000000000000000"></A>
<A ID="substaapply"></A>
<BR>
apply
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">apply ["<SPAN style="font-family:monospace">&lt;</SPAN>tablename(s)<SPAN style="font-family:monospace">&gt;</SPAN>"];</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">tablebases (<A HREF="#tablebase">12</A>), apply (<A HREF="#tblapply">12.2</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
This statement<A NAME="3058"></A> is explained in the chapter on 
tablebases.
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION00860000000000000000"></A>
<A ID="substaargexplode"></A>
<BR>
argexplode
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">argexplode [<SPAN style="font-family:monospace">&lt;</SPAN>list of functions<SPAN style="font-family:monospace">&gt;</SPAN>]</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">argimplode (<A HREF="#substaargimplode">7.7</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
See the description of the ArgImplode&nbsp;<A HREF="#substaargimplode">7.7</A> 
statement.
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION00870000000000000000"></A>
<A ID="substaargimplode"></A>
<BR>
argimplode
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">argimplode [<SPAN style="font-family:monospace">&lt;</SPAN>list of functions<SPAN style="font-family:monospace">&gt;</SPAN>]</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">argexplode (<A HREF="#substaargexplode">7.6</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
This is a rather specialized statement. It converts one notation 
of indices, used for harmonic sums<A NAME="3080"></A><A NAME="3081"></A>, harmonic 
polylogarithms<A NAME="3082"></A><A NAME="3083"></A> and multiple zeta values<A NAME="3084"></A> into 
its alternative notation. The two notations are:
<PRE>
   Z(0,0,0,1,0,0,-1)
   Z(4,-3)
</PRE>
In the first notation the indices can only be 0, 1 and -1. In the second 
notation there can be no zeroes. The `ArgImplode,Z;' 
statement<A NAME="3087"></A> would be 
equivalent to the statement
<PRE>
   repeat id Z(?a,0,x?!{0,0},?b) = Z(?a,x+sig_(x),?b);
</PRE>
and takes one from the first notation to the second. The `ArgExplode,Z;' 
statement<A NAME="3090"></A> is equivalent to the statement
<PRE>
   repeat id Z(?a,x?!{1,0,-1},?b) = Z(?a,0,x-sig_(x),?b);
</PRE>
and takes one from the second notation to the first. The reason that these 
statements have been built in lies in the fact that for many indices the 
repeat statements started to become very time-consuming.

<P>
For the harmonic sums, the harmonic polylogarithms and the 
multiple zeta values one can use the summer6 and the harmpol packages in 
the FORM distribution. They are described in the papers

<P>
J.&nbsp;A.&nbsp;M. Vermaseren, <I>Harmonic sums, Mellin transforms and integrals</I>,
  <EM>Int. J. Mod. Phys.</EM> <B>A14</B> (1999) 2037,
  http://arxiv.org/abs/hep-ph/9806280.

<P>
E.&nbsp;Remiddi and J.&nbsp;A.&nbsp;M. Vermaseren, <I>Harmonic polylogarithms</I>,  <EM>Int. J. Mod. Phys.</EM> <B>A15</B> (2000) 725,
  http://arxiv.org/abs/hep-ph/9905237.
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION00880000000000000000"></A>
<A ID="substaargtoextrasymbol"></A>
<BR>
argtoextrasymbol
</H1>

<P>

<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">argtoextrasymbol [tonumber] [<SPAN style="font-family:monospace">&lt;</SPAN>argument specifications<SPAN style="font-family:monospace">&gt;</SPAN>];</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">topolynomial (<A HREF="#substatopolynomial">7.148</A>) and
  extrasymbols (<A HREF="#substaextrasymbols">7.53</A>, <A HREF="#sect-extrasymbols">2.11</A>).</TD>
</TR>
</TABLE>
<BR>
<BR>

<P>
Converts function arguments into extra symbols. 
An argument will be replaced with an extra symbol. 
The arguments that have been encountered before are replaced with the same 
extra symbols. 
Unlike the <SPAN  CLASS="texttt">topolynomial</SPAN> statement (<A HREF="#substatopolynomial">7.148</A>), the 
replacement occurs even for arguments consisting only of numbers and symbols 
(including extra symbols). 
<BR>
<BR>

<P>
The <SPAN  CLASS="texttt">tonumber</SPAN> option requests that function arguments are converted to 
positive integers corresponding to extra symbols. This provides an efficient 
mapping from any expression (stored as a function argument) to a number. 
<BR>
<BR>

<P>
The function arguments to be converted can be specified in the same way as the 
<SPAN  CLASS="texttt">argument</SPAN> statement (see <A HREF="#substaargument">7.9</A>). 
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION00890000000000000000"></A>
<A ID="substaargument"></A>
<BR>
argument
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">argument [<SPAN style="font-family:monospace">&lt;</SPAN>argument specifications<SPAN style="font-family:monospace">&gt;</SPAN>]</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT"><code>{</code><SPAN style="font-family:monospace">&lt;</SPAN>name of function/set<SPAN style="font-family:monospace">&gt;</SPAN>
[<SPAN style="font-family:monospace">&lt;</SPAN>argument specifications<SPAN style="font-family:monospace">&gt;</SPAN>]<code>}</code>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">endargument (<A HREF="#substaendargument">7.43</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
This statement starts an argument<A NAME="3132"></A> 
environment<A NAME="3133"></A>. Such an environment is terminated 
by an endargument statement (see <A HREF="#substaendargument">7.43</A>). The statements 
between the argument and the endargument<A NAME="3135"></A> statements will 
be applied only to the function arguments as specified by the remaining 
information in the argument statement. This information is given by:

<UL>
<LI>No further information: the statements are applied to all arguments 
of all functions.
</LI>
<LI>A series of numbers: the statements are applied to the given 
arguments of all functions.
</LI>
<LI>A function name (or a set of functions), possibly followed by a 
series of numbers: the statements are applied to the numbered arguments of 
the function specified. If a set of functions was specified, all the 
functions in the set will be taken. If no numbers are specified, all 
arguments of the function (or elements of the set) are taken.
</LI>
</UL>
The combination of a function (or set) possibly followed by numbers of 
arguments, can occur as many times as needed. The generic numbers of 
arguments that refer to all functions work in addition to the numbers 
specified for individual functions. Example
<BR>
<PRE>
   Argument 2,f,1,{f,f1},3,4;
</PRE>
This specifies the second argument of all functions. In addition the first 
argument of <code>f</code> will be taken and then also the third and fourth 
arguments of <code>f</code> and <code>f1</code> will be taken. <BR>
<BR>

<P>
Argument/endargument constructions can be nested. <BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008100000000000000000"></A>
<A ID="substaautodeclare"></A>
<BR>
auto, autodeclare
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Declaration statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">autodeclare <SPAN style="font-family:monospace">&lt;</SPAN>variable type<SPAN style="font-family:monospace">&gt;</SPAN> <SPAN style="font-family:monospace">&lt;</SPAN>list of variables to be declared<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">auto <SPAN style="font-family:monospace">&lt;</SPAN>variable type<SPAN style="font-family:monospace">&gt;</SPAN> <SPAN style="font-family:monospace">&lt;</SPAN>list of variables to be declared<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
The variable<A NAME="3157"></A><A NAME="3158"></A> types are 
<BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>s[ymbol]
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>Declaration of symbols<A NAME="7473"></A>. For options see <A HREF="#substasymbols">7.140</A>.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>v[ector]
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>Declaration of vectors<A NAME="7487"></A>. For options see <A HREF="#substavectors">7.159</A>.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>i[ndex]
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>Declaration of indices<A NAME="7501"></A>. For options see <A HREF="#substaindex">7.74</A>.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>i[ndices]
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>Declaration of indices<A NAME="7515"></A>. For options see <A HREF="#substaindex">7.74</A>.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>f[unctions]
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>Declaration of noncommuting<A NAME="7529"></A> 
functions<A NAME="7530"></A>. For options see 
<A HREF="#substanfunctions">7.95</A>.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>nf[unctions]
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>Declaration of noncommuting functions. For options see 
<A HREF="#substanfunctions">7.95</A>.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>cf[unctions]
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>Declaration of commuting<A NAME="7557"></A> 
functions<A NAME="7558"></A>. For options see 
<A HREF="#substacfunctions">7.14</A>.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>co[mmuting]
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>Declaration of commuting functions. For options see 
<A HREF="#substacfunctions">7.14</A>.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>t[ensors]
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>Declaration of commuting tensors<A NAME="7585"></A>. For options see 
<A HREF="#substatensors">7.144</A>.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>nt[ensors]
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>Declaration of noncommuting tensors<A NAME="7599"></A>. For options see 
<A HREF="#substantensors">7.102</A>.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>ct[ensors]
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>Declaration of commuting tensors<A NAME="7613"></A>. For options see 
<A HREF="#substactensors">7.27</A>.</TD></TR>
</TABLE>
    <BR>

<P>
The action of the autodeclare statement is to set a default for 
variable types. In a statement of the type
<PRE>
   AutoDeclare Symbol a,bc,def;
</PRE>
all undeclared variables of which the name starts with the character a, the 
string bc or the string def will be interpreted as symbols and entered in 
the name tables as such. In the case there are two statements as in
<PRE>
   AutoDeclare CFunction b,d;
   AutoDeclare Symbol a,bc,def;
</PRE>
all previously undeclared variables of which the name starts with a, bc or 
def will be declared as symbols. All other previously undeclared variables 
of which the name starts with a b or a d will be declared as commuting 
functions. This is independent of the order of the autodeclare statements. 
FORM starts looking for the most detailed matches 
first. Hence the variable defi will match with the string def first.
<BR>
<BR>

<P>
It is also allowed to use the properties of the various variables 
in the autodeclare statement:
<PRE>
   AutoDeclare Index i=4,i3=3,i5=5;
</PRE>
This declares all previously undeclared variables of which the name starts 
with an i to be four dimensional indices, unless their names start with i3 in 
which case they will be three dimensional indices, or their names start 
with i5 in which case they will be five dimensional indices. <BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008110000000000000000"></A>
<A ID="substabracket"></A>
<BR>
bracket
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Output control statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">b[rackets][+][-] <SPAN style="font-family:monospace">&lt;</SPAN>list of names<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">antibracket (<A HREF="#substaabrackets">7.1</A>), keep (<A HREF="#substakeep">7.80</A>),
    collect(<A HREF="#substacollect">7.19</A>) and the chapter on brackets 
     (<A HREF="#brackets">9</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
This statement causes the output to be reorganized in such a way 
that all objects in the `list of names' are placed outside 
brackets<A NAME="3214"></A> and all remaining objects inside 
brackets<A NAME="3215"></A>. This grouping will remain till the next time that 
the expression is active and is being manipulated. Hence the brackets can 
survive skip (see <A HREF="#substaskip">7.132</A>), hide (see <A HREF="#substahide">7.67</A>) and even 
save (see <A HREF="#substasave">7.127</A>) and load (see <A HREF="#substaload">7.83</A>) statements. The 
bracket information can be used by the collect (see <A HREF="#substacollect">7.19</A>) 
and keep (see <A HREF="#substakeep">7.80</A>) statements, as well in r.h.s. expressions 
when the contents of individual brackets of an expression can be picked up 
(see <A HREF="#brackets">9</A>). <BR>
<BR>

<P>
The list of names can contain names of symbols, vectors, 
functions, tensors and sets. In addition it can contain dotproducts. There 
should be only one bracket or antibracket (see <A HREF="#substaabrackets">7.1</A>) 
statement in each module. If there is more than one, only the last one has 
an effect. The presence of a set has the same effect as having all the 
symbolic elements of the set declared in the (anti)bracket 
statement.
<BR>
<BR>

<P>
The presence of a <SPAN CLASS="MATH"><IMG STYLE="height: 1.75ex; vertical-align: -0.30ex; " SRC="img7.svg"
 ALT="$+$"></SPAN> or <SPAN CLASS="MATH"><IMG STYLE="height: 1.75ex; vertical-align: -0.30ex; " SRC="img6.svg"
 ALT="$-$"></SPAN> after the bracket (or anti bracket) 
refers to potential indexing of the brackets<A NAME="3226"></A>. 
Usually FORM has the information inside the terms in an expression. If 
it needs to search for a particular bracket it does so by starting at the 
beginning of that expression. This can be slow. If one likes to access 
individual brackets, it may be faster to tell FORM to make an index by 
putting the <SPAN CLASS="MATH"><IMG STYLE="height: 1.75ex; vertical-align: -0.30ex; " SRC="img7.svg"
 ALT="$+$"></SPAN> after the bracket or antibracket keyword. For more 
information, see the chapter on brackets (see <A HREF="#brackets">9</A>). A <SPAN CLASS="MATH"><IMG STYLE="height: 1.75ex; vertical-align: -0.30ex; " SRC="img6.svg"
 ALT="$-$"></SPAN> 
indicates that no index should be made. Currently this is the default and 
hence there is no need to use this option. It is present just in case the 
default might be changed in a future version of FORM (in which FORM 
might for instance try to determine by itself what seems best. This option 
exists for case that the user would like to overrule such a mechanism). 
<BR>
<BR>

<P>
See also the antibracket statement in <A HREF="#substaabrackets">7.1</A>.
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008120000000000000000"></A>
<A ID="substabreak"></A>
<BR>
break
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">break;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">case (<A HREF="#substacase">7.13</A>), switch (<A HREF="#substaswitch">7.139</A>),
		 default(<A HREF="#substadefault">7.30</A>), endswitch (<A HREF="#substaendswitch">7.49</A>).</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
When a break statement is reached in a switch construction the 
next statement to be executed is the first statement after the 
corresponding endswitch statement.

<P>
<BR>
<BR>
<BR>

<H1><A ID="SECTION008130000000000000000"></A>
<A ID="substacase"></A>
<BR>
case
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">case,number;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">switch (<A HREF="#substaswitch">7.139</A>), break (<A HREF="#substabreak">7.12</A>),
		 default(<A HREF="#substadefault">7.30</A>), endswitch (<A HREF="#substaendswitch">7.49</A>).</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
The cases in a switch construction are marked by a number. This 
number must be an interger that can be represented inside a FORM word. 
On a 64-bit processor this would be an integer in the range <SPAN CLASS="MATH"><IMG STYLE="height: 2.33ex; vertical-align: -0.30ex; " SRC="img19.svg"
 ALT="$-2^{31}$"></SPAN> to 
<SPAN CLASS="MATH"><IMG STYLE="height: 2.33ex; vertical-align: -0.30ex; " SRC="img18.svg"
 ALT="$2^{31}-1$"></SPAN>. If the dollar variable in the switch statement has the same 
value as the integer in the case statement, the next statement to be 
executed is the first statement after the case statement. Usually cases are 
terminated by break statements, but if there is no break statement 'fall 
through' may occur in which execution continues with the first statement 
after the next case statement or default statement.

<P>
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008140000000000000000"></A>
<A ID="substacfunctions"></A>
<BR>
cfunctions
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Declaration statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">c[functions] <SPAN style="font-family:monospace">&lt;</SPAN>list of functions to be declared<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">functions (<A HREF="#substafunctions">7.62</A>), nfunctions (<A HREF="#substanfunctions">7.95</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
This statement declares commuting<A NAME="3270"></A> 
functions<A NAME="3271"></A>. The name of a 
function can be followed by some information that specifies additional 
properties of the preceding function. These can be (name indicates the 
name of the function to be declared): <BR>
<BR>

<P>
<TABLE   STYLE="width:186;">
<TR><TD>name#r
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>The function is considered to be a real<A NAME="7635"></A> function (default).</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:186;">
<TR><TD>name#c
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>The function is considered to be a complex<A NAME="7650"></A> function. This means 
that internally two spaces are reserved. One for the variable name and one 
for its complex conjugate name#.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:186;">
<TR><TD>name#i
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>The function is considered to be imaginary<A NAME="7667"></A>.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:186;">
<TR><TD>name(s[ymmetric])
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>The function is totally symmetric<A NAME="7680"></A>. This means that during 
normalization FORM will order the arguments according to its internal 
notion of order by trying permutations. The result will depend on the order 
of declaration of variables.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:186;">
<TR><TD>name(a[ntisymmetric])
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>The function is totally antisymmetric<A NAME="7695"></A>. This means that 
during normalization FORM will order the arguments according to its 
internal notion of order and if the resulting permutation of arguments is 
odd the coefficient of the term will change sign. The order will depend on 
the order of declaration of variables.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:186;">
<TR><TD>name(c[yclesymmetric])
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>The function is cycle<A NAME="7710"></A> symmetric in 
all its arguments. This means that during normalization FORM will order 
the arguments according to its internal notion of order by trying cyclic 
permutations. The result will depend on the order of declaration of 
variables.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:186;">
<TR><TD>name(r[cyclesymmetric)

<P>
name(r[cyclic])

<P>
name(r[eversecyclic])
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>The function is reverse<A NAME="7725"></A> 
cycle symmetric in all its arguments. This means that during normalization 
FORM will order the arguments according to its internal notion of order 
by trying cyclic permutations and/or a complete reverse order of all 
arguments. The result will depend on the order of declaration of 
variables.</TD></TR>
</TABLE>
    <BR>

<P>
The complexity properties and the symmetric properties can be 
combined. In that case the complexity properties should come first as in
<PRE>
    CFunction f1#i(antisymmetric);
</PRE>
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008150000000000000000"></A>
<A ID="substachainin"></A>
<BR>
chainin
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">Chainin,name of function;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">chainout (<A HREF="#substachainout">7.16</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
Has<A NAME="3316"></A> the same effect as the statement
<PRE>
   repeat id f(?a)*f(?b) = f(?a,?b);
</PRE>
if f is the name of the function specified. The chainin statement is just a 
faster shortcut. <BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008160000000000000000"></A>
<A ID="substachainout"></A>
<BR>
chainout
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">Chainout,name of function;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">chainin (<A HREF="#substachainin">7.15</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
Has<A NAME="3327"></A> the same effect as the statement
<PRE>
   repeat id f(x1?,x2?,?a) = f(x1)*f(x2,?a);
</PRE>
if f is the name of the function specified. The chainout statement is just a 
much faster shortcut. <BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008170000000000000000"></A>
<A ID="substachisholm"></A>
<BR>
chisholm
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">chisholm [options] <SPAN style="font-family:monospace">&lt;</SPAN>spinline indices<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">trace4 (<A HREF="#substatrace">7.152</A>) and the chapter on gamma algebra 
(<A HREF="#gammaalgebra">14</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
This statement<A NAME="3341"></A> applies the identity
<BR>
<DIV ALIGN="CENTER">

<!-- MATH
 \begin{eqnarray}
\gamma_a\gamma_\mu\gamma_b {\rm Tr}[\gamma_\mu S] & = &
         2\gamma_a( S + S^R ) \gamma_b  \nonumber
\end{eqnarray}
 -->
<TABLE CELLPADDING="0" ALIGN="CENTER" WIDTH="100%">
<TR VALIGN="MIDDLE"><TD NOWRAP ALIGN="RIGHT"><IMG STYLE="height: 2.62ex; vertical-align: -0.78ex; " SRC="img41.svg"
 ALT="$\displaystyle \gamma_a\gamma_\mu\gamma_b {\rm Tr}[\gamma_\mu S]$"></TD>
<TD ALIGN="CENTER" NOWRAP><IMG STYLE="height: 1.06ex; vertical-align: -0.11ex; " SRC="img42.svg"
 ALT="$\textstyle =$"></TD>
<TD ALIGN="LEFT" NOWRAP><IMG STYLE="height: 2.90ex; vertical-align: -0.69ex; " SRC="img43.svg"
 ALT="$\displaystyle 2\gamma_a( S + S^R ) \gamma_b$"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
&nbsp;</TD></TR>
</TABLE></DIV>
<BR CLEAR="ALL"><P></P>
in order to contract traces. <SPAN CLASS="MATH"><IMG STYLE="height: 1.79ex; vertical-align: -0.11ex; " SRC="img44.svg"
 ALT="$S$"></SPAN> is here a string of
gamma<A NAME="3346"></A> matrices and <SPAN CLASS="MATH"><IMG STYLE="height: 2.21ex; vertical-align: -0.11ex; " SRC="img45.svg"
 ALT="$S^R$"></SPAN> is the reverse string. This 
identity is particularly useful when the matrices <!-- MATH
 $\gamma_6 = 1+\gamma_5$
 -->
<SPAN CLASS="MATH"><IMG STYLE="height: 2.15ex; vertical-align: -0.56ex; " SRC="img46.svg"
 ALT="$\gamma_6 = 1+\gamma_5$"></SPAN> 
and/or <!-- MATH
 $\gamma_7 = 1-\gamma_5$
 -->
<SPAN CLASS="MATH"><IMG STYLE="height: 2.15ex; vertical-align: -0.56ex; " SRC="img47.svg"
 ALT="$\gamma_7 = 1-\gamma_5$"></SPAN> are involved. The spinline<A NAME="3347"></A> index refers to 
which trace should be eliminated this way. The options are <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>symmetrize
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>If there is more than one contraction with other gamma matrices, 
the answer will be the sum of the various contractions, divided by the 
number of different contractions. This will often result in a minimization 
of the number of <SPAN CLASS="MATH"><IMG STYLE="height: 1.66ex; vertical-align: -0.56ex; " SRC="img48.svg"
 ALT="$\gamma_5$"></SPAN> matrices left in the final results.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>nosymmetrize
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>The first contraction encountered will be taken. No attempt is 
made to optimize with respect to the number of <SPAN CLASS="MATH"><IMG STYLE="height: 1.66ex; vertical-align: -0.56ex; " SRC="img48.svg"
 ALT="$\gamma_5$"></SPAN> matrices left.</TD></TR>
</TABLE>
    <BR>

<P>
IMPORTANT: the above identity is only valid in 4 dimensions. For 
more details, see chapter <A HREF="#gammaalgebra">14</A> on gamma<A NAME="3354"></A> algebra. <BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008180000000000000000"></A>
<A ID="substacleartable"></A>
<BR>
cleartable
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Declaration statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">ClearTable [<SPAN style="font-family:monospace">&lt;</SPAN>list of tables<SPAN style="font-family:monospace">&gt;</SPAN>]</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
This statement clears the tables that are mentioned. Sometimes 
(sparse) tables can take so much space that there is no room for new 
elements, while old elements are not needed any longer. In that case one 
can clear the table and start all over again with filling it. It is also 
useful when one wants to reuse a table, but now with a different content.
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008190000000000000000"></A>
<A ID="substacollect"></A>
<BR>
collect
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Specification statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">collect <SPAN style="font-family:monospace">&lt;</SPAN>name of function<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">collect <SPAN style="font-family:monospace">&lt;</SPAN>name of function<SPAN style="font-family:monospace">&gt;</SPAN> 
        <SPAN style="font-family:monospace">&lt;</SPAN>name of other function<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">collect <SPAN style="font-family:monospace">&lt;</SPAN>name of function<SPAN style="font-family:monospace">&gt;</SPAN> 
        <SPAN style="font-family:monospace">&lt;</SPAN>name of other function<SPAN style="font-family:monospace">&gt;</SPAN> <SPAN style="font-family:monospace">&lt;</SPAN>percentage<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">bracket (<A HREF="#substabracket">7.11</A>), antibracket 
     (<A HREF="#substaabrackets">7.1</A>) and the chapter on brackets 
     (<A HREF="#brackets">9</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
Upon processing<A NAME="3386"></A> the expressions (hence expressions 
in hide as well as skipped expressions do not take part in this) the 
contents of the brackets<A NAME="3387"></A> (if there was a bracket or 
antibracket<A NAME="3388"></A> statement in the preceding module) are 
collected and put inside the argument of the named function. Hence if the 
expression <code>F</code> is given by
<PRE>
   F =
      a*(b^2+c)
    + a^2*(b+6)
    + b^3 + c*b + 12;
</PRE>
the statement
<PRE>
   Collect cfun;
</PRE>
will change <code>F</code> into
<PRE>
   F = a*cfun(b^2+c)+a^2*cfun(b+6)+cfun(b^3+c*b+12);
</PRE>
The major complication<A NAME="3395"></A> occurs if the content of a 
bracket is so long that it will not fit inside a single term. The maximum 
size of a term is limited by the setup parameter 
maxtermsize<A NAME="3396"></A> (see <A HREF="#setupmaxtermsize">17</A>). If this size 
is exceeded, FORM will split the bracket contents over more than one term, 
in each of which it will be inside the named function. It will issue a 
warning that it has done so. <BR>
<BR>

<P>
If a second function is specified (the 
alternative<A NAME="3400"></A> collect function) and if a bracket takes 
more space than can be put inside a single term, the bracket contents will 
be split over more than one term, in each of which it will be inside the 
alternative collect function. In this case there is no need for a 
warning<A NAME="3401"></A> 
as the user can easily check whether this has occurred by checking whether 
the alternative function is present in the expression. <BR>
<BR>

<P>
If additionally a percentage<A NAME="3403"></A> is specified (an 
integer in the range of 1 to 99) this determines how big the argument must 
be as compared to MaxTermSize (see chapter <A HREF="#setup">17</A> on the setup) before 
use is made of the alternate collect function. <BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008200000000000000000"></A>
<A ID="substacommuteinset"></A>
<BR>
commuteinset
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Declaration statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">commuteinset <SPAN style="font-family:monospace">&lt;</SPAN><SPAN CLASS="MATH"><IMG STYLE="height: 2.53ex; vertical-align: -0.69ex; " SRC="img25.svg"
 ALT="$\{$"></SPAN>list of noncommuting functions/tensors<SPAN CLASS="MATH"><IMG STYLE="height: 2.53ex; vertical-align: -0.69ex; " SRC="img26.svg"
 ALT="$\}$"></SPAN><SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">functions (<A HREF="#substafunctions">7.62</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
This statement<A NAME="3415"></A> allows one or more sets of 
noncommuting functions and or tensors for its argument(s). The functions 
inside each set will commute with each other. It is allowed to have the 
same function inside more than one set. For a function to commute with 
itself (with for instance different arguments) it needs to be specified 
twice inside the same set. In that case it is more efficient to have a 
separate set with only two arguments. Example:
<PRE>
    I   i1,...,i10;
    F   A1,...,A10;
    CommuteInSet{A1,A3,A5},{A1,g_},{A1,A1};
    L   F = A5*A1*A5*A1*A5*A2*A3*A5*A1*A5*A3*A1;
    L   G = g_(2,i1)*g_(2,i2,i3)*A1(i2)*g_(1,i4)*g_(1,5_,i5,i6)
                    *A1(i1)*A1(i3)*g5_(1)*A3(i5)*A3(i4)*g5_(1);
    Print +f +s;
    .end

   F =
       + A1*A1*A5*A5*A5*A2*A1*A1*A3*A3*A5*A5;
   G =
       + g_(1,i4,i5,i6)*g_(2,i1,i2,i3)*A1(i1)*A1(i2)*A1(i3)*
       A3(i5)*A3(i4)*g_(1,5_);
</PRE>
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008210000000000000000"></A>
<A ID="substacommuting"></A>
<BR>
commuting
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Declaration statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">co[mmuting] <SPAN style="font-family:monospace">&lt;</SPAN>list of functions to be declared<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">cfunctions (<A HREF="#substacfunctions">7.14</A>), functions (<A HREF="#substafunctions">7.62</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
This statement<A NAME="3429"></A> is completely identical to the 
cfunction statement (see <A HREF="#substacfunctions">7.14</A>). <BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008220000000000000000"></A>
<A ID="substacompress"></A>
<BR>
compress
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Declaration statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">comp[ress] <SPAN style="font-family:monospace">&lt;</SPAN>on/off<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">on (<A HREF="#substaon">7.107</A>), off (<A HREF="#substaoff">7.106</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
This statement<A NAME="3442"></A> is obsolete. The user should try 
to use the compress option of the on (see <A HREF="#substaon">7.107</A>) or the off (see 
<A HREF="#substaoff">7.106</A>) statements. <BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008230000000000000000"></A>
<A ID="substacontract"></A>
<BR>
contract
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">contract [<SPAN style="font-family:monospace">&lt;</SPAN>argument specifications<SPAN style="font-family:monospace">&gt;</SPAN>];</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
Statement<A NAME="3454"></A> causes the contraction of pairs of 
Levi-Civita<A NAME="3455"></A> tensors<A NAME="3456"></A> <code>e_</code> 
(see also <A HREF="#functions">8</A>) into combinations of Kronecker<A NAME="3458"></A> 
delta's<A NAME="3459"></A>. If there are contracted indices, and if 
their dimension is identical to the number of indices of the Levi-Civita 
tensors, the regular shortcuts are taken. If there are contracted indices 
with a different dimension, the contraction treats these indices 
temporarily as different and lets the contraction be ruled by the 
contraction mechanism of the Kronecker delta's. In practise this means that 
the dimension will enter via <!-- MATH
 $\delta^{\mu}_{\mu} \rightarrow {\rm
dim}(\mu)$
 -->
<SPAN CLASS="MATH"><IMG STYLE="height: 2.85ex; vertical-align: -1.01ex; " SRC="img49.svg"
 ALT="$\delta^{\mu}_{\mu} \rightarrow {\rm
dim}(\mu)$"></SPAN>. <BR>
<BR>

<P>
In FORM there are no upper<A NAME="3465"></A> and lower<A NAME="3466"></A> 
indices<A NAME="3467"></A><A NAME="3468"></A>. Of course the user can 
emulate those. The contract statement always assumes that there is a proper 
distribution of upper and lower indices if the user decided to work in a 
metric in which this makes a difference. Note however that due to the fact 
that the Levi-Civita tensor is considered to be imaginary, there is usually 
no need to do anything special. This is explained in the chapter on 
functions (see <A HREF="#functions">8</A>). <BR>
<BR>

<P>
There are several options to control which contractions will be 
taken. They are <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>Contract;
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>Here only a single pair of Levi-Civita tensors will be contracted. 
The pair that is selected by FORM is the pair that will give the smallest 
number of terms in their contraction.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>Contract <SPAN style="font-family:monospace">&lt;</SPAN>number<SPAN style="font-family:monospace">&gt;</SPAN>;
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>This tells FORM to keep contracting pairs of Levi-Civita tensors 
until there are <SPAN style="font-family:monospace">&lt;</SPAN>number<SPAN style="font-family:monospace">&gt;</SPAN> or <SPAN style="font-family:monospace">&lt;</SPAN>number<SPAN style="font-family:monospace">&gt;</SPAN><SPAN CLASS="MATH"><IMG STYLE="height: 1.90ex; vertical-align: -0.30ex; " SRC="img50.svg"
 ALT="$+1$"></SPAN> 
Levi-Civita tensors left. A common example is

<P>
Contract 0;

<P>
which will contract as many pairs as possible.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>Contract:<SPAN style="font-family:monospace">&lt;</SPAN>number<SPAN style="font-family:monospace">&gt;</SPAN>;
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>Here the number indicates the number of indices in the 
Levi-Civita tensors to be contracted. Only a single pair will be 
contracted and it will be the pair that gives the smallest number of 
terms.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>Contract:<SPAN style="font-family:monospace">&lt;</SPAN>number<SPAN style="font-family:monospace">&gt;</SPAN>

<P>
<SPAN style="font-family:monospace">&lt;</SPAN>number<SPAN style="font-family:monospace">&gt;</SPAN>;
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>The First number refers to the number of indices in the 
Levi-Civita tensors to be contracted. The second number refers to the 
number of Levi-Civita tensors that should be left (if possible) after 
contraction.</TD></TR>
</TABLE>
    <BR>

<P>
Note that the order in which FORM selects the contractions is by 
looking at which pair will give the smallest number of terms. This means 
that usually the largest buildup of terms is at the end. This is not always 
the case, because there can be a complicated network of contracted indices. 
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008240000000000000000"></A>
<A ID="substacopyspectator"></A>
<BR>
copyspectator
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">copyspectator <SPAN style="font-family:monospace">&lt;</SPAN>exprname = spectator;<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
See chapter<A HREF="#spectators">20</A> on spectators.
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008250000000000000000"></A>
<A ID="substacreatespectator"></A>
<BR>
createspectator
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">createspectator <SPAN style="font-family:monospace">&lt;</SPAN>spectatorname, "filename";<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
See chapter<A HREF="#spectators">20</A> on spectators.
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008260000000000000000"></A>
<A ID="substactable"></A>
<BR>
ctable
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Declaration statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">ctable <SPAN style="font-family:monospace">&lt;</SPAN>options<SPAN style="font-family:monospace">&gt;</SPAN> <SPAN style="font-family:monospace">&lt;</SPAN>table to be 
declared<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">functions (<A HREF="#substafunctions">7.62</A>), table (<A HREF="#substatable">7.142</A>),
        ntable (<A HREF="#substantable">7.101</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
This statement declares a commuting<A NAME="3530"></A> 
table<A NAME="3531"></A> and is identical to the table command (see 
<A HREF="#substatable">7.142</A>) which has the commuting property as its default. 
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008270000000000000000"></A>
<A ID="substactensors"></A>
<BR>
ctensors
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Declaration statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">ct[ensors] <SPAN style="font-family:monospace">&lt;</SPAN>list of tensors to be declared<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">functions (<A HREF="#substafunctions">7.62</A>), tensors 
        (<A HREF="#substatensors">7.144</A>), ntensors (<A HREF="#substantensors">7.102</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
This statement declares commuting<A NAME="3545"></A> 
tensors<A NAME="3546"></A>. It is equal to the tensor statement (see 
<A HREF="#substatensors">7.144</A>) which has the commuting property as its default. 
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008280000000000000000"></A>
<A ID="substacyclesymmetrize"></A>
<BR>
cyclesymmetrize
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">cy[clesymmetrize] <code>{</code><SPAN style="font-family:monospace">&lt;</SPAN>name of function/tensor<SPAN style="font-family:monospace">&gt;</SPAN>
         [<SPAN style="font-family:monospace">&lt;</SPAN>argument specifications<SPAN style="font-family:monospace">&gt;</SPAN>];<code>}</code></TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">symmetrize (<A HREF="#substasymmetrize">7.141</A>), antisymmetrize 
(<A HREF="#substaantisymmetrize">7.4</A>), rcyclesymmetrize (<A HREF="#substarcyclesymmetrize">7.121</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
The argument<A NAME="3562"></A> specifications are explained 
in the section on the symmetrize statements (see <A HREF="#substasymmetrize">7.141</A>). 

<P>
<BR>

<P>
The action of this statement is to cycle-symmetrize the (specified) 
arguments of the functions that are mentioned. This means that the 
arguments are brought to `natural order' in the notation of FORM by trying 
cyclic permutations of the arguments or groups of arguments. The `natural 
order' may depend on the order of declaration of the variables. 
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008290000000000000000"></A>
<A ID="substadeallocatetable"></A>
<BR>
deallocatetable
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Declaration</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">DeallocateTable,name(s) of sparse table(s);</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">table (<A HREF="#substatable">7.142</A>), fill (<A HREF="#substafill">7.57</A>),
   table bases (<A HREF="#tablebase">12</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
Works<A NAME="3574"></A> only for sparse<A NAME="3575"></A> 
tables<A NAME="3576"></A>. Deallocates all definitions of elements as 
obtained with `Fill'<A NAME="3577"></A> statements as if there never were any 
`Fill' statements for the given tables.

<P>
This statement exists because sometimes cleaning up big tables is needed 
when they take too much memory. This can be the case when a big tablebase 
has been used. <BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008300000000000000000"></A>
<A ID="substadefault"></A>
<BR>
default
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">default;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">case (<A HREF="#substacase">7.13</A>), break (<A HREF="#substabreak">7.12</A>),
		 switch(<A HREF="#substaswitch">7.139</A>), endswitch (<A HREF="#substaendswitch">7.49</A>).</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
This is the default case in a switch construction.

<P>
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008310000000000000000"></A>
<A ID="substadelete"></A>
<BR>
delete
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Specification statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">delete storage;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">save (<A HREF="#substasave">7.127</A>), load (<A HREF="#substaload">7.83</A>)</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">delete extrasymbols;</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">delete extrasymbols&gt;number;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">extrasymbols (<A HREF="#substaextrasymbols">7.53</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
This statement has currently two varieties. The delete 
storage<A NAME="3600"></A> clears the complete storage<A NAME="3601"></A> 
file<A NAME="3602"></A> and reduces it to zero size. The effect is that 
all stored expressions are removed from the system. Because it is 
impossible to remove individual expressions from the store file (there is 
no mechanism to fill the resulting holes) it is the only way to clean up 
the storage file. If some expressions should be excluded from this 
elimination process, one should copy them first into active global 
expressions, then delete the storage file, after which the expressions can 
be written to storage again with a .store<A NAME="3603"></A> instruction.

<P>
The delete extrasymbols<A NAME="3604"></A><A NAME="3605"></A> variety removes 
extra symbols<A NAME="3606"></A> from the list. The default is that all 
extra symbols are removed, but one can also remove the symbols above a 
given number as in
<PRE>
   #$es = `extrasymbols_';
   ToPolynomial;
     ....some code....
   .sort
   * now the new extra symbols are not needed anylonger
   Delete extrasymbols&gt;`$es';
</PRE>
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008320000000000000000"></A>
<A ID="substadenominators"></A>
<BR>
denominators
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">denominators functionname;</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
This statement<A NAME="3616"></A> allows the user to rename all 
occurrences of the built-in denominator function. This built-in function is 
kind of an oddity inside FORM. Denominators are presented by a very special 
function which doesn't really have a name and hence is rather hard to 
address. In addition there are special rules connected to denominators. 
Hence it is usually better to collect denominators inside functions that 
have been defined by the user and hence allow the user to manipulate them 
at will. Yet, objects can end up inside denominator functions, especially 
when output from other programs is read in. Hence this statement allows all 
occurrences of the denominator function to be renamed into the function 
that is given in the statement. This function will work well together with 
the PolyRatFun statement in which we define a PolyFun with two arguments of 
which the second acts as a denominator and the first as a numerator:
<PRE>
   PolyRatFun,rat;
   Denominators,den;
   id den(x?) = rat(1,x);
</PRE>
For more about this one should consult the part on the 
PolyRatFun<A NAME="3619"></A> statement 
(<A HREF="#substapolyratfun">7.111</A>) and the chapter on polynomials (still to be 
included because the current version can handle only polynomials in a 
single variable and is also not optimized for many occurrences that have 
identical denominators).
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008330000000000000000"></A>
<A ID="substadimension"></A>
<BR>
dimension
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Declaration statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">d[imension] <SPAN style="font-family:monospace">&lt;</SPAN>number or symbol<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">index (<A HREF="#substaindex">7.74</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
Sets the default dimension<A NAME="3631"></A>. This default 
dimension determines the dimension of the indices<A NAME="3632"></A> that are 
being declared without dimension specification as well as the dimension of 
all dummy indices<A NAME="3633"></A>. At the moment an index is declared 
and there is no dimension specification, FORM looks for the default 
dimension and uses that. This index will then have this dimension, even 
when the default dimension is changed at a later moment. The dummy indices 
always have the dimension of the current default dimension. If the default 
dimension is changed the dimension of all dummy indices changes with it. 
Varieties: <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>Dimension <SPAN style="font-family:monospace">&lt;</SPAN>number<SPAN style="font-family:monospace">&gt;</SPAN>;
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>Declares the number to be the default dimension. The number must be smaller than
32768 on 32bit architectures or 2147483648 on 64bit architectures. Negative numbers are not allowed.
If one wants to work with negative dimensions, the practical workaround is to use a symbolic
dimension and later replace that symbol appropriately.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>Dimension <SPAN style="font-family:monospace">&lt;</SPAN>symbol<SPAN style="font-family:monospace">&gt;</SPAN>;
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>Symbol must be the name of a symbol, either previously 
declared or declarable because of an auto-declaration (see 
<A HREF="#substaautodeclare">7.10</A>). Declares the symbol to be the default dimension.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>Dimension

<P>
<SPAN style="font-family:monospace">&lt;</SPAN>symbol<SPAN style="font-family:monospace">&gt;</SPAN>:<SPAN style="font-family:monospace">&lt;</SPAN>symbol<SPAN style="font-family:monospace">&gt;</SPAN>;
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>The symbols<A NAME="7868"></A> must be the names of symbols, 
either previously declared or declarable because of an auto-declaration 
(see <A HREF="#substaautodeclare">7.10</A>). The first symbol will be the default 
dimension. The second symbol will be the first symbol minus 4. It will 
be used as such in the trace<A NAME="7870"></A> 
contractions<A NAME="7871"></A>. See also <A HREF="#substatracen">7.153</A> and 
<A HREF="#substaindex">7.74</A>.</TD></TR>
</TABLE>
    <BR>

<P>
Examples:
<PRE>
   Dimension 3;
   Dimension n;
   Dimension n:[n-4];
</PRE>
The default dimension in FORM is 4. <BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008340000000000000000"></A>
<A ID="substadiscard"></A>
<BR>
discard
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">dis[card];</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
This statement discards<A NAME="3668"></A> the current term. It can 
be very useful in statements of the type
<PRE>
   if ( count(x,1) &gt; 5 ) Discard;
</PRE>
which eliminates all terms that have more than five powers of x. 
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008350000000000000000"></A>
<A ID="substadisorder"></A>
<BR>
disorder
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">disorder <SPAN style="font-family:monospace">&lt;</SPAN>pattern<SPAN style="font-family:monospace">&gt;</SPAN> = <SPAN style="font-family:monospace">&lt;</SPAN>expression<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">identify (<A HREF="#substaidentify">7.68</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
This statement is identical to the disorder<A NAME="3683"></A> 
option<A NAME="3684"></A> of the id<A NAME="3685"></A><A NAME="3686"></A> 
statement (see <A HREF="#substaidentify">7.68</A>). It is just a shorthand notation for 
`id disorder'. <BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008360000000000000000"></A>
<A ID="substado"></A>
<BR>
do
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">do $loopvar = lowvalue,highvalue<code>{</code>,increment<code>}</code>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">enddo (<A HREF="#substaenddo">7.44</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
The syntax is the typical syntax for do-loops. The loop variable 
has to be a dollar variable. For parallel performance this variable can be 
declared local in a moduleoption (see <A HREF="#substamoduleoption">7.89</A>) statement, 
unless it is also used in other ways in the current module. The loop 
parameters should either be (short) integers or dollar variables or factors 
of dollar variables provided they evaluate at run time to (short) integers. 
The enddo statement should be in the same module as the do statement. In 
addition it should be properly nested with if, repeat, while and argument 
constructions.

<P>
The do-loop facility is in principle superfluous, because the 
repeat&nbsp;(<A HREF="#substarepeat">7.125</A>), if&nbsp;(<A HREF="#substaif">7.71</A>) and the pattern matcher can 
basically do everything the do-loop can do. Sometimes however the do-loop 
is easier to program and gives more readable code as shown here:
<PRE>
   do $i = 1,5;
      id,only,x^$i = f(F[factor_^$i]);
   enddo;
</PRE>
versus
<PRE>
   id,only,x^n?{1,2,3,4,5} = ff(n);
   repeat id ff(n?pos_) = ff(n-1)*f(F[factor_^n]);
   id ff(n?neg0_) = 1;
</PRE>
One should note that the do-loop is evaluated at run time. Hence 
the dollar variables need to be evaluated at run time as well. Therefore, 
if it is possible, the preprocessor variety (see <A HREF="#predo">3.19</A>) is almost 
always faster in execution as in
<PRE>
   #do i = 1,5
      id,only,x^`i' = f(F[factor_^`i']);
   #enddo
</PRE>
This can of course not be done in constructions like
<PRE>
   id  f1(x?$x) = f2(x);
   FactDollar,$x;
   Do $i = 1,$x[0];
     Multiply f($i,$x[$i]);
   Enddo;
</PRE>
because here <code>$x</code> and its factors are only known at run time 
and may be different for each term.
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008370000000000000000"></A>
<A ID="substadrop"></A>
<BR>
drop
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Specification statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">drop;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">drop <SPAN style="font-family:monospace">&lt;</SPAN>list of expressions<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">ndrop (<A HREF="#substandrop">7.93</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
In the first variety this statement<A NAME="3718"></A> eliminates all 
expressions<A NAME="3719"></A> from the system. In the second variety it 
eliminates only the expressions that are mentioned from the system. All 
expressions that are to be dropped can still be used in the r.h.s. of other 
expressions inside the current module. Basically the expressions to be 
dropped are not treated for execution and after the module has finished 
completely they are removed. See also the ndrop 
statement&nbsp;<A HREF="#substandrop">7.93</A>. <BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008380000000000000000"></A>
<A ID="substadropcoefficient"></A>
<BR>
dropcoefficient
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">DropCoefficient;</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
This statement replaces the coefficient of the current term by 
one. In principle it has the same effect as
<PRE>
   Multiply 1/coeff_;
</PRE>
but there is always the philosophical issue what is the coefficient once 
one enters function arguments. Inside an 
Argument/EndArgument<A NAME="3730"></A><A NAME="3731"></A> environment this 
statement would drop the coefficient of the terms inside the argument.
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008390000000000000000"></A>
<A ID="substadropsymbols"></A>
<BR>
dropsymbols
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">DropSymbols;</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
This statement removes all symbols from a term. 
It has the same effect as
<PRE>
   id,many,x?^n? = 1;
</PRE>
(x and n are symbols) except for that it is much faster.
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008400000000000000000"></A>
<A ID="substaelse"></A>
<BR>
else
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">else;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">if (<A HREF="#substaif">7.71</A>),
              elseif (<A HREF="#substaelseif">7.41</A>),
              endif (<A HREF="#substaendif">7.45</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
To be used in combination with an if statement (see 
<A HREF="#substaif">7.71</A>). The statements following the
else<A NAME="3752"></A><A NAME="3753"></A> statement until the matching 
endif<A NAME="3754"></A><A NAME="3755"></A> 
statement (see <A HREF="#substaendif">7.45</A>) will be executed for the current term if 
the conditions of the matching proceeding if<A NAME="3757"></A><A NAME="3758"></A> 
statement and/or all corresponding elseif<A NAME="3759"></A> statements (see 
<A HREF="#substaelseif">7.41</A>) are false. If any of the conditions of the matching 
proceeding if or elseif statements are true the statements following the 
else statement will be skipped. <BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008410000000000000000"></A>
<A ID="substaelseif"></A>
<BR>
elseif
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">elseif ( <SPAN style="font-family:monospace">&lt;</SPAN>condition<SPAN style="font-family:monospace">&gt;</SPAN> );</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">if (<A HREF="#substaif">7.71</A>),
              else (<A HREF="#substaelse">7.40</A>),
              endif (<A HREF="#substaendif">7.45</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
Should be proceeded by an if<A NAME="3773"></A><A NAME="3774"></A> 
statement (see <A HREF="#substaif">7.71</A>) and followed at least by a matching 
endif<A NAME="3776"></A><A NAME="3777"></A> 
statement (see <A HREF="#substaendif">7.45</A>). If the conditions of the proceeding 
matching if statement and all proceeding matching
elseif<A NAME="3779"></A><A NAME="3780"></A> statements are false the 
condition of this elseif statement will be evaluated. If it is true, the 
statements following it until the next matching elseif,
else<A NAME="3781"></A><A NAME="3782"></A> or endif statement will be executed. 
If not, control is passed to this next elseif, else or endif statement. The 
syntax for the condition is exactly the same as for the condition in the if 
statement. <BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008420000000000000000"></A>
<A ID="substaemptyspectator"></A>
<BR>
emptyspectator
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">emptyspectator <SPAN style="font-family:monospace">&lt;</SPAN>spectator;<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
See chapter<A HREF="#spectators">20</A> on spectators.
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008430000000000000000"></A>
<A ID="substaendargument"></A>
<BR>
endargument
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">endargument;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">argument (<A HREF="#substaargument">7.9</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
Terminates an argument environment<A NAME="3801"></A> 
(see <A HREF="#substaargument">7.9</A>). The argument<A NAME="3803"></A> statement and its 
corresponding endargument<A NAME="3804"></A> statement must belong to the 
same module. Argument environments can be nested with all other 
environments. <BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008440000000000000000"></A>
<A ID="substaenddo"></A>
<BR>
enddo
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">enddo;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">do (<A HREF="#substado">7.36</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
See the do statement (<A HREF="#substado">7.36</A>).
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008450000000000000000"></A>
<A ID="substaendif"></A>
<BR>
endif
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">endif;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">if (<A HREF="#substaif">7.71</A>),
              elseif (<A HREF="#substaelseif">7.41</A>),
              else (<A HREF="#substaelse">7.40</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
Terminates an if<A NAME="3824"></A><A NAME="3825"></A> construction (see <A HREF="#substaif">7.71</A>, 
<A HREF="#substaelseif">7.41</A> and <A HREF="#substaelse">7.40</A>). If should be noted that 
if<A NAME="3829"></A><A NAME="3830"></A> 
constructions can be nested.
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008460000000000000000"></A>
<A ID="substaendinexpression"></A>
<BR>
endinexpression
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">endinexpression;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">inexpression(<A HREF="#substainexpression">7.75</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
Only to be used in combination with the 
inexpression<A NAME="3839"></A><A NAME="3840"></A> statement. The 
combination
<PRE>
   InExpression,expr;
       Statements;
   EndInExpression;
</PRE>
is a more readable version of the construction
<PRE>
   if ( expression(expr) );
       Statements;
   endif;
</PRE>
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008470000000000000000"></A>
<A ID="substaendinside"></A>
<BR>
endinside
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">endinside;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">inside (<A HREF="#substainside">7.77</A>) and the chapter on $-variables 
(<A HREF="#dollars">6</A>)</TD>
</TR>
</TABLE>
<BR>
<BR>

<P>
Terminates an `inside'<A NAME="3854"></A> 
environment<A NAME="3855"></A> (see <A HREF="#substainside">7.77</A>) which is 
used to operate on the contents of $-variables<A NAME="3857"></A> (see 
<A HREF="#dollars">6</A>).
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008480000000000000000"></A>
<A ID="substaendrepeat"></A>
<BR>
endrepeat
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">endrepeat;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">repeat (<A HREF="#substarepeat">7.125</A>), while (<A HREF="#substawhile">7.160</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
Ends the repeat<A NAME="3868"></A> 
environment<A NAME="3869"></A>. The repeat environment is started 
with a repeat statement (see <A HREF="#substarepeat">7.125</A>). The repeat and its 
matching endrepeat<A NAME="3871"></A> should be inside the same module. 
Repeat environments can be nested with all other environments (and other 
repeat environments). <BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008490000000000000000"></A>
<A ID="substaendswitch"></A>
<BR>
endswitch
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">endswitch;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">case (<A HREF="#substacase">7.13</A>), break (<A HREF="#substabreak">7.12</A>),
		 default(<A HREF="#substadefault">7.30</A>), switch (<A HREF="#substaswitch">7.139</A>).</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
Ends a switch construction. It collects the various cases, puts 
them in order and decides whether the lookup of cases should be done by 
means of a jumptable, or by binary searching. The ratio (spread in 
cases)/(number of cases) determines whether a jumptable is constructed. The 
default value below which a jumptable is constructed is 4. This value can 
be changed in the setups (see the section on the setups <A HREF="#setup">17</A>) with 
the variable jumpratio.

<P>
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008500000000000000000"></A>
<A ID="substaendterm"></A>
<BR>
endterm
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">endterm;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">term (<A HREF="#substaterm">7.145</A>), sort (<A HREF="#substasort">7.133</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
Terminates a term<A NAME="3893"></A> environment<A NAME="3894"></A> 
(see <A HREF="#substaterm">7.145</A>). Term environments<A NAME="3896"></A> can be nested with 
other term environments and with other environments in general. The whole 
environment should be part of one single module. See also <A HREF="#substasort">7.133</A>. 
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008510000000000000000"></A>
<A ID="substaendwhile"></A>
<BR>
endwhile
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">endwhile;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">while (<A HREF="#substawhile">7.160</A>), repeat (<A HREF="#substarepeat">7.125</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
Terminates a while<A NAME="3907"></A> environment<A NAME="3908"></A> (see <A HREF="#substawhile">7.160</A>). The while 
statement and its corresponding endwhile<A NAME="3910"></A> statement must be part of the same 
module. <BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008520000000000000000"></A>
<A ID="substaexit"></A>
<BR>
exit
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">exit ["<SPAN style="font-family:monospace">&lt;</SPAN>string<SPAN style="font-family:monospace">&gt;</SPAN>"];</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">setexitflag (<A HREF="#substasetexitflag">7.130</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
Causes execution to be aborted<A NAME="3921"></A><A NAME="3922"></A> 
immediately. The string will be printed in the output. This can be used to 
indicate where FORM ran into the exit statement. <BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008530000000000000000"></A>
<A ID="substaextrasymbols"></A>
<BR>
extrasymbols
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Declaration statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">extrasymbols,array|vector|underscore,name;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">ToPolynomial (<A HREF="#substatopolynomial">7.148</A>), FromPolynomial 
(<A HREF="#substafrompolynomial">7.61</A>), ArgToExtraSymbol (<A HREF="#substaargtoextrasymbol">7.8</A>)</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">and extra symbols 
(<A HREF="#sect-extrasymbols">2.11</A>).</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
Starting with version 4.0 of FORM some built in operations or
statements can only deal with symbols and numbers. Examples of this are 
factorization&nbsp;(<A HREF="#substafactarg">7.54</A>) (which uses the topolynomial facilities 
automatically) and output simplification (see the Format 
statement <A HREF="#substaformat">7.60</A>).
The ToPolynomial statement<A NAME="3939"></A> takes each term, looks for 
objects that are not symbols to positive powers and replaces them by 
symbols. If the object has been encountered before the same symbol will be 
used, otherwise a new symbol will be defined. The object represented by the 
`extra symbol'<A NAME="3940"></A> is stored internally and can be printed 
if needed with the %X option in the #write instruction (<A HREF="#prewrite">3.64</A>). 
The representation of the extra symbols is by default the name Z followed 
by a number and an underscore character. If another name is desired this 
should be specified in an `ExtraSymbols' statement. The name given may 
contain only alphabetic characters! Because some compilers do not like the 
underscore character, there is an alternative notation for the extra 
symbols. This is just for cosmetic reasons and one cannot feed these 
symbols into the compiler this way. This is with an array notation. The 
statement
<PRE>
   ExtraSymbols,array,Ab;
</PRE>
would cause the second extra symbol to be printed as <SPAN style="font-family:monospace">Ab(2)</SPAN>. The total 
number of defined extra symbols is given by the built in symbol 
extrasymbols_.
The option vector in the ExtraSymbols statement is identical to the option 
array and the option underscore reverts the notation back to the default 
notation with the trailing underscore.
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008540000000000000000"></A>
<A ID="substafactarg"></A>
<BR>
factarg
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">factarg options <code>{</code><SPAN style="font-family:monospace">&lt;</SPAN>name of function/set<SPAN style="font-family:monospace">&gt;</SPAN>
                [<SPAN style="font-family:monospace">&lt;</SPAN>argument specifications<SPAN style="font-family:monospace">&gt;</SPAN>]<code>}</code>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">splitarg (<A HREF="#substasplitarg">7.134</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
Splits<A NAME="3957"></A> the indicated function<A NAME="3958"></A> arguments into individual factors. The argument specifications 
are as in the splitarg<A NAME="3959"></A> statement (see 
<A HREF="#substasplitarg">7.134</A>). There are a few extra options:

<P>
<TABLE   STYLE="width:91;">
<TR><TD>(0)
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:635;">
<TR><TD>Eliminates the coefficient<A NAME="7889"></A> of the term 
in the argument. Similar to Normalize,(0),....</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:91;">
<TR><TD>(1)
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:635;">
<TR><TD>The coefficient of the term and its sign are pulled out 
separately.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:91;">
<TR><TD>(-1)
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:635;">
<TR><TD>The coefficient is pulled out with its sign.</TD></TR>
</TABLE>
    <BR>

<P>
In the case of the above options only the coefficient is treated. 
When these options are not used the whole term is treated as in:
<PRE>
    Symbols a,b,c;
    CFunctions f,f1,f2,f3;
    Local F = f(-3*a*b)+f(3*a*b)
             +f1(-3*a*b)+f1(3*a*b)
             +f2(-3*a*b)+f2(3*a*b)
             +f3(-3*a*b)+f3(3*a*b);
    FactArg,f;
    Factarg,(0),f1;
    Factarg,(1),f2;
    Factarg,(-1),f3;
    Print;
    .end

   F =
      f(a,b,-1,3) + f(a,b,3) + 2*f1(a*b) + f2(a*b,-1,3) + f2(a*b,3)
      + f3(a*b,-3) + f3(a*b,3);
</PRE>
When no extra options are used, starting with version 4.0, the whole 
argument is factorized over the rationals. This means that
<PRE>
    f(x^2+2*x*y+y^2) --&gt; f(y + x,y + x,1)
</PRE>
It should be noticed that FORM can although the internal algorithms can
only factorize expressions with numbers and symbols, FORM redefines all
non-symbol objects temporarily into symbols and at the end substitutes them 
back. This is done with a mechanism that is similar to that of the 
ToPolynomial statement.

<P>
See also the On OldfactArg; and Off OldFactArg statements for a 
compatibility mode with versions before version 4.0.
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008550000000000000000"></A>
<A ID="substafactdollar"></A>
<BR>
factdollar
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">factdollar <SPAN style="font-family:monospace">&lt;</SPAN>name of dollar variable<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">the chapter on polynomials&nbsp;<A HREF="#polynomials">11</A>.</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
The FactDollar statement will factorize a dollar expression. If 
the dollar expression was already factorized the old factors will be 
removed first. Unlike expressions (see <A HREF="#substafactorize">7.56</A>) where only 
either the expanded or the factorized version exists, with dollar 
expressions we have both versions simultaneously. This means that one can 
refer to the complete dollar in its unfactorized form and its factors. The 
factors are indicated between braces as in <code>$x[1]</code> which would be the 
first factor. The number of factors of <code>$x</code> is given by <code>$x[0]</code>. 
One can also obtain the number of factors of a dollar variable with the 
numfactors_ function (see <A HREF="#funnumfactors">8.49</A>).

<P>
The index indicating the number of the factor can be a nonzero 
integer, no greater than the number of factors, or (a factor of) a dollar 
variable that evaluates into such a number. Composite expressions are not 
allowed. They should be worked out first in a separate dollar variable, 
after which this dollar variable can then be used as a factor indicator.
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008560000000000000000"></A>
<A ID="substafactorize"></A>
<BR>
factorize
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Output control statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">factorize <code>{</code><SPAN style="font-family:monospace">&lt;</SPAN>name of expression(s)<SPAN style="font-family:monospace">&gt;</SPAN><code>}</code>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">the chapter on polynomials&nbsp;<A HREF="#polynomials">11</A>.</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
If no expressions are mentioned all expressions will be affected 
by the action of this statement. One may exclude certain expressions with 
the nfactorize statement (see <A HREF="#substanfactorize">7.94</A>). If one or more 
expressions are mentoned they will be added to the list of expressions that 
will be affected.

<P>
The statement causes the output expression(s) that is/are marked 
as such to be factorized after they have been processed and already written 
to the output. This means that each expression, after having been written, 
is read again and factorized. Then the factorized result is written over 
the original output. After that FORM will start executing the statements of 
the current module on the next expression, sort it, write it to output, and 
if necessary read it again and factorize it.

<P>
Expressions never exists in two varieties as the dollar variable 
that have been factorized. It is either unfactorized (default) or 
factorized. An expression remains factorized untill an UnFactorize 
statement is encoutered that mentions that this expression should be 
brought to unfactorized representation (see also 
UnFactorize&nbsp;<A HREF="#substaunfactorize">7.156</A> and 
NunFactorize&nbsp;<A HREF="#substanunfactorize">7.103</A>).

<P>
One should realize that factorization of complicated expressions 
can be a rather costly operation.

<P>
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008570000000000000000"></A>
<A ID="substafill"></A>
<BR>
fill
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Declaration statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">fill <SPAN style="font-family:monospace">&lt;</SPAN>tableelement<SPAN style="font-family:monospace">&gt;</SPAN> = <SPAN style="font-family:monospace">&lt;</SPAN>expression<SPAN style="font-family:monospace">&gt;</SPAN> [,<SPAN style="font-family:monospace">&lt;</SPAN>moreexpressions<SPAN style="font-family:monospace">&gt;</SPAN>];</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">table (<A HREF="#substatable">7.142</A>), 
                fillexpression (<A HREF="#substafillexpression">7.58</A>),
                printtable (<A HREF="#substaprinttable">7.115</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
The standard<A NAME="4020"></A> way to define elements of a 
table<A NAME="4021"></A>. In the left hand 
side one specifies the table element without the extra function arguments 
that could potentially occur (see <A HREF="#substatable">7.142</A>). In the right hand 
side one specifies what the table element should be substituted by. 
Example:
<PRE>
    Table tab(1:2,1:2,x?);
    Fill tab(1,1) = x+y;
    Fill tab(2,1) = (x+y)^2;
    Fill tab(1,2) = tab(1,1)+y;
    Fill tab(2,2) = tab(2,1)+y^2;
</PRE>
The first fill statement is a bit like a continuous attempt to try the 
substitution
<PRE>
    id  tab(1,1,x?) = x+y;
</PRE>
The last two fill statements show that one could use the table 
recursively<A NAME="4027"></A>. 
If a real loop occurs the program may terminate due to
stack<A NAME="4028"></A> overflow.

<P>
It is possible to define several table elements in one statement. 
In that case the various elements are separated by commas. The last index 
is the first one to be raised. This means that in the above example one 
could have written:
<PRE>
    Table tab(1:2,1:2,x?);
    Fill tab(1,1) = x+y,tab(1,1)+y,(x+y)^2,tab(2,1)+y^2;
</PRE>
<BR>
<BR>
<BR>

<P>
One warning<A NAME="4032"></A> is called for. One should avoid using 
expressions in the right hand side of fill statements:
<PRE>
    Table B(1:1);
    Local dummy = 1;
    .sort
    Fill B(1) = dummy;
    Drop dummy;
    .sort
    Local F = B(1);
    Print;
    .end
</PRE>
In the example a crash will result, because when we use the table element 
the expression dummy doesn't exist anymore. In a fill statement the r.h.s. 
is not expanded. Hence it keeps the reference to the expression dummy. When 
the table element is used the reference to the expression dummy is inserted 
and expanded. Hence one obtains the contents of dummy that exist at the 
moment of use. This is illustrated in the following example:
<PRE>
    Table B(1:1);
    Local dummy = 1;
    .sort
    Fill B(1) = dummy;
    .sort
    Local F = B(1);
    Print;
    .sort
    Drop;
    .sort
    Local dummy = 2;
    .sort
    Local F = B(1);
    Print;
    .end
</PRE>
The final value of F will be 2, not 1.

<P>
A way to get around this problem is to force the evaluation of 
the table definition by using dollar<A NAME="4037"></A> 
variables<A NAME="4038"></A>:
<PRE>
    Table B(1:1);
    Local dummy = 1;
    .sort
    #$value = dummy;
    Fill B(1) = `$value';
    Drop dummy;
    .sort
    Local F = B(1);
    Print;
    .end
</PRE>
Here we use the character representation of the contents of the dollar 
variable to obtain an expression that doesn't need any further evaluation. 
If we would put
<PRE>
    fill B(1) = $value;
</PRE>
a reference to the dollar variable would be inserted and it would only be 
evaluated at use again. In principle this could cause similar problems.

<P>
Not dropping the expression dummy can sometimes give the correct 
result, but is potentially still unsafe. 
<PRE>
    Table B(1:1);
    Local u = 2;
    Local dummy = 1;
    .sort
    Fill B(1) = dummy;
    Drop dummy;
    .sort
    Local v = 5;
    Local F = B(1);
    Print;
    .end
</PRE>
Here the answer will be 5, because after u has been dropped the expressions 
will be renumbered. Hence now dummy becomes the first expression, and 
eventually v becomes the second expression. The references in the table 
elements are not renumbered. Hence the r.h.s. of B(1) keeps pointing at the 
second expression, which at the moment of application has the value 5. One 
can see now also why the original example crashes. First dummy was the 
first expression and at the moment of application F is the first (existing) 
expression. Hence the substitution of B(1) causes a self reference and 
hence an infinite loop. Eventually some buffer will 
overflow<A NAME="4045"></A>.
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008580000000000000000"></A>
<A ID="substafillexpression"></A>
<BR>
fillexpression
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Declaration statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">fillexpression <SPAN style="font-family:monospace">&lt;</SPAN>table<SPAN style="font-family:monospace">&gt;</SPAN> = <SPAN style="font-family:monospace">&lt;</SPAN>expression<SPAN style="font-family:monospace">&gt;</SPAN>(<SPAN style="font-family:monospace">&lt;</SPAN>x1<SPAN style="font-family:monospace">&gt;</SPAN>,...,<SPAN style="font-family:monospace">&lt;</SPAN>xn<SPAN style="font-family:monospace">&gt;</SPAN>);</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">fillexpression <SPAN style="font-family:monospace">&lt;</SPAN>table<SPAN style="font-family:monospace">&gt;</SPAN> = <SPAN style="font-family:monospace">&lt;</SPAN>expression<SPAN style="font-family:monospace">&gt;</SPAN>(<SPAN style="font-family:monospace">&lt;</SPAN>funname<SPAN style="font-family:monospace">&gt;</SPAN>);</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">table (<A HREF="#substatable">7.142</A>), 
                fill (<A HREF="#substafill">7.57</A>) and the table_ function 
(<A HREF="#funtable">8.68</A>)</TD>
</TR>
</TABLE>
<BR>
<BR>

<P>
Used<A NAME="4070"></A> to dynamically<A NAME="4071"></A>
load<A NAME="4072"></A> a table<A NAME="4073"></A> during runtime. When 
there are n symbols (here called x1 to xn) it is assumed that the table is 
n-dimensional. The expression must previously have been bracketed in these 
symbols and each of the brackets<A NAME="4074"></A> has the effect of a 
fill<A NAME="4075"></A> statement in which the powers of the x1 to xn refer to the 
table elements. Brackets that do not have a corresponding table element are 
skipped.

<P>
In the case that only a function name is specified the arguments 
of the function refer to the table elements.
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008590000000000000000"></A>
<A ID="substafixindex"></A>
<BR>
fixindex
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Declaration statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">fi[xindex] <code>{</code><SPAN style="font-family:monospace">&lt;</SPAN>number<SPAN style="font-family:monospace">&gt;</SPAN>:<SPAN style="font-family:monospace">&lt;</SPAN>value<SPAN style="font-family:monospace">&gt;</SPAN><code>}</code>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">index (<A HREF="#substaindex">7.74</A>) and chapter <A HREF="#metric">15</A>.</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
Defines <code>d_(number,number) = value</code> in which number is the 
number<A NAME="4089"></A> of a fixed<A NAME="4090"></A> index<A NAME="4091"></A> 
(hence a positive short integer with a value less than 
ConstIndex<A NAME="4092"></A> (see <A HREF="#setup">17</A>). The value should be a 
short<A NAME="4094"></A> integer, i.e. its absolute value should be less 
than <SPAN CLASS="MATH"><IMG STYLE="height: 2.14ex; vertical-align: -0.11ex; " SRC="img51.svg"
 ALT="$2^{15}$"></SPAN> on 32<A NAME="4096"></A> bit computers and less than <SPAN CLASS="MATH"><IMG STYLE="height: 2.14ex; vertical-align: -0.11ex; " SRC="img52.svg"
 ALT="$2^{31}$"></SPAN> on 
64<A NAME="4098"></A> bit 
computers. One can define more than one fixed index in one statement. 
Before one would like to solve problems involving the choice of a metric 
with this statement, one should consult the chapter on the use of a 
metric<A NAME="4099"></A> 
(chapter <A HREF="#metric">15</A>).
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008600000000000000000"></A>
<A ID="substaformat"></A>
<BR>
format
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Output control statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">fo[rmat] <SPAN style="font-family:monospace">&lt;</SPAN>option<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">print (<A HREF="#substaprint">7.113</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
Controls the format<A NAME="4111"></A> for the 
printing<A NAME="4112"></A> of expressions. There is a variety of options.

<P>
<TABLE   STYLE="width:159;">
<TR><TD><SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img23.svg"
 ALT="$&lt;$"></SPAN>number<SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img24.svg"
 ALT="$&gt;$"></SPAN>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Output will be printed using the indicated number of 
characters per line. The default is 72. Numbers outside the range 1-255 are 
corrected to 72. Positive numbers less than 39 are corrected to 39.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>float<A NAME="7934"></A><A NAME="7935"></A> 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN style="font-family:monospace">[</SPAN><SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img23.svg"
 ALT="$&lt;$"></SPAN>number<SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img24.svg"
 ALT="$&gt;$"></SPAN><SPAN style="font-family:monospace">]</SPAN>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Numbers are printed in floating<A NAME="7944"></A> 
point notation, even though internally they remain fractions. This is 
purely cosmetic. If no number is specified the precision of the output will 
be 10 digits. If a number is specified it indicates the number of digits to 
be used for the precision.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>rational<A NAME="7951"></A><A NAME="7952"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Output format is switched back to rational numbers (in 
contrast to floating point output). This is the default.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>nospaces<A NAME="7965"></A><A NAME="7966"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>The output is printed without the spaces that make the 
output slightly more readable. This gives a more compact output.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>spaces<A NAME="7979"></A><A NAME="7980"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>The output is printed with extra spaces between the terms 
and around certain operators to make it slightly more readable. This is the 
default.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>O0<A NAME="7993"></A><A NAME="7994"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>FORM will turn off output optimization. See the section 
on output optimization <A HREF="#optimization">10</A></TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>O1[options]<A NAME="8009"></A><A NAME="8010"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>FORM will use level 1 output optimization. See the section 
on output optimization <A HREF="#optimization">10</A></TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>O2[options]<A NAME="8025"></A><A NAME="8026"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>FORM will use level 2 output optimization. See the section 
on output optimization <A HREF="#optimization">10</A></TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>O3[options]<A NAME="8041"></A><A NAME="8042"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>FORM will use level 3 output optimization. See the section 
on output optimization <A HREF="#optimization">10</A>.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>fortran<A NAME="8057"></A><A NAME="8058"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>The output is printed in a way that is readable by a 
fortran compiler. This includes continuation characters and the splitting 
of the output into blocks of no more than 15 continuation lines. This 
number can be changed with the setup parameter ContinuationLines (see 
<A HREF="#setup">17</A>). In addition dotproducts are printed with the `dotchar' 
in the place of the period between the vectors. This dotchar can be set in 
the setup file (see <A HREF="#setup">17</A>). Its default is the underscore character.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>doublefortran<A NAME="8073"></A><A NAME="8074"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Same as the fortran mode, but fractions are printed with 
double floating point numbers, because some compilers convert numbers like 
1. into 1.E0. With this format FORM will force double precision by using 
1.D0.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>quadruplefortran<A NAME="8088"></A><A NAME="8089"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Same as the fortran mode, but fractions are printed with 
quadruple floating point numbers, because some compilers convert numbers like 
1. into 1.E0. With this format FORM will force quadruple precision by using 
1.Q0.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>quadfortran<A NAME="8103"></A><A NAME="8104"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Same as quadruplefortran.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>fortran90<A NAME="8117"></A><A NAME="8118"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Similar to the fortran option, but prints the 
continuation lines according to the syntax of Fortran 90. If the fortran90 
option is followed by a comma and a string that does not contain white space 
or other comma's, this string is attached to all numbers in coefficients of 
terms. Example: 
<BR><SPAN style="font-family:monospace">      Format Fortran90,.0_ki;</SPAN> 
<BR>
which would give in the printout: 
<BR><SPAN style="font-family:monospace">      +23.0_ki/32.0_ki*a**2&amp; </SPAN> 
<BR><SPAN style="font-family:monospace">    &amp; +34.0_ki/1325.0_ki*a**3</SPAN> 
<BR>
When there is no string attached it defaults to a period as in the regular 
Fortran option.
</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>C<A NAME="8134"></A><A NAME="8135"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Output will be C compatible. The
exponent<A NAME="8142"></A> operator (<SPAN CLASS="MATH"><IMG STYLE="height: 1.50ex; vertical-align: -0.11ex; " SRC="img13.svg"
 ALT="$\wedge$"></SPAN>) is represented by the 
function pow<A NAME="8143"></A>. It is the responsibility of the user that this 
function will be properly defined. Dotproducts are printed with the 
`dotchar'<A NAME="8144"></A> in the place of the period between the vectors. 
This dotchar can be set in the setup file (see <A HREF="#setup">17</A>). Its default is 
the underscore<A NAME="8146"></A> character.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>maple<A NAME="8153"></A><A NAME="8154"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Output will be as much as possible compatible with Maple 
format. It is not guaranteed that this is perfect.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>mathematica<A NAME="8167"></A><A NAME="8168"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Output will be as much as possible compatible with 
Mathematica format. It is not guaranteed that this is perfect.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>reduce<A NAME="8181"></A><A NAME="8182"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Output will be as much as possible compatible with 
Reduce format. It is not guaranteed that this is perfect.</TD></TR>
</TABLE>
    <BR>

<P>
The last few formats have not been tried out extensively. The 
author is open for suggestions.

<P>
<TABLE   STYLE="width:159;">
<TR><TD>normal<A NAME="8195"></A><A NAME="8196"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Will return to the regular FORM formatting mode.</TD></TR>
</TABLE>
    <BR>

<P>
If the statement has no arguments the formatting will be reset to 
the mode it was in when the program started.
<BR>
<BR>

<P>
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008610000000000000000"></A>
<A ID="substafrompolynomial"></A>
<BR>
frompolynomial
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">frompolynomial</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">factarg (<A HREF="#substafactarg">7.54</A>), ToPolynomial 
(<A HREF="#substatopolynomial">7.148</A>) and ExtraSymbols (<A HREF="#substaextrasymbols">7.53</A>,
<A HREF="#sect-extrasymbols">2.11</A>).</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
Starting with version 4.0 of FORM some built in operations or
statements can only deal with symbols and numbers. Examples of this are 
factorization&nbsp;(<A HREF="#substafactarg">7.54</A>) and output simplification (still to be 
implemented). Whereas the ToPolynomial statement takes each term, looks for objects 
that are not symbols to positive powers and replaces them by symbols the 
FromPolynomial does the opposite: it replaces the newly defined extra 
symbols and replaces them back by their original meaning.
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008620000000000000000"></A>
<A ID="substafunctions"></A>
<BR>
functions
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Declaration statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">f[unctions] <SPAN style="font-family:monospace">&lt;</SPAN>list of functions to be declared<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">cfunctions (<A HREF="#substacfunctions">7.14</A>), 
           tensors (<A HREF="#substatensors">7.144</A>),
           ntensors (<A HREF="#substantensors">7.102</A>),</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">table (<A HREF="#substatable">7.142</A>),
           ntable (<A HREF="#substantable">7.101</A>),
           ctable (<A HREF="#substactable">7.26</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
Used to declare one or more functions<A NAME="4245"></A>. The functions declared 
with this statement will be noncommuting<A NAME="4246"></A>. For 
commuting<A NAME="4247"></A> functions one 
should use the cf[unctions] statement (see <A HREF="#substacfunctions">7.14</A>). 
Functions can have a number of properties that can be set in the 
declaration. This is done by appending the options to the name of the 
function. These options are:

<P>
<TABLE   STYLE="width:186;">
<TR><TD>name#r
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>The function is considered to be a real<A NAME="8219"></A> function (default).</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:186;">
<TR><TD>name#c
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>The function is considered to be a complex<A NAME="8234"></A> function. This means 
that internally two spaces are reserved. One for the variable name and one 
for its complex conjugate name#.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:186;">
<TR><TD>name#i
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>The function is considered to be imaginary<A NAME="8251"></A>.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:186;">
<TR><TD>name(s[ymmetric])
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>The function is totally symmetric<A NAME="8264"></A>. This means that during 
normalization FORM will order the arguments according to its internal 
notion of order by trying permutations. The result will depend on the order 
of declaration of variables.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:186;">
<TR><TD>name(a[ntisymmetric])
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>The function is totally antisymmetric<A NAME="8279"></A>. This means that 
during normalization FORM will order the arguments according to its 
internal notion of order and if the resulting permutation of arguments is 
odd the coefficient of the term will change sign. The order will depend on 
the order of declaration of variables.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:186;">
<TR><TD>name(c[yclesymmetric])
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>The function is cycle<A NAME="8294"></A> 
symmetric<A NAME="8295"></A> in all its arguments. 
This means that during normalization FORM will order the arguments 
according to its internal notion of order by trying cyclic permutations. 
The result will depend on the order of declaration of variables.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:186;">
<TR><TD>name(r[cyclesymmetric)

<P>
name(r[cyclic])

<P>
name(r[eversecyclic])
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>The function is reverse<A NAME="8310"></A> 
cycle symmetric<A NAME="8311"></A> in all its arguments. This 
means that during normalization FORM will order the arguments according 
to its internal notion of order by trying cyclic permutations and/or a 
complete reverse order of all arguments. The result will depend on the 
order of declaration of variables.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:186;">
<TR><TD>name&lt;number

<P>
name&lt;=number

<P>
name&gt;number

<P>
name&gt;=number
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>The function has a restriction on the number of 
arguments. If the number of arguments of an occurrence of the function is 
not fulfilling the condition during normalization FORM will set the term 
equal to zero.</TD></TR>
</TABLE>
    <BR>
<BR>

<P>
The complexity properties, the symmetric properties and the 
number of arguments restrictions can be 
combined. In that case the complexity properties should come first and the 
argument restrictions should come last as in
<PRE>
    Function f1#i(symmetric)&gt;=4&lt;8;
    Function f1#i&lt;=8;
</PRE>
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008630000000000000000"></A>
<A ID="substafunpowers"></A>
<BR>
funpowers
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Declaration statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">funpowers <SPAN style="font-family:monospace">&lt;</SPAN>on/off<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">on (<A HREF="#substaon">7.107</A>), off (<A HREF="#substaoff">7.106</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
This statement<A NAME="4302"></A> is obsolete<A NAME="4303"></A>. The 
user should try to use the funpowers option of the on<A NAME="4304"></A> (see 
<A HREF="#substaon">7.107</A>) or the off<A NAME="4306"></A> (see <A HREF="#substaoff">7.106</A>) statements. 
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008640000000000000000"></A>
<A ID="substagfactorized"></A>
<BR>
gfactorized
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Definition statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">g[lobal]factorized <SPAN style="font-family:monospace">&lt;</SPAN>option<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">the chapter on polynomials&nbsp;<A HREF="#polynomials">11</A>, the 
factorize statement&nbsp;<A HREF="#substafactorize">7.56</A> and the LocalFactorized</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">statement&nbsp;<A HREF="#substalfactorized">7.82</A>.</TD>
</TR>
</TABLE>

<P></P>

<P>
The syntax is like the syntax of the LocalFactorized (or 
LFactorized) statement&nbsp;<A HREF="#substalfactorized">7.82</A>. The only difference is that 
now the expression defined by the statement will become a global 
expression (see the Global statement&nbsp;<A HREF="#substaglobal">7.65</A>).
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008650000000000000000"></A>
<A ID="substaglobal"></A>
<BR>
global
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Definition statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">g[lobal] <SPAN style="font-family:monospace">&lt;</SPAN>name<SPAN style="font-family:monospace">&gt;</SPAN> = <SPAN style="font-family:monospace">&lt;</SPAN>expression<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">g[lobal] <SPAN style="font-family:monospace">&lt;</SPAN>names of expressions<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">local (<A HREF="#substalocal">7.84</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
Used to define a global<A NAME="4335"></A> 
expression<A NAME="4336"></A>. A global expression is an expression that 
remains active until the first .store<A NAME="4337"></A> instruction. At that 
moment it is stored into the `storage file'<A NAME="4338"></A><A NAME="4339"></A> and stops being manipulated. After this it can 
still be used in the right hand side of expressions and id<A NAME="4340"></A> 
statements (see <A HREF="#substaidnew">7.69</A>). Global expressions that have been put 
in the storage file can be saved to a disk file<A NAME="4342"></A> with the 
save statement (see <A HREF="#substasave">7.127</A>) for use in later programs.

<P>
There are two versions of the global statement. In the first the 
expression is defined and filled with a right hand side expression. The left 
hand side and the right hand side are separated by an = sign. In this case 
the expression can have arguments which will serve as
dummy<A NAME="4344"></A> arguments after the global expression has been 
stored with a .store instruction. Note that this use of arguments can often 
be circumvented with the replace_ function (see <A HREF="#funreplace">8.59</A>) as in
<PRE>
    Global F(a,b) = (a+b)^2;
    .store
    Local FF = F(x,y);
    Local GG = F*replace_(a,x,b,y);
</PRE>
because both definitions give the same result.

<P>
The second version of the global statement has no = sign and no 
right hand side. It can be used to change a local<A NAME="4348"></A> expression 
into a global expression. <BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008660000000000000000"></A>
<A ID="substagoto"></A>
<BR>
goto
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">go[to] <SPAN style="font-family:monospace">&lt;</SPAN>label<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">label (<A HREF="#substalabel">7.81</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
Causes<A NAME="4359"></A> processing to proceed at the indicated 
label<A NAME="4360"></A> statement 
(see <A HREF="#substalabel">7.81</A>). This label statement must be in the same module. 
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008670000000000000000"></A>
<A ID="substahide"></A>
<BR>
hide
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Specification statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">hide;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">hide <SPAN style="font-family:monospace">&lt;</SPAN>list of expressions<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">nhide (<A HREF="#substanhide">7.96</A>),
              unhide (<A HREF="#substaunhide">7.157</A>),
              nunhide (<A HREF="#substanunhide">7.104</A>),
              pushhide (<A HREF="#substapushhide">7.118</A>),
              pophide (<A HREF="#substapophide">7.112</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
In the first variety this statement marks all currently active 
expressions for being put in hidden<A NAME="4376"></A> storage. In the second variety it marks 
only the specified active<A NAME="4377"></A> expressions as such. <BR>
<BR>

<P>
If an expression is marked for being hidden, it will be copied to 
the `hide<A NAME="4379"></A> file'<A NAME="4380"></A>, a storage which is 
either in memory or on file depending on the combined size of all 
expressions being hidden. If this size exceeds the size of the setup 
parameter scratchsize<A NAME="4381"></A> (see <A HREF="#setup">17</A>) the storage will 
be on file. If it is less, the storage will be in memory. An expression 
that has been hidden is not affected by the statements in the modules as 
long as it remains hidden, but it can be used inside other expressions in 
the same way skipped<A NAME="4383"></A> expressions (see 
<A HREF="#substaskip">7.132</A>) or active expressions can be used. In particular all its 
bracket<A NAME="4385"></A> information (see <A HREF="#substabracket">7.11</A>) is retained 
and can be accessed, including possible bracket<A NAME="4387"></A> 
indexing. <BR>
<BR>

<P>
The hide mechanism is particularly useful if an expression is not 
needed for a large number of modules. It has also advantages over the 
storing of global expressions after a .store<A NAME="4389"></A> instruction (see 
<A HREF="#instrstore">4</A>), because the substitution of global expressions is slower 
(name definitions may have changed and have to be checked) and also a 
possible bracket index is not maintained by the .store instruction. 
<BR>
<BR>

<P>
Expressions can be returned from a hidden status into active 
expressions with the unhide<A NAME="4392"></A> statement (see 
<A HREF="#substaunhide">7.157</A>). One might want to consult the nhide<A NAME="4394"></A> 
statement (<A HREF="#substahide">7.67</A>) as well. <BR>
<BR>

<P>
When an expression is marked to be hidden it will remain just 
marked until execution starts in the current module. When it is the turn of 
the expression to be executed, it is copied to the hide file instead. 
<BR>
<BR>

<P>
Note that a .store instruction will simultaneously remove all 
expressions from the hide system. <BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008680000000000000000"></A>
<A ID="substaidentify"></A>
<BR>
identify
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">id[entify] [<SPAN style="font-family:monospace">&lt;</SPAN>options<SPAN style="font-family:monospace">&gt;</SPAN>] <SPAN style="font-family:monospace">&lt;</SPAN>pattern<SPAN style="font-family:monospace">&gt;</SPAN> = <SPAN style="font-family:monospace">&lt;</SPAN>expression<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">also (<A HREF="#substaalso">7.2</A>),
              idnew (<A HREF="#substaidnew">7.69</A>),
              idold (<A HREF="#substaidold">7.70</A>)</TD>
</TR>
</TABLE>
<BR>
<BR>

<P>
The statement<A NAME="4414"></A><A NAME="4415"></A> tries to match the 
pattern<A NAME="4416"></A>. If the pattern matches one or more times, it will 
be replaced by the expression in the r.h.s. taking the possible 
wildcard<A NAME="4417"></A> substitutions into account. For the description of 
the patterns, see chapter <A HREF="#pattern">5</A>.

<P>
The options are <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>multi<A NAME="8334"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>This option is for combinations of symbols and dotproducts only 
and it does not use wildcard powers. FORM determines how many times the 
pattern fits in one pattern matching action. Then the r.h.s. is substituted 
to that power. It is the default for these kinds of patterns.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>many<A NAME="8348"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>This is the default for patterns that contain other objects 
than symbols and dotproducts. The pattern is matched and taken out. Then 
FORM tries again to match the pattern in the remainder of the term. This 
is repeated until there is no further match. Then for each match the r.h.s. 
is substituted (with its own wildcard substitutions).</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>select<A NAME="8362"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>This option should be followed by one or more sets<A NAME="8369"></A>. After 
the sets the pattern can be specified. The pattern will only be substituted 
if none of the objects mentioned in the sets will be left after the pattern 
has been taken out. This holds only for objects 'at ground level'; i.e. the 
pattern matcher will not look inside function arguments for this. Note 
that this is a special case of the option 'only'.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>once<A NAME="8376"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>The pattern is matched only once, even if it occurs more than once 
in the term. The first match that FORM encounters is taken. When wildcards 
are involved, this may depend on the order of declaration of variables. It 
could also be installation dependent. Also the setting of 
properorder<A NAME="8383"></A> (see <A HREF="#substaon">7.107</A> and <A HREF="#substaoff">7.106</A>) 
could be relevant. Try to write programs in such a way that the outcome 
does not depend on which match is taken.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>only<A NAME="8393"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>The pattern will match only if there is an exact match in 
the powers of the symbols and dotproducts present.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>ifmatch<SPAN CLASS="MATH"><IMG STYLE="height: 1.75ex; vertical-align: -0.30ex; " SRC="img53.svg"
 ALT="$-\!\!&gt;$"></SPAN><A NAME="8406"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>This option should be followed by the name (or number) of a 
label<A NAME="8413"></A>. If the pattern matches, the replacement will be made 
after which the execution continues at the label.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>ifnomatch<SPAN CLASS="MATH"><IMG STYLE="height: 1.75ex; vertical-align: -0.30ex; " SRC="img53.svg"
 ALT="$-\!\!&gt;$"></SPAN><A NAME="8420"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>This option should be followed by the name (or number) of a 
label<A NAME="8427"></A>. If the pattern does not match, 
execution continues at the label.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>disorder<A NAME="8434"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>This option is used for products of 
noncommuting<A NAME="8441"></A> functions<A NAME="8442"></A> or 
tensors<A NAME="8443"></A>. The match will only take place if the 
order of the functions in the match is different from what FORM would have 
made of it if the functions would be commuting<A NAME="8444"></A>. Hence if 
the functions in the term are in the order that FORM would give them if 
they would be commuting (which depends on the order of declaration) there 
will be no match. This can be rather handy when using wildcards as in <SPAN style="font-family:monospace">F(a?)*F(b?)</SPAN>.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>all<A NAME="8454"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>This option is rather special in that it generates all possible 
matches one by one. Normally, when there are many possible matches, FORM 
takes the first one it encounters. In the case of the all option it will 
run through all possible matches and produce all of them. There are however 
severe restrictions. First of all, other options are not allowed 
simultaneously, although ifmatch<SPAN CLASS="MATH"><IMG STYLE="height: 1.75ex; vertical-align: -0.30ex; " SRC="img53.svg"
 ALT="$-\!\!&gt;$"></SPAN> and ifnomatch<SPAN CLASS="MATH"><IMG STYLE="height: 1.75ex; vertical-align: -0.30ex; " SRC="img53.svg"
 ALT="$-\!\!&gt;$"></SPAN> are allowed 
because technically they are no options that concern the pattern matching. 
In addition it is not allowed to be in an idold/also statement, and it 
cannot be followed by such a statement. Most severely: it can have only 
functions in the left hand side. These functions can have all kinds of 
arguments, but outside the functions symbols, vectors, dotproducts etc. are 
not allowed. This is due to the fact that the backtracking when a wildcard 
combination fails, does not include such objects and it is this 
backtracking mechanism that is used to generate all matches. For the 
purpose of the all option tensors and unsubstituted tables count as 
functions. It should also be known that the all option cannot be used in 
the if(match()) construction. It would not make sense there anyway.</TD></TR>
</TABLE>
    <BR>

<P>
Example:
<PRE>
    Vector Q,p1,...,p5,q1,...,q5;
    Cfunction V(s),replace;
    Format 60;
    *   This is a t1 topology:
    L   F = V(Q,p1,p4)*V(p1,p2,p5)*
            V(p2,p3,Q)*V(p3,p4,p5);
    $t = term_;
    id,all,$t*replace_(&lt;p1,p1?&gt;,...,&lt;p5,p5?&gt;) =
         $t*replace(&lt;p1,q1&gt;,...,&lt;p5,q5&gt;);
    Print +s;
    .end

   F =
       + V(Q,p1,p4)*V(Q,p2,p3)*V(p1,p2,p5)*V(p3,p4,p5)*
      replace(p1,q1,p2,q2,p3,q3,p4,q4,p5,q5)
       + V(Q,p1,p4)*V(Q,p2,p3)*V(p1,p2,p5)*V(p3,p4,p5)*
      replace(p2,q1,p1,q2,p4,q3,p3,q4,p5,q5)
       + V(Q,p1,p4)*V(Q,p2,p3)*V(p1,p2,p5)*V(p3,p4,p5)*
      replace(p3,q1,p4,q2,p1,q3,p2,q4,p5,q5)
       + V(Q,p1,p4)*V(Q,p2,p3)*V(p1,p2,p5)*V(p3,p4,p5)*
      replace(p4,q1,p3,q2,p2,q3,p1,q4,p5,q5)
      ;
</PRE>
This program produces all renumberings of the momenta in the t1 topology 
that produce the same topology. The interesting thing here is that one does 
not have to know the topology to produce all topologically equivalent 
terms.

<P>
There are two options in the id,all statement: 
<BR><TABLE   STYLE="width:181;">
<TR><TD>all(n[ormalize])
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>Here the final answer is divided by the number of matches. In the 
example above that would be 4.</TD></TR>
</TABLE>
    <BR>
<TABLE   STYLE="width:181;">
<TR><TD>all(<SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img23.svg"
 ALT="$&lt;$"></SPAN>number<SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img24.svg"
 ALT="$&gt;$"></SPAN>)
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>The number between the parentheses will be the maximum number of 
matches allowed. This means that once this number is reached, no further 
matches are produced.</TD></TR>
</TABLE>
    <BR>
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008690000000000000000"></A>
<A ID="substaidnew"></A>
<BR>
idnew
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">idn[ew] [<SPAN style="font-family:monospace">&lt;</SPAN>options<SPAN style="font-family:monospace">&gt;</SPAN>] <SPAN style="font-family:monospace">&lt;</SPAN>pattern<SPAN style="font-family:monospace">&gt;</SPAN> = <SPAN style="font-family:monospace">&lt;</SPAN>expression<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">identify (<A HREF="#substaidentify">7.68</A>),
              also (<A HREF="#substaalso">7.2</A>),
              idold (<A HREF="#substaidold">7.70</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
This statement<A NAME="4466"></A> and its options are completely 
identical to the regular id<A NAME="4467"></A> or identify<A NAME="4468"></A> statement 
(see <A HREF="#substaidentify">7.68</A>). <BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008700000000000000000"></A>
<A ID="substaidold"></A>
<BR>
idold
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">ido[ld] [<SPAN style="font-family:monospace">&lt;</SPAN>options<SPAN style="font-family:monospace">&gt;</SPAN>] <SPAN style="font-family:monospace">&lt;</SPAN>pattern<SPAN style="font-family:monospace">&gt;</SPAN> = <SPAN style="font-family:monospace">&lt;</SPAN>expression<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">identify (<A HREF="#substaidentify">7.68</A>),
              also (<A HREF="#substaalso">7.2</A>),
              idnew (<A HREF="#substaidnew">7.69</A>)</TD>
</TR>
</TABLE>
<BR>
<BR>

<P>
This statement<A NAME="4486"></A> and its options are completely 
identical to the regular also<A NAME="4487"></A> statement (see <A HREF="#substaalso">7.2</A>). 
The options are described with the id<A NAME="4489"></A> or identify<A NAME="4490"></A> 
statement (see <A HREF="#substaidentify">7.68</A>).
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008710000000000000000"></A>
<A ID="substaif"></A>
<BR>
if
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">if ( <SPAN style="font-family:monospace">&lt;</SPAN>condition<SPAN style="font-family:monospace">&gt;</SPAN> );</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">if ( <SPAN style="font-family:monospace">&lt;</SPAN>condition<SPAN style="font-family:monospace">&gt;</SPAN> ) <SPAN style="font-family:monospace">&lt;</SPAN>executable statement<SPAN style="font-family:monospace">&gt;</SPAN></TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">elseif (<A HREF="#substaelseif">7.41</A>),
              else (<A HREF="#substaelse">7.40</A>),
              endif (<A HREF="#substaendif">7.45</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
Used<A NAME="4508"></A> for executing parts of code only when certain 
conditions<A NAME="4509"></A> are met. Works together with the 
else<A NAME="4510"></A> statement (see <A HREF="#substaelse">7.40</A>), the elseif<A NAME="4512"></A> 
statement (see <A HREF="#substaelseif">7.41</A>) and the endif<A NAME="4514"></A> statement 
(see <A HREF="#substaendif">7.45</A>). There are two versions. In the first the if 
statement must be accompanied by at least an endif statement. In that case 
the statements between the if statement and the endif statement will be 
executed if the condition is met. It is also possible to use elseif and 
else statements to be more flexible. This is done in the same way as in 
almost all computer languages.

<P>
In the second form the if statement does not terminate with a 
semicolon<A NAME="4516"></A>. It is followed by a single regular statement. 
No endif statement should be used. The single statement will be executed if 
the condition is met.

<P>
The condition in the if statement should be enclosed by 
parentheses. Its primary components are:

<P>
<TABLE   STYLE="width:159;">
<TR><TD>count()<A NAME="8492"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Returns an integer power counting value for the current 
term. Should have arguments that come in pairs. The first element of the 
pair is a variable. The second is its integer weight<A NAME="8499"></A>. The 
types of variables that are allowed are symbols, dotproducts, functions, 
tensors, tables and vectors. The weights can be positive as well as 
negative. They have to be short integers (Absolute value <SPAN CLASS="MATH"><IMG STYLE="height: 2.23ex; vertical-align: -0.20ex; " SRC="img54.svg"
 ALT="$&lt; 2^{15}$"></SPAN> on 
32<A NAME="8501"></A> bit computers and <SPAN CLASS="MATH"><IMG STYLE="height: 2.23ex; vertical-align: -0.20ex; " SRC="img55.svg"
 ALT="$&lt; 2^{31}$"></SPAN> on 64<A NAME="8503"></A> bit 
computers). The vectors can have several options appended to their name. 
This is done by putting a + after the name of the vector and have this 
followed by one or more of the following letters:

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">v</TD>
<TD CLASS="LEFT">Loose vectors with an index are taken into account.</TD>
</TR>
<TR><TD CLASS="LEFT">d</TD>
<TD CLASS="LEFT">Vectors inside dotproducts are taken into account.</TD>
</TR>
<TR><TD CLASS="LEFT">f</TD>
<TD CLASS="LEFT">Vectors inside tensors are taken into account.</TD>
</TR>
<TR><TD CLASS="LEFT">?set</TD>
<TD CLASS="LEFT"><TABLE   STYLE="width:499;">
<TR><TD>The set should be a set of functions. Vectors inside 
the functions that are members of the set are taken into account. It is 
assumed that those functions are linear in the given vector</TD></TR>
</TABLE></TD>
</TR>
</TABLE> <BR>

<P>
When no options are specified the result is identical to +vfd.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>match()<A NAME="8518"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>The argument of the match condition can be any left hand 
side of an id statement, including options as once<A NAME="8525"></A>, 
only<A NAME="8526"></A>, multi<A NAME="8527"></A>, many<A NAME="8528"></A> and 
select<A NAME="8529"></A> (see <A HREF="#substaidnew">7.69</A>). The id of the id statement 
should not be included. FORM will invoke the pattern<A NAME="8531"></A> 
matcher and see how many times the pattern matches. This number is 
returned. In the case of once or only this is of course at most one.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>expression()<A NAME="8539"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>The argument(s) of this condition is/are a list of 
expressions. In the case that the current term belongs to any of the given 
expressions the return value is 1. If it does not belong to any of the 
given expressions the return value is 0.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>occurs()<A NAME="8552"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>The argument(s) of this condition is/are a list of 
variables. In the case that any of the variables occurs inside the current 
term (including inside function arguments) the 
return value is 1. Otherwise the return value is zero.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>findloop()<A NAME="8565"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>The arguments are as in the 
replaceloop<A NAME="8572"></A> statement (see <A HREF="#substareplaceloop">7.126</A>) with 
the exception of the outfun which should be omitted. If FORM detects an 
index<A NAME="8574"></A> loop in the current term that fulfils the specified 
conditions the return value is 1. It is 0 otherwise.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>multipleof()<A NAME="8582"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>The argument should be a positive integer. This object is 
to be compared with a number (could be obtained from a condition) and if 
this number is an integer multiple of the argument there will be a match. 
If should be obvious that such a compare only makes sense for the == and != 
operators.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD><SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img23.svg"
 ALT="$&lt;$"></SPAN>integer<SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img24.svg"
 ALT="$&gt;$"></SPAN>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>To be compared either with another number, the result of a 
condition or a multipleof object.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>coefficient<A NAME="8607"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Represents the coefficient of the current term.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>$-variable
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Will be evaluated at runtime when the if statement is 
encountered. Should evaluate into a numerical value. If it does not, an 
error will result.</TD></TR>
</TABLE>
    <BR>

<P>
All the above primary components result in numerical objects. 
Such objects can be compared to each other in structures of the type 
<SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img23.svg"
 ALT="$&lt;$"></SPAN>obj1<SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img24.svg"
 ALT="$&gt;$"></SPAN> <SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img23.svg"
 ALT="$&lt;$"></SPAN>operator<SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img24.svg"
 ALT="$&gt;$"></SPAN> <SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img23.svg"
 ALT="$&lt;$"></SPAN>obj2<SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img24.svg"
 ALT="$&gt;$"></SPAN>. The result of such a compare is 
either true (or 1) or false (or 0). The operators are:

<P>
<TABLE   STYLE="width:91;">
<TR><TD><SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img24.svg"
 ALT="$&gt;$"></SPAN>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:635;">
<TR><TD>Results in true if object 1 is greater than object 2.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:91;">
<TR><TD><SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img23.svg"
 ALT="$&lt;$"></SPAN>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:635;">
<TR><TD>Results in true if object 1 is less than object 2.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:91;">
<TR><TD><SPAN CLASS="MATH"><IMG STYLE="height: 1.06ex; vertical-align: -0.11ex; " SRC="img34.svg"
 ALT="$=$"></SPAN>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:635;">
<TR><TD>Same as ==.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:91;">
<TR><TD><SPAN CLASS="MATH"><IMG STYLE="height: 1.06ex; vertical-align: -0.11ex; " SRC="img33.svg"
 ALT="$==$"></SPAN>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:635;">
<TR><TD>Results in true if both objects have the same value.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:91;">
<TR><TD><SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img31.svg"
 ALT="$&gt;=$"></SPAN>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:635;">
<TR><TD>Results in true if object 1 is greater than or equal to object 2.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:91;">
<TR><TD><SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img32.svg"
 ALT="$&lt;=$"></SPAN>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:635;">
<TR><TD>Results in true if object 1 is less than or equal to object 2.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:91;">
<TR><TD><SPAN CLASS="MATH"><IMG STYLE="height: 1.82ex; vertical-align: -0.11ex; " SRC="img35.svg"
 ALT="$!=$"></SPAN>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:635;">
<TR><TD>Results in true if object 1 does not have the same value 
as object 2.</TD></TR>
</TABLE>
    <BR>

<P>
If the condition for true is not met, false is returned. Several of the 
above compares can be combined with logical operators. For this it is 
necessary to enclose the above compares within parentheses. This forces 
FORM to interpret the hierarchy<A NAME="4601"></A> of the operators 
properly. The extra logical operators are

<P>
<TABLE   STYLE="width:91;">
<TR><TD><SPAN CLASS="MATH"><IMG STYLE="height: 2.53ex; vertical-align: -0.69ex; " SRC="img37.svg"
 ALT="$\vert\vert$"></SPAN>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:635;">
<TR><TD>The or operation. True if at least one of the objects 1 
and 2 is true (or nonzero). False or zero if both are false or zero.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:91;">
<TR><TD><SPAN CLASS="MATH"><IMG STYLE="height: 1.82ex; vertical-align: -0.11ex; " SRC="img36.svg"
 ALT="$\&amp;\&amp;$"></SPAN>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:635;">
<TR><TD>The and operation. True if both the objects 1 
and 2 are true (or nonzero). False or zero if at least one is false or zero.</TD></TR>
</TABLE>
    <BR>

<P>
Example:
<PRE>
    if ( ( match(f(1,x)*g(?a)) &amp;&amp; ( count(x,1,v+d,1) == 3 ) )
         || ( expression(F1,F2) == 0 ) );
        some statements
    endif;
    if ( ( ( match(f(1,x)*g(?a)) == 0 ) &amp;&amp; ( count(x,1,v+d,1) == 3 ) )
         || expression(F1,F2) );
        some statements
    endif;
</PRE>
We see that <code>match()</code> is equivalent to <code>( match() != 0 )</code> and 
something similar for <code>expression()</code>. This shorthand<A NAME="4612"></A> 
notation can make a program slightly more readable.

<P>
<B>Warning! </B> The if-statement knows only logical values as the result of 
operations. Hence the answer to anything that contains parenthesis (which 
counts as the evaluation of an expression) is either true (1) or false (0). 
Hence the object (5) evaluates to true. <BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008720000000000000000"></A>
<A ID="substaifmatch"></A>
<BR>
ifmatch
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">ifmatch<SPAN CLASS="MATH"><IMG STYLE="height: 1.75ex; vertical-align: -0.30ex; " SRC="img53.svg"
 ALT="$-\!\!&gt;$"></SPAN> <SPAN style="font-family:monospace">&lt;</SPAN>label<SPAN style="font-family:monospace">&gt;</SPAN> <SPAN style="font-family:monospace">&lt;</SPAN>pattern<SPAN style="font-family:monospace">&gt;</SPAN> = <SPAN style="font-family:monospace">&lt;</SPAN>expression<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">identify (<A HREF="#substaidentify">7.68</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
This statement<A NAME="4628"></A> is identical to the ifmatch option 
of the id statement (see <A HREF="#substaidentify">7.68</A>). Hence
<PRE>
   ifmatch-&gt; ....
</PRE>
is just a shorthand notation for
<PRE>
   id ifmatch-&gt; ....
</PRE>
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008730000000000000000"></A>
<A ID="substaifnomatch"></A>
<BR>
ifnomatch
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">ifnomatch<SPAN CLASS="MATH"><IMG STYLE="height: 1.75ex; vertical-align: -0.30ex; " SRC="img53.svg"
 ALT="$-\!\!&gt;$"></SPAN> <SPAN style="font-family:monospace">&lt;</SPAN>label<SPAN style="font-family:monospace">&gt;</SPAN> <SPAN style="font-family:monospace">&lt;</SPAN>pattern<SPAN style="font-family:monospace">&gt;</SPAN> = <SPAN style="font-family:monospace">&lt;</SPAN>expression<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">identify (<A HREF="#substaidentify">7.68</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
This statement<A NAME="4648"></A> is identical to the ifnomatch option 
of the id statement (see <A HREF="#substaidentify">7.68</A>). Hence
<PRE>
   ifnomatch-&gt; ....
</PRE>
is just a shorthand notation for
<PRE>
   id ifnomatch-&gt; ....
</PRE>
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008740000000000000000"></A>
<A ID="substaindex"></A>
<BR>
index, indices
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Declaration statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">i[ndex] <SPAN style="font-family:monospace">&lt;</SPAN>list of indices to be declared<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">i[ndices] <SPAN style="font-family:monospace">&lt;</SPAN>list of indices to be declared<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">dimension (<A HREF="#substadimension">7.33</A>),
              fixindex (<A HREF="#substafixindex">7.59</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
Declares one or more indices<A NAME="4667"></A><A NAME="4668"></A>. In the 
declaration of an index one can specify its dimension<A NAME="4669"></A>. 
This is done by appending one or two options to the name of the index to be 
declared:
<BR>
<BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>name=dim
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>The dimension is either a nonnegative integer or a 
previously declared symbol. If the dimension is zero<A NAME="8747"></A> 
this means that no dimension is attached to the index. The consequence is 
that the index cannot be summed over and index contractions are not 
performed for this index. If no dimension is specified the default 
dimension will be assumed (see the dimension statement 
<A HREF="#substadimension">7.33</A>).</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>name=dim:ext
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>The dimension is a symbol as above. Ext is an extra 
symbol which indicates the value of dim-4. This option is useful when 
traces over gamma matrices are considered (see <A HREF="#substatrace">7.152</A> and 
<A HREF="#substatracen">7.153</A>).</TD></TR>
</TABLE>
    <BR> <BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008750000000000000000"></A>
<A ID="substainexpression"></A>
<BR>
inexpression
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">inexpression,name(s) of expression(s);</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">endinexpression&nbsp;(<A HREF="#substaendinexpression">7.46</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
The combination<A NAME="4689"></A>
<PRE>
   InExpression,expr;
       Statements;
   EndInExpression;
</PRE>
is a more readable version of the construction
<PRE>
   if ( expression(expr) );
       Statements;
   endif;
</PRE>
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008760000000000000000"></A>
<A ID="substainparallel"></A>
<BR>
inparallel
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Specification statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">inparallel;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">inparallel <SPAN style="font-family:monospace">&lt;</SPAN>list of expressions<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">NotInParallel (<A HREF="#substanotinparallel">7.98</A>), 
     ModuleOption (<A HREF="#substamoduleoption">7.89</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
This statement is only active in the context of 
TFORM<A NAME="4705"></A>. It causes 
(small) expressions to be executed side by side. Normally the terms of 
expressions are distributed over the processors and the expressions are 
executed one by one. This isn't very efficient for small expressions 
because there is a certain amount of overhead. When there are many small 
expressions, this statement can cause each expression to be executed by its 
own processor. A consequence is that the expressions now can finish in a 
semi-random order and hence may end up in the output in a order that is 
different from when this statement isn't used. The proper order is restored 
in the first module that comes after and that doesn't use this option. One 
should be careful using this statement for big expressions, because in that 
case the sorting may need sort files and the output may temporarily need 
scratch files and the simultaneous use of many files can slow execution 
down significantly.

<P>
In the case that no expressions are mentioned, all active 
expressions will be affected. When there is a list of expressions, only 
those mentioned will be affected, provided they are active. Several of 
these statements will work cumulatively. This statement doesn't affect 
expressions that are still to be defined inside the current module. If it 
is needed to affect such expressions inside the current module, one should 
use the InParallel option of the 
ModuleOption&nbsp;<A HREF="#substamoduleoption">7.89</A><A NAME="4707"></A> 
statement. This statement works independently of the `On 
Parallel;'&nbsp;<A HREF="#substaon">7.107</A> and `Off Parallel;'&nbsp;<A HREF="#substaoff">7.106</A> statements.
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008770000000000000000"></A>
<A ID="substainside"></A>
<BR>
inside
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">inside <SPAN style="font-family:monospace">&lt;</SPAN>list of $-variables<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">endinside (<A HREF="#substaendinside">7.47</A>) and the chapter on $-variables 
(<A HREF="#dollars">6</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
works<A NAME="4721"></A> a bit like the argument<A NAME="4722"></A> 
statement (see <A HREF="#substaargument">7.9</A>) but with 
$-variables<A NAME="4724"></A> instead of with functions. An inside 
statement should be paired with an endinside<A NAME="4725"></A> statement 
(see <A HREF="#substaendinside">7.47</A>) inside the same module. The statements 
in-between will then be executed on the contents of the $-variables that 
are mentioned. One should pay some attention to the order of the action. 
The $-variables are treated sequentially. Hence, after the first one has 
been treated its contents are substituted by the new value. Then the second 
one is treated. If it uses the contents of the first variable, it will use 
the new value. If the first variable uses the contents of the second 
variable it will use its old value. Redefining any of the listed 
$-variables in the range of the `inside-environment' is very dangerous. It 
is not specified what FORM will do. Most likely it will be 
unpleasant<A NAME="4727"></A>. 
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008780000000000000000"></A>
<A ID="substainsidefirst"></A>
<BR>
insidefirst
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Declaration statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">insidefirst <SPAN style="font-family:monospace">&lt;</SPAN>on/off<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">on (<A HREF="#substaon">7.107</A>), off (<A HREF="#substaoff">7.106</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
This statement<A NAME="4739"></A> is obsolete<A NAME="4740"></A>. 
The user should try to use the insidefirst option of the on (see 
<A HREF="#substaon">7.107</A>) or the off (see <A HREF="#substaoff">7.106</A>) statements. <BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008790000000000000000"></A>
<A ID="substaintohide"></A>
<BR>
intohide
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Specification statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">intohide;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">intohide <SPAN style="font-family:monospace">&lt;</SPAN>list of expressions<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">hide (<A HREF="#substahide">7.67</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
In the first variety this statement marks all currently active 
expressions for being put in hidden<A NAME="4753"></A> storage at the end of the 
module, after it has been processed. In the second variety it marks only 
the specified active<A NAME="4754"></A> expressions as such. 
<BR>
<BR>

<P>
The difference with the hide (<A HREF="#substahide">7.67</A>) statement is 
that in the hide statement the expression is copied immediately into the 
hide system and it will not be processed in the current module, while in 
the intohide statement the expression is first processed and its final 
output in this module is sent to the hide system rather than to the regular 
scratch system. The effect is the same as not putting the intohide 
statement in the current module and putting a hide statement in the next, 
but it saves one copy operation and it is possibly a bit more economical 
with the disk space.
<BR>
<BR>

<P>
Note that a .store instruction will simultaneously remove all 
expressions from the hide system. <BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008800000000000000000"></A>
<A ID="substakeep"></A>
<BR>
keep
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Specification statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">keep brackets;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">bracket (<A HREF="#substabracket">7.11</A>), antibracket 
     (<A HREF="#substaabrackets">7.1</A>) and the chapter on brackets 
     (<A HREF="#brackets">9</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
The effect<A NAME="4768"></A><A NAME="4769"></A><A NAME="4770"></A> 
of this statement is that during execution of the current module the 
contents of the brackets are not considered. The statements only act on the 
`outside' of the brackets. Only when the terms are considered finished and 
are ready for the sorting are they multiplied by the contents of the 
brackets. At times this can save much computer time as complicated pattern 
matching and multiplications of function arguments with large fractions 
have to be done only once, rather than for each complete term separately 
(assuming that each bracket contains a large number of terms).

<P>
There can be some nasty side effects. Assume an expression like:
<PRE>
    F = f(i1,x)*(g(i1,y)+g(i1,z));
    B  f;
    .sort
    Keep Brackets;
    sum i1;
</PRE>
the result will be
<PRE>
    F = f(N1_?,x)*g(i1,y)+f(N1_?,x)*g(i1,z);
</PRE>
because at the moment of summing over i1 FORM is not looking inside the 
brackets and hence it never sees the second occurrence of i1. There are 
some beneficial applications of the keep statement in the 
`mincer'<A NAME="4775"></A> package that comes with the FORM distribution. In 
this package the most costly step was made faster by a significant factor 
(depending on the problem) due to the keep brackets statement. 
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008810000000000000000"></A>
<A ID="substalabel"></A>
<BR>
label
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">la[bel] <SPAN style="font-family:monospace">&lt;</SPAN>name of label<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">goto (<A HREF="#substagoto">7.66</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
Places a label<A NAME="4786"></A> at the current location. The name of 
the label can be any name or positive number. Control can be transfered to the 
position of the label by a goto<A NAME="4787"></A> statement (see 
<A HREF="#substagoto">7.66</A>) or the ifmatch<A NAME="4789"></A> option of an id statement 
(see <A HREF="#substaidentify">7.68</A>). The only condition is that the goto statement 
and the label must be inside the same module. Once the module is terminated 
all existing labels are forgotten. This means that in a later module a 
label with the same name can be used again (this may not improve 
readability though but it is a good thing when third party libraries are 
used). <BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008820000000000000000"></A>
<A ID="substalfactorized"></A>
<BR>
lfactorized
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Definition statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">l[ocal]factorized <SPAN style="font-family:monospace">&lt;</SPAN>name<SPAN style="font-family:monospace">&gt;</SPAN> = <SPAN style="font-family:monospace">&lt;</SPAN>expression<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">the chapter on polynomials&nbsp;<A HREF="#polynomials">11</A> and the 
factorize statement&nbsp;<A HREF="#substafactorize">7.56</A>.</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
Used to define a local<A NAME="4804"></A> expression in factorized 
notation and keep it that way. The factors are recognized by multiplication 
and division signs at lowest bracket level. For the rest the expression is 
treated as a regular local expression. Example:
<PRE>
    Symbols x,y,z;
    LocalFactorized F1 = 3*(x+y)*(y+z)*((x+z)*(2*x+1));
    LocalFactorized F2 = 3*(x+y)*(y+z)+((x+z)*(2*x+1));
    Print;
    .end

   F1 =
         ( 3 )
       * ( y + x )
       * ( z + y )
       * ( z + x + 2*x*z + 2*x^2 );

   F2 =
         ( z + 3*y*z + 3*y^2 + x + 5*x*z + 3*x*y + 2*x^2 );
</PRE>
As one can see in the second expression, the plus at ground level 
makes that there is only one factor. In the first expression the last 
factor is seen as a single factor and not two factor2 because of the extra 
parentheses. Only parentheses at ground level are used to recognize 
factors. If one needs those factors anyway, one should either leave away 
those parentheses or use an extra Factorize statement to have FORM 
refactorize the expression.
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008830000000000000000"></A>
<A ID="substaload"></A>
<BR>
load
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Declaration statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">loa[d] <SPAN style="font-family:monospace">&lt;</SPAN>filename<SPAN style="font-family:monospace">&gt;</SPAN> [<SPAN style="font-family:monospace">&lt;</SPAN>list of expressions<SPAN style="font-family:monospace">&gt;</SPAN>];</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">save (<A HREF="#substasave">7.127</A>), delete (<A HREF="#substadelete">7.31</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
Loads<A NAME="4820"></A> a previously saved<A NAME="4821"></A> 
file<A NAME="4822"></A> (see <A HREF="#substasave">7.127</A>). If no expressions are 
specified all expressions in the file are put in the storage 
file<A NAME="4824"></A> and obtain the status of stored global 
expressions. If a list of expressions is specified all those expressions 
are loaded and possible other expressions are ignored. If a specified 
expression is not present, an error will result. If one does not know 
exactly what expressions are present in a file one could load the file 
without a list of expressions, because FORM will list all expressions that 
it encountered. <BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008840000000000000000"></A>
<A ID="substalocal"></A>
<BR>
local
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Definition statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">l[ocal] <SPAN style="font-family:monospace">&lt;</SPAN>name<SPAN style="font-family:monospace">&gt;</SPAN> = <SPAN style="font-family:monospace">&lt;</SPAN>expression<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">l[ocal] <SPAN style="font-family:monospace">&lt;</SPAN>names of expressions<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">global (<A HREF="#substaglobal">7.65</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
Used to define a local<A NAME="4839"></A> expression. A local 
expression is an expression that will be dropped<A NAME="4840"></A> when a 
.store<A NAME="4841"></A> instruction is encountered. If this is not what is 
intended one should use global<A NAME="4842"></A> expressions (see 
<A HREF="#substaglobal">7.65</A>). The statement can also be used to change the status of 
a global expression into that of a local expression. In that case there is 
no = sign and no right hand side. <BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008850000000000000000"></A>
<A ID="substamakeinteger"></A>
<BR>
makeinteger
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">makeinteger [<SPAN style="font-family:monospace">&lt;</SPAN>argument specifications<SPAN style="font-family:monospace">&gt;</SPAN>]</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT"><code>{</code><SPAN style="font-family:monospace">&lt;</SPAN>name of function/set<SPAN style="font-family:monospace">&gt;</SPAN>
[<SPAN style="font-family:monospace">&lt;</SPAN>argument specifications<SPAN style="font-family:monospace">&gt;</SPAN>]<code>}</code>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">normalize (<A HREF="#substanormalize">7.97</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
Normalizes<A NAME="4858"></A> the indicated 
argument<A NAME="4859"></A> of the indicated functions(s) in such a way that 
all terms in this argument have integer 
coefficients<A NAME="4860"></A> with a their greatest common 
divider being one. This still leaves the possibility that the first term of 
this argument may be negative. If this is not desired one can first 
normalize<A NAME="4861"></A> the argument and then make its coefficients 
integer. The overall factor that is needed to make the coefficients like 
described is taken from the overall factor of the complete term. Example:
<PRE>
    S   a,b,c;
    CF  f;
    L   F = f(22/3*a+14/5*b+18/7*c);
    MakeInteger,f;
    Print +f;
    .end
   F =
      2/105*f(135*c + 147*b + 385*a);
</PRE>

<P>
Note that this feature can be used to make outputs look much more 
friendly. It can be used in combination with the 
AntiBracket<A NAME="4864"></A> statement (<A HREF="#substaabrackets">7.1</A>) and the 
function dum_<A NAME="4866"></A> (<A HREF="#fundum">8.14</A>) to imitate a smart extra level 
of brackets and make outputs shorter.

<P>
It is possible to introduce a scale factor when extracting the coefficient 
and multiplying it into the complete term.

<P>
<TABLE   STYLE="width:181;">
<TR><TD>MakeInteger,<SPAN CLASS="MATH"><IMG STYLE="height: 1.59ex; vertical-align: -0.20ex; " SRC="img56.svg"
 ALT="$\wedge&lt;n&gt;$"></SPAN>,f;
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>The number n must be an integer (may be negative) and if 
the coefficient that is extracted is c the whole term is multiplied by the 
factor <SPAN CLASS="MATH"><IMG STYLE="height: 1.78ex; vertical-align: -0.11ex; " SRC="img57.svg"
 ALT="$c^n$"></SPAN>.</TD></TR>
</TABLE>
    <BR>
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008860000000000000000"></A>
<A ID="substamany"></A>
<BR>
many
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">many <SPAN style="font-family:monospace">&lt;</SPAN>pattern<SPAN style="font-family:monospace">&gt;</SPAN> = <SPAN style="font-family:monospace">&lt;</SPAN>expression<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">identify (<A HREF="#substaidentify">7.68</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
This statement<A NAME="4884"></A> is identical to the many option of the 
id<A NAME="4885"></A> statement (see <A HREF="#substaidentify">7.68</A>). Hence
<PRE>
   many ....
</PRE>
is just a shorthand notation for
<PRE>
   id many ....
</PRE>
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008870000000000000000"></A>
<A ID="substamerge"></A>
<BR>
merge
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">merge,functionname;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">merge,once,functionname;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">shuffle (<A HREF="#substashuffle">7.131</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
This statement is exactly the same as the shuffle<A NAME="4899"></A> 
statement (see <A HREF="#substashuffle">7.131</A>).
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008880000000000000000"></A>
<A ID="substametric"></A>
<BR>
metric
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Declaration statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">metric <SPAN style="font-family:monospace">&lt;</SPAN>option<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
</TABLE>

<P></P>

<P>
Remark: statement<A NAME="4909"></A> is inactive<A NAME="4910"></A>. 
Should have no effect.
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008890000000000000000"></A>
<A ID="substamoduleoption"></A>
<BR>
moduleoption
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Module control statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">moduleoption <SPAN style="font-family:monospace">&lt;</SPAN>option<SPAN style="font-family:monospace">&gt;</SPAN>[,<SPAN style="font-family:monospace">&lt;</SPAN>value<SPAN style="font-family:monospace">&gt;</SPAN>];</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">polyfun (<A HREF="#substapolyfun">7.110</A>),
              processbucketsize (<A HREF="#substaprocessbucketsize">7.116</A>),
              dollar variables (<A HREF="#pardollars">6.1</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
Used<A NAME="4925"></A> to set a mode for just the current 
module. It overrides the normal setting and will revert to this normal 
setting after this module. The settings are:

<P>
<TABLE   STYLE="width:159;">
<TR><TD>parallel<A NAME="8786"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Allows parallel<A NAME="8793"></A> execution of the current module if all 
other conditions are right. This is the default.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>noparallel<A NAME="8800"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Vetoes parallel<A NAME="8807"></A> execution of the current module.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>inparallel<A NAME="8814"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>This option is more or less equivalent to the 
InParallel&nbsp;<A HREF="#substainparallel">7.76</A> statement. The difference is that because 
this statement comes at the end of the module, its effects include also the 
expressions that have been defined inside the current module. This is not 
the case for the InParallel statement. The InParallel option can be 
followed by the names of expressions. If no such names are present, all 
active expressions are affected. Otherwise only the expressions that are 
mentioned are affected. Once this option is mentioned no more options can 
be used inside the same ModuleOption statement. This is to avoid potential 
confusion that could arise when expressions are used with a name identical 
to the name of one of the options.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>notinparallel<A NAME="8828"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>This option is more or less equivalent to the 
NotInParallel&nbsp;<A HREF="#substanotinparallel">7.98</A> statement. The difference is that 
because this statement comes at the end of the module, its effects include 
also the expressions that have been defined inside the current module. This 
is not the case for the NotInParallel statement. The NotInParallel option 
can be followed by the names of expressions. If no such names are present, 
all active expressions are affected. Otherwise only the expressions that 
are mentioned are affected. Once this option is mentioned no more options 
can be used inside the same ModuleOption statement. This is to avoid 
potential confusion that could arise when expressions are used with a name 
identical to the name of one of the options.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>polyfun<A NAME="8842"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Possibly followed by the name of a 
`polyfun'<A NAME="8849"></A>. Is similar to the polyfun statement (see 
<A HREF="#substapolyfun">7.110</A>) but only valid for the current module.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>polyratfun<A NAME="8857"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Possibly followed by the name of a 
`polyratfun'<A NAME="8864"></A>. Is similar to the polyfun statement (see 
<A HREF="#substapolyratfun">7.111</A>) but only valid for the current module. If there is 
second name, it refers to the inverse polyratfun. More complicated options 
of the polyratfun statement cannot be used here.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>processbucketsize<A NAME="8872"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Followed by a number. Similar to the 
processbucketsize<A NAME="8879"></A> 
statement (see <A HREF="#substaprocessbucketsize">7.116</A>) but only valid for the current 
module.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>local<A NAME="8887"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Should be followed by a list of $-variables. Indicates 
that the contents of the indicated $-variables<A NAME="8894"></A> are not 
relevant once the module has been finished and neither is the term by term 
order in which the $-variables obtain their value. In practise each 
processor<A NAME="8895"></A>/thread<A NAME="8896"></A> will work with its own copy 
of this variable.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>maximum<A NAME="8903"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Should be followed by a list of 
$-variables<A NAME="8910"></A>. Indicates that of the contents of the 
indicated $-variables the maximum is the only thing that is relevant once 
the module has been finished. The term by term order in which the 
$-variables obtain their value is not relevant.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>minimum<A NAME="8917"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Should be followed by a list of 
$-variables<A NAME="8924"></A>. Indicates that of the contents of the 
indicated $-variables the minimum is the only thing that is relevant once 
the module has been finished. The term by term order in which the 
$-variables obtain their value is not relevant.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>sum<A NAME="8931"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Should be followed by a list of 
$-variables<A NAME="8938"></A>. Indicates that the indicated $-variables 
are representing a sum. The term by term order in which the $-variables 
obtain their value is not relevant.</TD></TR>
</TABLE>
    <BR>

<P>
The options `local', `maximum', `minimum' and `sum' are for 
parallel versions of FORM. The presence of $-variables can be a problem 
when the order of processing of the terms is not well defined. These 
options tell FORM what these $-variables are used for. In the above 
cases FORM can take the appropriate action when gathering information 
from the various processors. This will allow
parallel<A NAME="4975"></A> execution of the current module. If
$-variables are used in a module and they are defined on a term by term
basis, the normal action of FORM will be to veto parallel execution unless
it is clear that no confusion can occur. See also chapter <A HREF="#parallel">18</A> on
the parallel version and section <A HREF="#pardollars">6.1</A> on the dollar variables.
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008900000000000000000"></A>
<A ID="substamodulus"></A>
<BR>
modulus
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Declaration statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">m[odulus] [option(s)] <SPAN style="font-family:monospace">&lt;</SPAN>value<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
Defines all calculus to be modulus<A NAME="4987"></A> the given 
integer value, provided this number is positive.

<P>
The modulus calculus extends itself to 
fractions<A NAME="4988"></A>. This means that if the value is not a prime 
number division by zero could result. It is the responsibility of the user 
to avoid such problems.

<P>
When the value in the modulus statement is either 0 or 1 the 
statement would be meaningless. It is used as a signal to FORM that modulus 
calculus should be switched off again.

<P>
The options are
<DL>
<DT><STRONG>NoFunctions</STRONG></DT>
<DD>Modulus calculus is not performed inside function 
arguments.
</DD>
<DT><STRONG>AlsoFunctions</STRONG></DT>
<DD>Modulus calculus is also performed inside function 
arguments.
</DD>
<DT><STRONG>CoefficientsOnly</STRONG></DT>
<DD>Modulus calculus is neither performed inside function 
arguments nor on powers of symbols.
</DD>
<DT><STRONG>PlusMin</STRONG></DT>
<DD>The values of numbers are reduced to the range 
<SPAN CLASS="MATH"><IMG STYLE="height: 2.53ex; vertical-align: -0.69ex; " SRC="img58.svg"
 ALT="$(-value+1)/2$"></SPAN> to <SPAN CLASS="MATH"><IMG STYLE="height: 2.53ex; vertical-align: -0.69ex; " SRC="img59.svg"
 ALT="$(value-1)/2$"></SPAN>.
</DD>
<DT><STRONG>Positive</STRONG></DT>
<DD>The values of numbers are reduced to the range <SPAN CLASS="MATH"><IMG STYLE="height: 1.70ex; vertical-align: -0.11ex; " SRC="img60.svg"
 ALT="$0$"></SPAN> to 
<SPAN CLASS="MATH"><IMG STYLE="height: 2.01ex; vertical-align: -0.30ex; " SRC="img61.svg"
 ALT="$value-1$"></SPAN>.
</DD>
<DT><STRONG>NoDollars</STRONG></DT>
<DD>The modulus calculus is not performed inside dollar 
variables.
</DD>
<DT><STRONG>AlsoDollars</STRONG></DT>
<DD>The modulus calculus is performed also inside dollar 
expressions.
</DD>
<DT><STRONG>InverseTable</STRONG></DT>
<DD>To speed up calculations all inverses are computed by 
means of a table. If the modulus value is very big, this table may be too 
big for the memory. That would result in an error message.
</DD>
<DT><STRONG>NoInverseTable</STRONG></DT>
<DD>No Table of Inverses is constructed. They are 
calculated whenever needed.
</DD>
<DT><STRONG>AlsoPowers</STRONG></DT>
<DD>Reduction is also used on powers of symbols with the 
relation <SPAN CLASS="MATH"><IMG STYLE="height: 1.82ex; vertical-align: -0.11ex; " SRC="img62.svg"
 ALT="$x^mod = x$"></SPAN> if mod is the given value
</DD>
<DT><STRONG>NoPowers</STRONG></DT>
<DD>No reduction on powers is done.
</DD>
<DT><STRONG>PrintPowersOf</STRONG></DT>
<DD>The proper syntax is here printpowersof(generator) in 
which generator is supposed to be a generator for calculus modulus the 
given value, which means that all numbers will be written as a power of the 
generator. If the number turns out not to be a proper generator an error 
will be given. Note that finding the powers is done by means of the 
construction of a table. Hence, if the modulus value is very big the table 
might not fit inside memory. This will result in an error message.
</DD>
</DL>
The default mode is NoFunctions, Positive, NoInverseTable, NoDollars, 
NoPowers.

<P>
The current syntax (version 4.0 and later) differs slightly from the 
previous syntax. As however there were many bugs in the old implementation 
we suspect that a slight change of the options does not inconvenience any 
many users.

<P>

<H1><A ID="SECTION008910000000000000000"></A>
<A ID="substamulti"></A>
<BR>
multi
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">multi <SPAN style="font-family:monospace">&lt;</SPAN>pattern<SPAN style="font-family:monospace">&gt;</SPAN> = <SPAN style="font-family:monospace">&lt;</SPAN>expression<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">identify (<A HREF="#substaidentify">7.68</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
This statement is identical to the multi<A NAME="5002"></A> option of 
the id<A NAME="5003"></A> statement (see <A HREF="#substaidentify">7.68</A>). Hence
<PRE>
   multi ....
</PRE>
is just a shorthand notation for
<PRE>
   id multi ....
</PRE>
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008920000000000000000"></A>
<A ID="substamultiply"></A>
<BR>
multiply
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">mu[ltiply] [<SPAN style="font-family:monospace">&lt;</SPAN>option<SPAN style="font-family:monospace">&gt;</SPAN>] <SPAN style="font-family:monospace">&lt;</SPAN>expression<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
Statement multiplies<A NAME="5020"></A> all terms by the given 
expression. It is advisable to use the options when noncommuting variables 
are involved. They are:
<BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>left<A NAME="8950"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>Multiplication is from the left.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>right<A NAME="8963"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>Multiplication is from the right.</TD></TR>
</TABLE>
    <BR>

<P>
There is no guarantee<A NAME="5026"></A> as to what the default is 
with respect to multiplication from the left or from the right. It is up to 
FORM to decide what it considers to be most efficient when neither 
option is present. <BR>
<BR>

<P>
Note that one should not abbreviate this command to `multi', 
because there is a separate multi<A NAME="5029"></A> command (see 
<A HREF="#substamulti">7.91</A>). <BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008930000000000000000"></A>
<A ID="substandrop"></A>
<BR>
ndrop
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Specification statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">ndrop;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">ndrop <SPAN style="font-family:monospace">&lt;</SPAN>list of expressions<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">drop (<A HREF="#substadrop">7.37</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
In the first variety<A NAME="5041"></A> this statement cancels all 
drop<A NAME="5042"></A> plans. This means that all expressions scheduled for being 
dropped will be restored to their previous status of local or global 
expressions. In the second variety this happens only to the expressions 
that are specified. Example:
<PRE>
   Drop;
   Ndrop F1,F2;
</PRE>
This drops all expressions, except for the expressions <code>F1</code> and 
<code>F2</code>. <BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008940000000000000000"></A>
<A ID="substanfactorize"></A>
<BR>
nfactorize
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Output control statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">nfactorize <code>{</code><SPAN style="font-family:monospace">&lt;</SPAN>name of expression(s)<SPAN style="font-family:monospace">&gt;</SPAN><code>}</code>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">the chapter on polynomials&nbsp;<A HREF="#polynomials">11</A> and 
<A HREF="#substafactorize">7.56</A>.</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
When one uses a factorize (see <A HREF="#substafactorize">7.56</A>) statement 
without arguments all expressions will be marked for factorization. If one 
would like to exclude a few expressions this can be done with the 
NFactorize statement. There should be at least one expression mentioned as 
in:
<PRE>
   Factorize;
   NFactorize expr12,expr29;
</PRE>
One can also use the Factorize statement with a number of expressions after 
which the NFactorize statement can remove some from the list again as in:
<PRE>
   Factorize expr1,...,expr100;
   NFactorize expr12,expr29;
</PRE>

<P>
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008950000000000000000"></A>
<A ID="substanfunctions"></A>
<BR>
nfunctions
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Declaration statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">n[functions] <SPAN style="font-family:monospace">&lt;</SPAN>list of functions to be declared<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">functions (<A HREF="#substafunctions">7.62</A>), cfunctions (<A HREF="#substacfunctions">7.14</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
This statement<A NAME="5072"></A> declares 
noncommuting<A NAME="5073"></A> functions. It is equal to the 
function<A NAME="5074"></A> statement (see <A HREF="#substafunctions">7.62</A>) which has 
the noncommuting property as its default. <BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008960000000000000000"></A>
<A ID="substanhide"></A>
<BR>
nhide
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Specification statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">nhide;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">nhide <SPAN style="font-family:monospace">&lt;</SPAN>list of expressions<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">hide (<A HREF="#substahide">7.67</A>),
              unhide (<A HREF="#substaunhide">7.157</A>),
              nunhide (<A HREF="#substanunhide">7.104</A>),
              pushhide (<A HREF="#substapushhide">7.118</A>),
              pophide (<A HREF="#substapophide">7.112</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
In its first variety<A NAME="5090"></A> this statement undoes all 
hide<A NAME="5091"></A> plans that exist thus far in the current module. In the 
second variety it does this only for the specified active<A NAME="5092"></A> 
expressions. See the hide statement in <A HREF="#substahide">7.67</A>. Example:
<PRE>
   Hide;
   Nhide F1,F2;
</PRE>
Here all active expressions will be transferred to the hide file except for 
the expressions <code>F1</code> and <code>F2</code>. <BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008970000000000000000"></A>
<A ID="substanormalize"></A>
<BR>
normalize
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">normalize options <code>{</code><SPAN style="font-family:monospace">&lt;</SPAN>name of function/set<SPAN style="font-family:monospace">&gt;</SPAN>
         [<SPAN style="font-family:monospace">&lt;</SPAN>argument specifications<SPAN style="font-family:monospace">&gt;</SPAN>]<code>}</code>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">argument (<A HREF="#substaargument">7.9</A>), splitarg 
            (<A HREF="#substasplitarg">7.134</A>), makeinteger (<A HREF="#substamakeinteger">7.85</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
Normalizes<A NAME="5110"></A> the indicated 
arguments<A NAME="5111"></A> of the indicated functions. Normalization means 
that the argument will be multiplied by the inverse of its 
coefficient<A NAME="5112"></A> 
(provided it is not zero). This holds for single term arguments. For 
multiple term arguments the inverse of the coefficient of the first term of 
the argument is used. The options and the argument specifications are as in 
the SplitArg<A NAME="5113"></A> statement (see <A HREF="#substasplitarg">7.134</A>). Under normal 
circumstances the coefficient that is removed from the argument(s) is 
multiplied into the coefficient of the term. This can be avoid with the 
extra option
<code>(0)</code>. Hence

<P>
<TABLE   STYLE="width:181;">
<TR><TD>Normalize,f;
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>changes <SPAN style="font-family:monospace">f(2*x+3*y)</SPAN> into <SPAN style="font-family:monospace">2*f(x+3/2*y)</SPAN> but</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>Normalize,(0),f;
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>changes <SPAN style="font-family:monospace">f(2*x+3*y)</SPAN> into <SPAN style="font-family:monospace">f(x+3/2*y)</SPAN>.</TD></TR>
</TABLE>
    <BR>

<P>
A more flexible way to extract the coefficient of the (first) term is by 
providing a scale factor as in

<P>
<TABLE   STYLE="width:181;">
<TR><TD>Normalize,<SPAN CLASS="MATH"><IMG STYLE="height: 1.59ex; vertical-align: -0.20ex; " SRC="img56.svg"
 ALT="$\wedge&lt;n&gt;$"></SPAN>,f;
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>The number n must be an integer (may be negative) and if 
the coefficient of the first term was c the whole term is multiplied by the 
factor <SPAN CLASS="MATH"><IMG STYLE="height: 1.78ex; vertical-align: -0.11ex; " SRC="img57.svg"
 ALT="$c^n$"></SPAN>.</TD></TR>
</TABLE>
    <BR>
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008980000000000000000"></A>
<A ID="substanotinparallel"></A>
<BR>
notinparallel
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Specification statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">notinparallel;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">notinparallel <SPAN style="font-family:monospace">&lt;</SPAN>list of expressions<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">InParallel (<A HREF="#substainparallel">7.76</A>), 
     ModuleOption (<A HREF="#substamoduleoption">7.89</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
This statement is only active in the context of 
TFORM<A NAME="5140"></A>. It vetoes (small) expressions to be executed side by 
side. For a complete explanation of this type of running one should look at 
the InParallel&nbsp;<A HREF="#substainparallel">7.76</A> statement. Because the default is 
that expressions are executed one by one, the major use of this statement 
is in constructions like:
<PRE>
   InParallel;
   NotInParallel F1,F25;
</PRE>
which would first mark all expressions to be executed in simultaneous mode 
and then make an exception for <SPAN style="font-family:monospace">F1</SPAN> and <SPAN style="font-family:monospace">F25</SPAN>.
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION008990000000000000000"></A>
<A ID="substanprint"></A>
<BR>
nprint
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Output control statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">np[rint] <SPAN style="font-family:monospace">&lt;</SPAN>list of names of expressions<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">print (<A HREF="#substaprint">7.113</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
Statement<A NAME="5156"></A> is used to take expressions from the list 
of expressions to be printed. When a print<A NAME="5157"></A> statement is used 
(see <A HREF="#substaprint">7.113</A>) without specification of expressions, all active 
expressions are marked for printing. With this statement one can remove a 
number of them from the list. <BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081000000000000000000"></A>
<A ID="substanskip"></A>
<BR>
nskip
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Specification statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">nskip;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">nskip <SPAN style="font-family:monospace">&lt;</SPAN>list of expressions<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">skip (<A HREF="#substaskip">7.132</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
In the first variety<A NAME="5169"></A> it causes the cancellation of 
all skip<A NAME="5170"></A> plans (see <A HREF="#substaskip">7.132</A>) for expressions. The 
status of these expressions is restored to their previous status (active 
local or global expressions). In the second variety this is done for the 
specified expressions only. Example:
<PRE>
   Skip;
   Nskip F1,F2;
</PRE>
This causes all active expressions to be skipped except for the expressions 
<code>F1</code> and <code>F2</code>. <BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081010000000000000000"></A>
<A ID="substantable"></A>
<BR>
ntable
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Declaration statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">ntable <SPAN style="font-family:monospace">&lt;</SPAN>options<SPAN style="font-family:monospace">&gt;</SPAN> <SPAN style="font-family:monospace">&lt;</SPAN>table to be 
declared<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">functions (<A HREF="#substafunctions">7.62</A>), table (<A HREF="#substatable">7.142</A>),
        ctable (<A HREF="#substactable">7.26</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
This statement<A NAME="5188"></A> declares a 
noncommuting<A NAME="5189"></A> table<A NAME="5190"></A>. For the 
rest it is identical to the table<A NAME="5191"></A> command (see 
<A HREF="#substatable">7.142</A>) which has the commuting property as its default. 
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081020000000000000000"></A>
<A ID="substantensors"></A>
<BR>
ntensors
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Declaration statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">nt[ensors] <SPAN style="font-family:monospace">&lt;</SPAN>list of tensors to be declared<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">functions (<A HREF="#substafunctions">7.62</A>), tensors 
            (<A HREF="#substatensors">7.144</A>), ctensors (<A HREF="#substactensors">7.27</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
This statement<A NAME="5205"></A> declares 
noncommuting<A NAME="5206"></A> tensors<A NAME="5207"></A>. For 
the rest it is equal to the tensor<A NAME="5208"></A> statement (see 
<A HREF="#substatensors">7.144</A>) which has the commuting property as its default.

<P>
The options that exist for properties of tensors are the same as 
those for functions (see <A HREF="#substafunctions">7.62</A>). <BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081030000000000000000"></A>
<A ID="substanunfactorize"></A>
<BR>
nunfactorize
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Output control statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">nunfactorize <code>{</code><SPAN style="font-family:monospace">&lt;</SPAN>name of expression(s)<SPAN style="font-family:monospace">&gt;</SPAN><code>}</code>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">the chapter on polynomials&nbsp;<A HREF="#polynomials">11</A> and 
<A HREF="#substaunfactorize">7.156</A>.</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
When one uses an UnFactorize (see <A HREF="#substaunfactorize">7.156</A>) 
statement without arguments all expressions will be marked for being 
unfactorized. If one would like to exclude a few expressions this can be 
done with the NUnFactorize statement. There should be at least one expression 
mentioned as in:
<PRE>
   UnFactorize;
   NUnFactorize expr12,expr29;
</PRE>
One can also use the UnFactorize statement with a number of expressions after 
which the NUnFactorize statement can remove some from the list again as in:
<PRE>
   UnFactorize expr1,...,expr100;
   NUnFactorize expr12,expr29;
</PRE>

<P>
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081040000000000000000"></A>
<A ID="substanunhide"></A>
<BR>
nunhide
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Specification statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">nunhide;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">nunhide <SPAN style="font-family:monospace">&lt;</SPAN>list of expressions<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">hide (<A HREF="#substahide">7.67</A>),
              nhide (<A HREF="#substanhide">7.96</A>),
              unhide (<A HREF="#substaunhide">7.157</A>),
              pushhide (<A HREF="#substapushhide">7.118</A>),
              pophide (<A HREF="#substapophide">7.112</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
In its first variety<A NAME="5241"></A> this statement undoes all 
unhide<A NAME="5242"></A> (see <A HREF="#substaunhide">7.157</A> and <A HREF="#substahide">7.67</A>) plans 
that the system has in the current module. In its second variety this 
happens only with the specified expressions. Example:
<PRE>
   Unhide;
   Nunhide F1,F2;
</PRE>
All expressions are taken from the hide<A NAME="5247"></A> system, except for the 
expressions <code>F1</code> and <code>F2</code>. <BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081050000000000000000"></A>
<A ID="substanwrite"></A>
<BR>
nwrite
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Declaration statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">nw[rite] <SPAN style="font-family:monospace">&lt;</SPAN>keyword<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">on (<A HREF="#substaon">7.107</A>), off (<A HREF="#substaoff">7.106</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
This statement<A NAME="5259"></A> is considered 
obsolete<A NAME="5260"></A>. All its varieties have been taken over by the 
off<A NAME="5261"></A> statement (see <A HREF="#substaoff">7.106</A>) and the on<A NAME="5263"></A> 
statement (see <A HREF="#substaon">7.107</A>). The current version of FORM will still 
recognize it, but the user is advised to avoid its usage. In future 
versions of FORM it is scheduled to be used for a different kind of 
writing and hence its syntax may change considerably. The conversion 
program conv2to3<A NAME="5267"></A> should help in the conversion of programs 
that have been written for version 2. For completeness we still give the 
syntax and how it should be converted.
The keywords are: <BR>
<BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>stats<A NAME="9020"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Same as: Off stats;</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>statistics<A NAME="9033"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Same as: Off statistics;</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>shortstats<A NAME="9046"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Same as: Off shortstats;</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>shortstatistics<A NAME="9059"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Same as: Off shortstatistics;</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>warnings<A NAME="9072"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Same as: Off warnings;</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>allwarnings<A NAME="9085"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Same as: Off allwarnings;</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>setup<A NAME="9098"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Same as: Off setup;</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>names<A NAME="9111"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Same as: Off names;</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>allnames<A NAME="9124"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Same as: Off allnames;</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>shortstats<A NAME="9137"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Same as: Off shortstats;</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>highfirst<A NAME="9150"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Same as: Off highfirst;</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>lowfirst<A NAME="9163"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Same as: Off lowfirst;</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>powerfirst<A NAME="9176"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Same as: Off powerfirst;</TD></TR>
</TABLE>
    <BR>
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081060000000000000000"></A>
<A ID="substaoff"></A>
<BR>
off
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Declaration statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">off <SPAN style="font-family:monospace">&lt;</SPAN>keyword<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">off <SPAN style="font-family:monospace">&lt;</SPAN>keyword<SPAN style="font-family:monospace">&gt;</SPAN> <SPAN style="font-family:monospace">&lt;</SPAN>option<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">on (<A HREF="#substaon">7.107</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
Statement<A NAME="5335"></A> to control settings<A NAME="5336"></A> during 
execution. Many of these settings replace older statements. The settings 
and their keywords are:

<P>
<TABLE   STYLE="width:159;">
<TR><TD>allnames<A NAME="9189"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Turns the allnames mode off. The default.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>allwarnings<A NAME="9202"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Turns off the printing of all warnings.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>checkpoint<A NAME="9215"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Deactivates the checkpoint mechanism. See
<A HREF="#checkpoints">4.1</A>.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>compress<A NAME="9229"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Turns compression mode off.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>finalstats<A NAME="9242"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Turns off the last line of statistics that is normally 
printed at the end of the run (introduced in version 3.2).</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>highfirst<A NAME="9255"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Puts the sorting in a low first mode.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>insidefirst<A NAME="9268"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Not active at the moment.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>lowfirst<A NAME="9281"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Leaves the default low first mode and puts the sorting in 
a high first mode.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>names<A NAME="9294"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Turns the names mode off. This is the default.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>nospacesinnumbers<A NAME="9307"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD><A ID="staoffnospacesinnumbers"></A>
<BR>
<BR>
Allows very
long numbers to be printed with leading blank spaces at the beginning of a new
line. The numbers are usually broken up by placing a backslash character at
the end of the line and then continuing at the next line. For cosmetic
purposes FORM puts usually a few blank spaces at the beginning of the line.
FORM itself can read this but some programs cannot. This option can be turned
off by the `on nospacesinnumbers;' statement. The printing of the blank
characters can be restored by turning this variable off. See also page 
<A HREF="#nospacesinnumbers">17</A> for a corresponding variable in the setup file.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>oldfactarg<A NAME="9325"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD><A ID="staoffoldfactarg"></A>Switches the use of the FactArg 
statement&nbsp;<A HREF="#substafactarg">7.54</A><A NAME="9334"></A> to the new mode of version 4 or 
later in which expressions in the argument of the mentioned function are 
completely factored over the rationals. The default is off.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>parallel<A NAME="9341"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Disallows the running of the program in parallel mode 
(only relevant for parallel versions of FORM).</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>powerfirst<A NAME="9355"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Puts the sorting back into `highfirst' mode.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>processstats<A NAME="9368"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Turns the process by process printing of the statistics 
in P<SMALL>AR</SMALL>FORM off. Only the master process will be printing statistics. 
Other versions of FORM will ignore this option.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>propercount<A NAME="9385"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Turns the propercounting mode off. This means that for the 
generated terms in the statistics not only the `ground level' terms are 
counted but also terms that were generated inside function arguments.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>properorder<A NAME="9398"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Turns the properorder mode off. This is the default.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>setup<A NAME="9411"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Switches off the mode in which the setup parameters are 
printed. This is the default.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>stats<A NAME="9424"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Same as `Off statistics'.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>statistics<A NAME="9437"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Turns off the printing of statistics.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>shortstats<A NAME="9450"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Same as `Off shortstatistics'.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>shortstatistics<A NAME="9463"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Takes the writing of the statistics back from shorthand 
mode to the regular statistics mode in which each statistics messages takes 
three lines of text and one blank line.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>threadloadbalancing<A NAME="9476"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>
<BR>
<BR>
<BR>
Disables the loadbalancing mechanism of 
TFORM in parallel mode. In other versions of FORM this option is 
ignored.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>threads<A NAME="9492"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Disallows multithreaded running in TFORM.
In other versions of FORM this option is ignored.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>threadstats<A NAME="9507"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Turns off the thread by thread printing of the statistics 
in TFORM. Only the master thread will be printing statistics. Other 
versions of FORM will ignore this option.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>totalsize<A NAME="9522"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Switches the totalsize mode off. For a more detailed 
description of the totalsize mode, see the "On TotalSize;" 
command&nbsp;<A HREF="#ontotalsize">7.107</A>.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>warnings<A NAME="9536"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Turns off the printing of warnings.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>wtimestats<A NAME="9549"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Disables the wall-clock time in the timing information in the 
statistics on the master.</TD></TR>
</TABLE>
    <BR>

<P>
If a description is too short, one should also consult the 
description in the on statement (see <A HREF="#substaon">7.107</A>). <BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081070000000000000000"></A>
<A ID="substaon"></A>
<BR>
on
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Declaration statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">on <SPAN style="font-family:monospace">&lt;</SPAN>keyword<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">on <SPAN style="font-family:monospace">&lt;</SPAN>keyword<SPAN style="font-family:monospace">&gt;</SPAN> <SPAN style="font-family:monospace">&lt;</SPAN>option<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">off (<A HREF="#substaoff">7.106</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
New statement to control settings during execution. Many of these 
settings replace older statements. The settings and their keywords are:

<P>
<TABLE   STYLE="width:159;">
<TR><TD>allnames<A NAME="9562"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Same as `On names' but additionally all system variables 
are printed as well. Default is off. </TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>allwarnings<A NAME="9575"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Puts the printing of warnings in a mode in which all 
warnings, even the very unimportant warnings are printed.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>checkpoint<A NAME="9588"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Activates the checkpoint mechanism that allows for
the recovery of a crashed FORM session. See <A HREF="#checkpoints">4.1</A> for
detailed information.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>compress<A NAME="9603"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Turns compression mode on. This compression is a 
relatively simple compression that hardly costs extra computer time but 
saves roughly a factor two in disk storage. The old statement was `compress 
on' but this should be avoided in the future. This setting is the default.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>compress,gzip<A NAME="9616"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>This option should be followed by a comma or a space and 
a single digit. It activates the gzip compression for the sort file. This 
compression can make the intermediate sort file considerably shorter at the 
cost of some CPU time. This option can be used when disk space is at a 
premium. The digit indicates the compression level. Zero means no 
compression and 9 is the highest level. The default level is 6. Above that 
the compression becomes very slow and doesn't gain very much extra.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>fewerstatistics<A NAME="9629"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Determines how many of the statistics FORM prints when a 
small buffer is full. The keyword can be followed by a positive integer in 
which case one out of that many of these statistics will be printed. If no 
number is given the default value of 10 is used. When the number that 
follows is zero, statistics are never printed when sorting the small buffer.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>fewerstats<A NAME="9643"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Same as the above fewerstatistics.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>finalstats<A NAME="9656"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Determines whether FORM prints a final line of run time 
statistics at the end of the run. Default is on.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>highfirst<A NAME="9670"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>In this mode polynomials are sorted in a way that high 
powers come before low powers.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>insidefirst<A NAME="9683"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Not active at the moment.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>lowfirst<A NAME="9696"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>In this mode polynomials are sorted in a way that low 
powers come before high powers. This is the default.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>names<A NAME="9709"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Turns on the mode in which at the end of each module the 
names of all variables that have been defined by the user are printed. This 
is an inspection mode for debugging by the user. Default is off.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>nospacesinnumbers<A NAME="9722"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD><A ID="staonnospacesinnumbers"></A>
<BR>
<BR>
Makes that very
long numbers are printed with no leading blank spaces at the beginning of a
new line. The numbers are usually broken up by placing a backspace character
at the end of the line and then continuing at the next line. For cosmetic
purposes FORM puts usually a few blank spaces at the beginning of the line.
FORM itself can read this but some programs cannot. Hence this printing of the
blank characters can be omitted by turning this variable on. See also page
<A HREF="#nospacesinnumbers">17</A> for a corresponding variable in the setup file.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>oldfactarg<A NAME="9740"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD><A ID="staonoldfactarg"></A>Switches the use of the FactArg 
statement&nbsp;<A HREF="#substafactarg">7.54</A><A NAME="9749"></A> to the old mode from before 
version 4. This is a compatibility mode to allow oldprograms that rely on a 
specific working of the FactArg statement to still run. The default is 
off.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>parallel<A NAME="9756"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Allows the running of the program in parallel mode unless 
other problems prevent this. This is of course only relevant for parallel 
versions of FORM. The default is on.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>powerfirst<A NAME="9770"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>In this mode polynomials are sorted in a way that high 
powers come before low powers. The most relevant is however the combined 
power of all symbols.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>processstats<A NAME="9783"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Only active for P<SMALL>AR</SMALL>FORM. It determines whether all
processes print their run time statistics or only the master process does so.
Default is on.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>propercount<A NAME="9798"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Sets the counting of the terms during generation into 
`propercount' mode. This means that only terms at the `ground level' are 
counted and terms inside functions arguments are not counted in the 
statistics. This setting is the default.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>properorder<A NAME="9811"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Turns the properorder mode on. The default is off. In the 
properorder mode FORM pays particular attention to function arguments when 
bringing terms and expressions to normal form. This may cost a considerable 
amount of extra time. In normal mode FORM is a bit sloppy (and much 
faster) about this, resulting sometimes in an ordering that appears without 
logic. This concerns only function arguments! This mode is mainly intended 
for the few moments in which the proper ordering is important.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>setup<A NAME="9826"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Causes the printing of the current setup parameters for 
inspection. Default is off.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>shortstatistics<A NAME="9839"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Puts the writing of the statistics in a shorthand mode in 
which the complete statistics are written on a single line only.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>shortstats<A NAME="9852"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Same as `On shortstatistics'.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>statistics<A NAME="9865"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Turns the writing of runtime statistics on. This is the 
default. It is possible to change this default with one of the setup 
parameters in the setup file (see <A HREF="#setup">17</A>).</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>stats<A NAME="9879"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Same as `On statistics'.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>threadloadbalancing<A NAME="9892"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>
<BR>
<BR>
<BR>
Causes the load balancing mechanism in TFORM
to be turned on or off. Default is on. Ignored by other versions of FORM.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>threads<A NAME="9908"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Allows the running of the program in multithreaded mode 
unless other problems prevent this. This is of course only relevant for 
TFORM. Other versions of FORM ignore this. The default is on.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>threadstats<A NAME="9923"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Only active for TFORM. It determines whether all threads 
print their run time statistics or only the master thread does so. Default 
is on.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>totalsize<A NAME="9937"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD><A ID="ontotalsize"></A> Puts FORM in a 
mode<A NAME="9945"></A> in which it tries to determine 
the maximum space occupied by all expressions at any given moment during 
the execution of the program. This space is the sum of the 
input/output/hide scratch files, the sort file(s) and the .str file. This 
maximum is printed at the end of the program. The same can be obtained with 
the "TotalSize ON" command in the setup (see <A HREF="#setup">17</A>) or the -T option 
in the command tail when FORM is started (see <A HREF="#running">1</A>).</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>warnings<A NAME="9956"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Turns on the printing of warnings in regular mode. This 
is the default.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>wtimestats<A NAME="9969"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Prints the wall-clock time in the timing information in the 
statistics. The wall-clock time is indicated by `<SPAN  CLASS="texttt">WTime</SPAN>' instead of 
`<SPAN  CLASS="texttt">Time</SPAN>' in the normal statistics with `<SPAN  CLASS="texttt">shortstatistics</SPAN>' turned 
off. For parallel versions, it affects the statistics only on the master, and 
does not change those on the workers. The same can be obtained with the 
<SPAN  CLASS="texttt">-W</SPAN> option in the command line options of FORM (see <A HREF="#running">1</A>) 
or `<SPAN  CLASS="texttt">WTimeStats ON</SPAN>' in the setup (see <A HREF="#setup">17</A>). Default is off.</TD></TR>
</TABLE>
    <BR>

<P>
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081080000000000000000"></A>
<A ID="substaonce"></A>
<BR>
once
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">once <SPAN style="font-family:monospace">&lt;</SPAN>pattern<SPAN style="font-family:monospace">&gt;</SPAN> = <SPAN style="font-family:monospace">&lt;</SPAN>expression<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">identify (<A HREF="#substaidentify">7.68</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
This statement<A NAME="5611"></A> is identical to the once option of the 
id<A NAME="5612"></A> statement (see <A HREF="#substaidentify">7.68</A>). Hence
<PRE>
   once ....
</PRE>
is just a shorthand notation for
<PRE>
   id once ....
</PRE>
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081090000000000000000"></A>
<A ID="substaonly"></A>
<BR>
only
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">only <SPAN style="font-family:monospace">&lt;</SPAN>pattern<SPAN style="font-family:monospace">&gt;</SPAN> = <SPAN style="font-family:monospace">&lt;</SPAN>expression<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">identify (<A HREF="#substaidentify">7.68</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
This statement<A NAME="5630"></A> is identical to the only option of the 
id<A NAME="5631"></A> statement (see <A HREF="#substaidentify">7.68</A>). Hence
<PRE>
   only ....
</PRE>
is just a shorthand notation for
<PRE>
   id only ....
</PRE>
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081100000000000000000"></A>
<A ID="substapolyfun"></A>
<BR>
polyfun
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Declaration statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">polyfun <SPAN style="font-family:monospace">&lt;</SPAN>name of function<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">polyfun;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">moduleoption (<A HREF="#substamoduleoption">7.89</A>)</TD>
</TR>
</TABLE>
<BR>
<BR>

<P>
Declares the specified<A NAME="5647"></A> function to be the 
`polyfun'. The polyfun is a function of which the single 
argument<A NAME="5648"></A> is considered to be the 
coefficient<A NAME="5649"></A> of the term. If two terms are otherwise 
identical the arguments of their polyfun will be added during the sorting, 
even if these arguments are little expressions. Hence
<PRE>
    PolyFun acc;
    Local F = 3*x^2*acc(1+y+y^2)+2*x^2*acc(1-y+y^2);
</PRE>
will result in
<PRE>
    F = x^2*acc(5+y+5*y^2);
</PRE>
Note that the external numerical coefficient<A NAME="5654"></A> is also 
pulled inside the polyfun.

<P>
If the polyfun statement has no argument, FORM reverts to its 
default mode in which no polyfun exists. This does not change any terms. If 
one would like to remove the polyfun from the terms one has to do that 
`manually' as in
<PRE>
    PolyFun;
    id  acc(x?) = x;
</PRE>
in which we assume that previously the function acc had been declared to be 
the `polyfun'. <BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081110000000000000000"></A>
<A ID="substapolyratfun"></A>
<BR>
polyratfun
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Declaration statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">polyratfun <SPAN style="font-family:monospace">&lt;</SPAN>name of function<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">polyratfun <SPAN style="font-family:monospace">&lt;</SPAN>name of function<SPAN style="font-family:monospace">&gt;</SPAN>,<SPAN style="font-family:monospace">&lt;</SPAN>name of function<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">polyratfun;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">polyfun (<A HREF="#substapolyfun">7.110</A>),
			  moduleoption (<A HREF="#substamoduleoption">7.89</A>)</TD>
</TR>
</TABLE>
<BR>
<BR>

<P>
Declares the specified<A NAME="5672"></A> function to be the 
`polyratfun'. The polyratfun is a function with two 
arguments<A NAME="5673"></A> which together form a rational polynomial that 
acts as the 
coefficient<A NAME="5674"></A> of the term. If two terms are otherwise 
identical the arguments of their polyratfun will be added during the sorting, 
even if these arguments are little nontrivial. Hence
<PRE>
    PolyRatFun acc;
    Local F = 3*x^2*acc(1+y+y^2,1-y)+2*x^2*acc(1-y+y^2,1+y);
</PRE>
will result in
<PRE>
    F = x^2*acc(-y^3-10*y^2-2*y-5,y^2-1);
</PRE>
Note that the external numerical coefficient<A NAME="5679"></A> is also 
pulled inside the polyratfun.

<P>
If the polyratfun statement has no argument, FORM reverts to its 
default mode in which no polyratfun exists. This does not change any terms.

<P>
The polyratfun has many similarities with the polyfun (see 
<A HREF="#substapolyfun">7.110</A>). At any moment there can only be at most either one 
polyfun or one polyratfun. Occurrences of the polyfun or the polyratfun 
with the wrong number or the wrong type of arguments are treated as regular 
functions.

<P>
There is a fundamental difference between the polyfun and the 
polyratfun. The last one is far more restrictive. It can have only numbers 
and symbols for its arguments. Also the ordering of the terms in the 
arguments can be different. In the polyratfun the terms are always sorted 
with the highest power first. In the polyfun the ordering is as with the 
regular terms. By default the lowest powers come first as one usually likes 
for power series expansions.

<P>
When two functions are specified, the first will be the 
PolyRatFun, and the second will be its inverse as in
<PRE>
    PolyRatFun rat,RAT;
</PRE>
in which case
<PRE>
        RAT(x1,x2) = rat(x2,x1)
</PRE>
This can be handy when one needs to solve systems of equations by manual 
interference. In that case exchanging numerators and denominators can be 
rather messy, while just changing a name is far less error-prone.

<P>
In many cases it may be very wasteful to keep full track of the 
complete rational polynomial. An example is the reduction of a complicated 
4-loop massless propagator diagram for which the rational polynomials can 
easily have hundreds of powers of the dimension parameter <SPAN CLASS="MATH"><IMG STYLE="height: 1.99ex; vertical-align: -0.30ex; " SRC="img63.svg"
 ALT="$D=4-2\epsilon$"></SPAN>. 
In the end one has to expand in terms of <SPAN CLASS="MATH"><IMG STYLE="height: 1.21ex; vertical-align: -0.11ex; " SRC="img64.svg"
 ALT="$\epsilon$"></SPAN> although it is not 
known in advance to how many powers. For this there are two extra options 
in the polyratfun statement. The first is
<PRE>
    PolyRatFun rat(divergence,x);
</PRE>
in which x is the name of the symbol of interest. In this case the 
polyratfun keeps only its most divergent term in this variable x and gives 
it the coefficient one. The result is that terms will never cancel and at 
the end of the calcuation one can see how many poles in x were maximally 
present, and hence how far one has to expand in x. Because the contents of 
the polyratfun are extremely simple, the expensive rational arithmetic is 
completely absent and things should go rather fast.

<P>
In the second option one can specify how far one should expand:
<PRE>
    PolyRatFun rat(expand,x,power);
</PRE>
In this case the denomnator can only be a polynomial in the variable x. It 
will be expanded and multiplied by the numerator and eventually all terms 
with powers of x that are greater than 'power' will be discarded. The 
remaining incidence of the function rat will then have only one argument, 
like the polyfun (see <A HREF="#substapolyfun">7.110</A>). The advantage is that now the 
addition of two coefficients is a simple and straightforward operation that 
does not need the expensive polynomial GCD computations.

<P>
Of course one can program such expansions externally and maybe 
better suited for the problem at hand, but using this option of the 
polyratfun is much faster and gives fewer chances of mistakes.

<P>
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081120000000000000000"></A>
<A ID="substapophide"></A>
<BR>
pophide
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Specification statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">pophide;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">hide (<A HREF="#substahide">7.67</A>),
              nhide (<A HREF="#substanhide">7.96</A>),
              unhide (<A HREF="#substaunhide">7.157</A>),
              nunhide (<A HREF="#substanunhide">7.104</A>),
              pushhide (<A HREF="#substapushhide">7.118</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
Undoes<A NAME="5702"></A> the action of the most recent 
pushhide<A NAME="5703"></A> statement (see <A HREF="#substapushhide">7.118</A>). If there is 
no matching pushhide statement an error will result. <BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081130000000000000000"></A>
<A ID="substaprint"></A>
<BR>
print
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Print statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">Print [<SPAN style="font-family:monospace">&lt;</SPAN>options<SPAN style="font-family:monospace">&gt;</SPAN>];</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">Print <code>{</code>[<SPAN style="font-family:monospace">&lt;</SPAN>options<SPAN style="font-family:monospace">&gt;</SPAN>] <SPAN style="font-family:monospace">&lt;</SPAN>expression<SPAN style="font-family:monospace">&gt;</SPAN><code>}</code>;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">Print [<SPAN style="font-family:monospace">&lt;</SPAN>options<SPAN style="font-family:monospace">&gt;</SPAN>] "<SPAN style="font-family:monospace">&lt;</SPAN>format string<SPAN style="font-family:monospace">&gt;</SPAN>" [<SPAN style="font-family:monospace">&lt;</SPAN>objects<SPAN style="font-family:monospace">&gt;</SPAN>];</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">print[&nbsp;] (<A HREF="#substaprintc">7.114</A>),
              nprint (<A HREF="#substanprint">7.99</A>),
              printtable (<A HREF="#substaprinttable">7.115</A>)</TD>
</TR>
</TABLE>
<BR>
<BR>

<P>
General purpose print<A NAME="5727"></A> statement. It has three modes. In 
the first two modes flags are set for the printing of expressions after the 
current module has been finished. The third mode concerns printing during 
execution. This allows the printing of individual terms or 
$-variables<A NAME="5728"></A> on a term by term basis. It should be 
considered as a useful debugging<A NAME="5729"></A> device.

<P>
In the first mode all active<A NAME="5730"></A> expressions are 
scheduled for printing. The options are
<BR>

<P>
<TABLE   STYLE="width:91;">
<TR><TD><SPAN style="font-family:monospace">&lt;</SPAN>filename<SPAN style="font-family:monospace">&gt;</SPAN>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:635;">
<TR><TD>The results will be printed to the file. The <SPAN style="font-family:monospace">&lt;</SPAN> and 
<SPAN style="font-family:monospace">&gt;</SPAN> are mandatory for this option.</TD></TR>
</TABLE>
    <BR>
This option can only be used in the 
version that prints out individual terms, i.e. the version with the format 
string.

<P>
<TABLE   STYLE="width:45;">
<TR><TD>+f
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:680;">
<TR><TD>Printing will be only to the log<A NAME="10015"></A> 
file<A NAME="10016"></A>.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:45;">
<TR><TD>-f
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:680;">
<TR><TD>Printing will be both to the screen<A NAME="10029"></A> and to 
the log<A NAME="10030"></A> file<A NAME="10031"></A>. This is the default.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:45;">
<TR><TD>+s
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:680;">
<TR><TD>Each term will start a new line. This is called the 
single<A NAME="10044"></A> term mode<A NAME="10045"></A>.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:45;">
<TR><TD>+ss
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:680;">
<TR><TD>Each term will start a new line. In addition each 
internal group will start a new line. A group is either a single function 
or all symbols together, or all dotproducts together, or all vectors 
together, or all Kronecker delta's together.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:45;">
<TR><TD>+sss
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:680;">
<TR><TD>Like the +ss option but now each symbol and its power 
will start a new line. The same for individual dotproducts (and their 
power), vectors and Kronecker delta's.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:45;">
<TR><TD>-s
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:680;">
<TR><TD>Regular term mode. There can be more terms in a line. 
Linebreaks<A NAME="10082"></A> are placed when the line is full. The line 
size is set in the format<A NAME="10083"></A> statement (see <A HREF="#substaformat">7.60</A>). 
This is the default.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:45;">
<TR><TD>-ss
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:680;">
<TR><TD>Lowers the single term mode to -s. If one would like to 
switch off the single term mode altogether, -s suffices.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:45;">
<TR><TD>-sss
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:680;">
<TR><TD>Lowers the single term mode to -ss. If one would like to 
switch off the single term mode altogether, -s suffices.</TD></TR>
</TABLE>
    <BR>

<P>
In the second mode one can specify
individual<A NAME="5776"></A> expressions to be printed. The 
options hold for all the expressions that follow them until new options are 
specified. The options are the same as for the first mode.

<P>
In the third mode there is a format<A NAME="5777"></A> string 
as for the printf<A NAME="5778"></A> command in the C<A NAME="5779"></A> programming 
language. Of course the control characters are not exactly the same as for 
the C language because the objects are different. The special characters 
are:

<P>
<TABLE   STYLE="width:45;">
<TR><TD>%t<A NAME="10115"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:680;">
<TR><TD>The current term will be printed at this position 
including its sign, even if this is a plus sign.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:45;">
<TR><TD>%T<A NAME="10128"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:680;">
<TR><TD>The current term will be printed at this position. If its 
coeficient is positive no leading plus sign is printed.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:45;">
<TR><TD>%w<A NAME="10141"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:680;">
<TR><TD>The number of the current thread will be printed. This is 
for TFORM only. In the sequential version this combination is skipped. The 
number zero refers to the master thread.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:45;">
<TR><TD>%W<A NAME="10155"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:680;">
<TR><TD>The number of the current thread and its CPU-time at the 
moment of printing. This is for TFORM only. In the sequential version 
this combination is skipped. The number zero refers to the master thread.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:45;">
<TR><TD>%$<A NAME="10169"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:680;">
<TR><TD>A dollar expression will be printed at this position. The 
name(s) of the dollar expression(s) should follow the format string in the 
order in which they are used in the format string.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:45;">
<TR><TD>%%<A NAME="10182"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:680;">
<TR><TD>The character %.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:45;">
<TR><TD>%
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:680;">
<TR><TD>If this is the last character of the string no linefeed 
will be printed at the end of the print command.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:45;">
<TR><TD><SPAN CLASS="MATH"><IMG STYLE="height: 2.53ex; vertical-align: -0.69ex; " SRC="img40.svg"
 ALT="$\backslash$"></SPAN>n
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:680;">
<TR><TD>A linefeed<A NAME="10213"></A>.</TD></TR>
</TABLE>
    <BR>

<P>
Each call is terminated with a linefeed<A NAME="5812"></A>. Example:
<PRE>
    Symbols a,b,c;
    Local F = 3*a+2*b;
    Print "&gt; %T";
    id  a = b+c;
    Print "&gt;&gt; %t";
    Print;
    .end
&gt; 3*a
&gt;&gt;  + 3*b
&gt;&gt;  + 3*c
&gt; 2*b
&gt;&gt;  + 2*b

   F =
      5*b + 3*c;
</PRE>

<P>
In the third mode one can also use the +/&ndash;&nbsp;f options of the 
first mode. This should be placed before the format string as in
<PRE>
    Print +f "(%$) %t",$var;
</PRE>

<P>
Because of the mixed nature of this statement it can occur in 
more than one location in the module. <BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081140000000000000000"></A>
<A ID="substaprintc"></A>
<BR>
print[&nbsp;]
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Output control statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">print[&nbsp;] <code>{</code>[<SPAN style="font-family:monospace">&lt;</SPAN>options<SPAN style="font-family:monospace">&gt;</SPAN>] <SPAN style="font-family:monospace">&lt;</SPAN>name<SPAN style="font-family:monospace">&gt;</SPAN><code>}</code>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">print (<A HREF="#substaprint">7.113</A>)</TD>
</TR>
</TABLE>
<BR>
<BR>

<P>
Print<A NAME="5830"></A> statement<A NAME="5831"></A> to cause the printing 
of expressions at the end of the current module. Is like the first two 
modes of the regular print statement (see <A HREF="#substaprint">7.113</A>), but when 
printing FORM does not print the contents of each bracket<A NAME="5833"></A>, 
only the number of terms inside the bracket. Is to be used in combination 
with a bracket or an antibracket<A NAME="5834"></A> statement (see 
<A HREF="#substabracket">7.11</A> and <A HREF="#substaabrackets">7.1</A>). Apart from this the options 
are identical to those of the first two modes of the print statement. 
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081150000000000000000"></A>
<A ID="substaprinttable"></A>
<BR>
printtable
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Print statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">printtable [<SPAN style="font-family:monospace">&lt;</SPAN>options<SPAN style="font-family:monospace">&gt;</SPAN>] <SPAN style="font-family:monospace">&lt;</SPAN>tablename<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">printtable [<SPAN style="font-family:monospace">&lt;</SPAN>options<SPAN style="font-family:monospace">&gt;</SPAN>] <SPAN style="font-family:monospace">&lt;</SPAN>tablename<SPAN style="font-family:monospace">&gt;</SPAN> <SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img24.svg"
 ALT="$&gt;$"></SPAN> <SPAN style="font-family:monospace">&lt;</SPAN>filename<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">printtable [<SPAN style="font-family:monospace">&lt;</SPAN>options<SPAN style="font-family:monospace">&gt;</SPAN>] <SPAN style="font-family:monospace">&lt;</SPAN>tablename<SPAN style="font-family:monospace">&gt;</SPAN> <SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img65.svg"
 ALT="$&gt;\!\!&gt;$"></SPAN> <SPAN style="font-family:monospace">&lt;</SPAN>filename<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">print (<A HREF="#substaprint">7.113</A>),
            table (<A HREF="#substatable">7.142</A>),
            fill (<A HREF="#substafill">7.57</A>),
            fillexpression (<A HREF="#substafillexpression">7.58</A>),</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">and the table_ function (<A HREF="#funtable">8.68</A>)</TD>
</TR>
</TABLE>
<BR>
<BR>

<P>
Almost<A NAME="5865"></A> the opposite of a 
FillExpression<A NAME="5866"></A> statement (see 
<A HREF="#substafillexpression">7.58</A>). Prints<A NAME="5868"></A> the contents of a 
table<A NAME="5869"></A> according to the current format (see 
<A HREF="#substaformat">7.60</A>). The output can go to standard output, the 
log<A NAME="5871"></A> file<A NAME="5872"></A> or a specified file. The elements of 
the table that have been defined and filled are written in the form of 
fill<A NAME="5873"></A> statements (see <A HREF="#substafill">7.57</A>) in such a way that they 
can be read in a future program to fill the table with the current 
contents. This is especially useful when the fillexpression statement has 
been used to dynamically extend tables based on what FORM has encountered 
during running. This way those elements will not have to be computed again 
in future programs. 

<P>
The options are

<P>
<TABLE   STYLE="width:59;">
<TR><TD>+f
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:667;">
<TR><TD>Output is to the logfile and not to the screen.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:59;">
<TR><TD>-f
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:667;">
<TR><TD>Output is both to the logfile and to the screen. This is 
the default.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:59;">
<TR><TD>+s
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:667;">
<TR><TD>Output will be in a mode in which each new term starts a 
new line.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:59;">
<TR><TD>-s
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:667;">
<TR><TD>Output will be in the regular mode in which new terms 
continue to be written on the same line within the limits of the number of 
characters per line as set in the format statement. Default is 72 
characters per line. This can be changed with the format<A NAME="10264"></A> 
statement (see <A HREF="#substaformat">7.60</A>).</TD></TR>
</TABLE>
    <BR>

<P>
If redirection to a file is specified output will be only to this 
file. The +f option will be ignored. There are two possibilities:

<P>
<TABLE   STYLE="width:127;">
<TR><TD><SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img24.svg"
 ALT="$&gt;$"></SPAN> filename
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:599;">
<TR><TD>The old contents of the file with name `filename' will be 
overwritten<A NAME="10278"></A>.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:127;">
<TR><TD><SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img65.svg"
 ALT="$&gt;\!\!&gt;$"></SPAN> filename
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:599;">
<TR><TD>The table will be appended<A NAME="10291"></A> to the file 
with the name `filename'. This allows the writing of more than one table to 
a file.</TD></TR>
</TABLE>
    <BR>
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081160000000000000000"></A>
<A ID="substaprocessbucketsize"></A>
<BR>
processbucketsize
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Declaration statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">processbucketsize <SPAN style="font-family:monospace">&lt;</SPAN>value<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">moduleoption (<A HREF="#substamoduleoption">7.89</A>), setup 
(<A HREF="#setupprocessbucketsize">17</A>)</TD>
</TR>
</TABLE>
<BR>
<BR>

<P>
Sets the number of terms<A NAME="5911"></A> in the buckets that are sent 
to the secondary processors in P<SMALL>AR</SMALL>FORM<A NAME="5912"></A>, one of the 
parallel<A NAME="5913"></A> versions of FORM (see chapter <A HREF="#parallel">18</A>). In 
all other versions this statement is ignored. See also the moduleoption 
(<A HREF="#substamoduleoption">7.89</A>) statement and the corresponding parameter for 
the setup (<A HREF="#setupprocessbucketsize">17</A>). <BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081170000000000000000"></A>
<A ID="substapropercount"></A>
<BR>
propercount
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Declaration statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">propercount <SPAN style="font-family:monospace">&lt;</SPAN>on/off<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">on (<A HREF="#substaon">7.107</A>), off (<A HREF="#substaoff">7.106</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
This statement<A NAME="5928"></A> is obsolete<A NAME="5929"></A>. 
The user should try to use the propercount option of the on<A NAME="5930"></A> (see 
<A HREF="#substaon">7.107</A>) or the off<A NAME="5932"></A> (see <A HREF="#substaoff">7.106</A>) statements. 
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081180000000000000000"></A>
<A ID="substapushhide"></A>
<BR>
pushhide
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Specification statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">pushhide;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">hide (<A HREF="#substahide">7.67</A>),
              nhide (<A HREF="#substanhide">7.96</A>),
              unhide (<A HREF="#substaunhide">7.157</A>),
              nunhide (<A HREF="#substanunhide">7.104</A>),
              pophide (<A HREF="#substapophide">7.112</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
Hides<A NAME="5946"></A> all currently<A NAME="5947"></A> active 
expressions (see <A HREF="#substahide">7.67</A>). The pophide<A NAME="5949"></A> statement 
(see <A HREF="#substapophide">7.112</A>) can bring them back to active status again. 
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081190000000000000000"></A>
<A ID="substaputinside"></A>
<BR>
putinside
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">putinside <SPAN style="font-family:monospace">&lt;</SPAN>name of function<SPAN style="font-family:monospace">&gt;</SPAN> [,<SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img23.svg"
 ALT="$&lt;$"></SPAN>bracket information<SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img24.svg"
 ALT="$&gt;$"></SPAN>];</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">AntiPutInside (<A HREF="#substaantiputinside">7.3</A>)</TD>
</TR>
</TABLE>
<BR>
<BR>

<P>
This statement<A NAME="5961"></A> puts the complete term inside a 
function argument. The function must be a regular function (hence no tensor 
or table which are special types of functions). If there is 
bracket<A NAME="5962"></A> information, this information should adhere to the 
syntax of the bracket statement (<A HREF="#substaantiputinside">7.3</A>) and only 
occurrences of the bracket variables will be put inside the function. The 
coefficient will also be put inside the function.
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081200000000000000000"></A>
<A ID="substaratio"></A>
<BR>
ratio
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">ratio <SPAN style="font-family:monospace">&lt;</SPAN>symbol1<SPAN style="font-family:monospace">&gt;</SPAN> <SPAN style="font-family:monospace">&lt;</SPAN>symbol2<SPAN style="font-family:monospace">&gt;</SPAN> <SPAN style="font-family:monospace">&lt;</SPAN>symbol3<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
This statement<A NAME="5977"></A> can be used for limited but fast 
partial<A NAME="5978"></A> fractioning. In the statement
<PRE>
   ratio a,b,c;
</PRE>
in which <code>a</code>, <code>b</code> and <code>c</code> should be three symbols FORM 
will assume that <SPAN CLASS="MATH"><IMG STYLE="height: 2.01ex; vertical-align: -0.30ex; " SRC="img66.svg"
 ALT="$c = b-a$"></SPAN> and then make the substitutions
<BR>
<DIV ALIGN="CENTER">

<!-- MATH
 \begin{eqnarray}
\frac{1}{a^m}\frac{1}{b^n} & = & \sum_{i=0}^{m-1}\sign(i)
        \binom(n-1+i,n-1)\frac{1}{a^{m-i}}\frac{1}{c^{n+i}}
        +\sum_{i=0}^{n-1}\sign(m)
        \binom(m-1+i,m-1)\frac{1}{b^{n-i}}\frac{1}{c^{m+i}}
        \nonumber \\
    \frac{b^n}{a^m} & = & \sum_{i=0}^n\binom(n,i)\frac{c^i}{a^{m-n+i}}
            \ \ \ \ \ \ \ \hfill m\ge n \nonumber \\
    \frac{b^n}{a^m} & = & \sum_{i=0}^{m-1}\binom(n,i)\frac{c^{n-i}}{a^{m-i}}
        + \sum_{i=0}^{n-m}\binom(m-1+i,m-1)
            c^ib^{n-m-i}
            \ \ \ \ \ \ \ \hfill m<n \nonumber
\end{eqnarray}
 -->
<TABLE CELLPADDING="0" ALIGN="CENTER" WIDTH="100%">
<TR VALIGN="MIDDLE"><TD NOWRAP ALIGN="RIGHT"><IMG STYLE="height: 4.86ex; vertical-align: -1.70ex; " SRC="img67.svg"
 ALT="$\displaystyle \frac{1}{a^m}\frac{1}{b^n}$"></TD>
<TD ALIGN="CENTER" NOWRAP><IMG STYLE="height: 1.06ex; vertical-align: -0.11ex; " SRC="img42.svg"
 ALT="$\textstyle =$"></TD>
<TD ALIGN="LEFT" NOWRAP><IMG STYLE="height: 7.00ex; vertical-align: -2.91ex; " SRC="img68.svg"
 ALT="$\displaystyle \sum_{i=0}^{m-1}\sign(i)
\binom(n-1+i,n-1)\frac{1}{a^{m-i}}\frac{...
...}
+\sum_{i=0}^{n-1}\sign(m)
\binom(m-1+i,m-1)\frac{1}{b^{n-i}}\frac{1}{c^{m+i}}$"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
&nbsp;</TD></TR>
<TR VALIGN="MIDDLE"><TD NOWRAP ALIGN="RIGHT"><IMG STYLE="height: 4.97ex; vertical-align: -1.70ex; " SRC="img69.svg"
 ALT="$\displaystyle \frac{b^n}{a^m}$"></TD>
<TD ALIGN="CENTER" NOWRAP><IMG STYLE="height: 1.06ex; vertical-align: -0.11ex; " SRC="img42.svg"
 ALT="$\textstyle =$"></TD>
<TD ALIGN="LEFT" NOWRAP><IMG STYLE="height: 6.64ex; vertical-align: -2.91ex; " SRC="img70.svg"
 ALT="$\displaystyle \sum_{i=0}^n\binom(n,i)\frac{c^i}{a^{m-n+i}}
\ \ \ \ \ \ \ \hfill m\ge n$"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
&nbsp;</TD></TR>
<TR VALIGN="MIDDLE"><TD NOWRAP ALIGN="RIGHT"><IMG STYLE="height: 4.97ex; vertical-align: -1.70ex; " SRC="img69.svg"
 ALT="$\displaystyle \frac{b^n}{a^m}$"></TD>
<TD ALIGN="CENTER" NOWRAP><IMG STYLE="height: 1.06ex; vertical-align: -0.11ex; " SRC="img42.svg"
 ALT="$\textstyle =$"></TD>
<TD ALIGN="LEFT" NOWRAP><IMG STYLE="height: 7.00ex; vertical-align: -2.91ex; " SRC="img71.svg"
 ALT="$\displaystyle \sum_{i=0}^{m-1}\binom(n,i)\frac{c^{n-i}}{a^{m-i}}
+ \sum_{i=0}^{n-m}\binom(m-1+i,m-1)
c^ib^{n-m-i}
\ \ \ \ \ \ \ \hfill m&lt;n$"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
&nbsp;</TD></TR>
</TABLE></DIV>
<BR CLEAR="ALL"><P></P>
Of course, such substitutions can be made also by the user in a more 
flexible way. This statement has however the advantage of the best speed.
<BR>
<BR>

<P>
Actually the ratio statement is a leftover from the 
Schoonschip<A NAME="6017"></A> 
inheritance. For most simple partial fractioning one could use
<PRE>
   repeat id 1/[x+a]/[x+b] = (1/[x+a]-1/[x+b])/[b-a];
   repeat id [x+a]/[x+b] = 1-[b-a]/[x+b];
   repeat id [x+b]/[x+a] = 1+[b-a]/[x+a];
</PRE>
or similar constructions. This does not give the speed of the 
binomials<A NAME="6020"></A>, but it does make the program more readable and 
it is much more flexible.
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081210000000000000000"></A>
<A ID="substarcyclesymmetrize"></A>
<BR>
rcyclesymmetrize
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">rc[yclesymmetrize] <code>{</code><SPAN style="font-family:monospace">&lt;</SPAN>name of function/tensor<SPAN style="font-family:monospace">&gt;</SPAN>
         [<SPAN style="font-family:monospace">&lt;</SPAN>argument specifications<SPAN style="font-family:monospace">&gt;</SPAN>];<code>}</code></TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">symmetrize (<A HREF="#substasymmetrize">7.141</A>), cyclesymmetrize 
(<A HREF="#substacyclesymmetrize">7.28</A>), antisymmetrize (<A HREF="#substaantisymmetrize">7.4</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
The argument<A NAME="6035"></A> specifications are explained 
in the section on the symmetrize<A NAME="6036"></A> statement (see 
<A HREF="#substasymmetrize">7.141</A>). 
<P>
<BR>

<P>
The action of this statement is to
reverse<A NAME="6038"></A>-cycle-symmetrize
<A NAME="6039"></A> the (specified) arguments of the functions 
that are mentioned. This means that the arguments are brought to `natural 
order' in the notation of FORM by trying cyclic and reverse cyclic 
permutations<A NAME="6040"></A> of the arguments or groups of arguments. 
The `natural order' may depend on the order of declaration of the 
variables. <BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081220000000000000000"></A>
<A ID="substaredefine"></A>
<BR>
redefine
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">r[edefine] <SPAN style="font-family:monospace">&lt;</SPAN>preprocessor variable<SPAN style="font-family:monospace">&gt;</SPAN> "<SPAN style="font-family:monospace">&lt;</SPAN>string<SPAN style="font-family:monospace">&gt;</SPAN>";</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">preprocessor variables in the chapter on the preprocessor 
    (<A HREF="#preprocessor">3</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
This statement<A NAME="6053"></A> can be used to change the contents 
of preprocessor<A NAME="6054"></A> 
variables<A NAME="6055"></A>. The new contents can be used after 
the current module has finished execution and the preprocessor becomes 
active again for further translation and compilation<A NAME="6056"></A>. 
This termwise adaptation of the value of a preprocessor variable can be 
very useful in setting up multi module loops until a certain condition is 
not met any longer. Example:
<PRE>
   #do i = 1,1
      statements;
      if ( condition ) redefine i "0";
      .sort
   #enddo
</PRE>
As long as there is a term that fulfils the condition the loop<A NAME="6059"></A> 
will continue. This defines effectively a while loop<A NAME="6060"></A> (see 
<A HREF="#substawhile">7.160</A>) over various modules. Note that the .sort<A NAME="6062"></A> 
instruction is essential. Note also that a construction like
<PRE>
   if ( count(x,1) &gt; 3 ) redefine i "`i'+1";
</PRE>
is probably not going to do what the user intends. It is not going to count 
terms with more than three powers of x. The preprocessor will insert the 
compile time value of the preprocessor variable i. If this is 0, then each 
time a term has more than three powers of x, i will get the string value 
<code>0+1</code>. If one would like to do such counting, one should use a 
dollar variable<A NAME="6065"></A> (see <A HREF="#dollars">6</A>). <BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081230000000000000000"></A>
<A ID="substaremovespectator"></A>
<BR>
removespectator
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">removespectator <SPAN style="font-family:monospace">&lt;</SPAN>spectator;<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
See chapter<A HREF="#spectators">20</A> on spectators.
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081240000000000000000"></A>
<A ID="substarenumber"></A>
<BR>
renumber
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">renumber <SPAN style="font-family:monospace">&lt;</SPAN>number<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">sum (<A HREF="#substasum">7.138</A>)</TD>
</TR>
</TABLE>
<BR>
<BR>

<P>
Renumbers<A NAME="6087"></A> the dummy<A NAME="6088"></A> 
indices<A NAME="6089"></A>. Dummy indices are indices of the type 
<code>N1_?</code>. Normally FORM tries to renumber these indices to make the 
internal representation of a term `minimal'. It does not try exhaustively 
though. Especially interference with symmetric or antisymmetric functions 
is far from perfect. This is due to considerations of economy. With the 
renumber statement the user can force FORM to do better. The allowable 
options are:

<P>
<TABLE   STYLE="width:45;">
<TR><TD>0
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:680;">
<TR><TD>All exchanges of one pair of dummy indices are tried 
until all pair exchanges yield no improvements. This is the default if no 
option is specified.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:45;">
<TR><TD>1
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:680;">
<TR><TD>If there are N sets of dummy indices all N! 
permutations<A NAME="10322"></A> are tried. This can be very costly when a 
large number of indices is involved. Use with care!</TD></TR>
</TABLE>
    <BR>
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081250000000000000000"></A>
<A ID="substarepeat"></A>
<BR>
repeat
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">repeat;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">repeat <SPAN style="font-family:monospace">&lt;</SPAN>executable statement<SPAN style="font-family:monospace">&gt;</SPAN></TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">endrepeat (<A HREF="#substaendrepeat">7.48</A>), while (<A HREF="#substawhile">7.160</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
The repeat<A NAME="6109"></A> statement starts a
repeat<A NAME="6110"></A> environment. It is terminated with an 
endrepeat<A NAME="6111"></A> statement (see <A HREF="#substaendrepeat">7.48</A>). The 
repeat statement and its matching endrepeat statement should be inside the 
same module. <BR>
<BR>

<P>
The statements inside the repeat environment should all be 
executable statements (or print statements) and if any of the executable 
statements inside the environment has changed the current term, the action 
of the endrepeat statement will be to bring control back to the beginning 
of the environment. In that sense the repeat/endrepeat combination acts as
<PRE>
   do
      executable statements
   while any action due to any of the statements
</PRE>
The second form of the statement is a shorthand<A NAME="6116"></A> notation:
<PRE>
   repeat;
      single statement;
   endrepeat;
</PRE>
is equivalent to
<PRE>
   repeat single statement;
</PRE>
Particular attention should be given to avoid infinite<A NAME="6121"></A> 
loops<A NAME="6122"></A> as in
<PRE>
   repeat id a = a+1;
</PRE>
A more complicated infinite loop is
<PRE>
   repeat;
      id  S(x1?)*R(x2?) = T(x1,x2,x2-x1);
      id  T(x1?,x2?,x3?pos_) = T(x1,x2-2,x3-1)*X(x2);
      id  T(x1?,x2?,x3?) = S(x1)*R(x2);
   endrepeat;
</PRE>
If the current term is S(2)*R(2), the statements in the loop do not change 
it in the end. Yet the program goes into an infinite loop, because the 
first id statement will change the term (action) and the third statement 
will change it back. FORM does not check that the term is the same 
again. Hence there is action inside the repeat environment and hence the 
statements will be executed again. This kind of hidden action is a major 
source of premature<A NAME="6128"></A> 
terminations<A NAME="6129"></A> of FORM programs. <BR>
<BR>

<P>
Repeat environments can be nested<A NAME="6132"></A> with all other 
environments (and of course also with other repeat/endrepeat combinations). 
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081260000000000000000"></A>
<A ID="substareplaceloop"></A>
<BR>
replaceloop
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">replaceloop <SPAN style="font-family:monospace">&lt;</SPAN>parameters<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">the findloop option of the if statement (<A HREF="#substaif">7.71</A>)</TD>
</TR>
</TABLE>
<BR>
<BR>

<P>
This statement<A NAME="6143"></A> causes the substitution of 
index<A NAME="6144"></A> loops<A NAME="6145"></A>. An index loop is a 
sequence of contracted indices in which the indices are arguments of 
various instances of the same function and each contracted<A NAME="6146"></A> index<A NAME="6147"></A> occurs once in one instance of the 
function and once in another instance of the function. Such a contraction 
defines a connection and if a number of such connections between 
occurrences of the function form a loop this structure is a candidate for 
replacement. Examples of such loops are:
<PRE>
    f(i1,i2,j1)*f(i2,i1,j2)
    f(i1,i2,j1)*f(i2,i3,j2)*f(i1,i3,j3)
    f(i1,k1,i2,j1)*f(k2,i2,i3,j2)*f(i1,k3,i3,j3)
</PRE>
The first term has a loop of two functions or vertices<A NAME="6150"></A> and 
the other two terms each define a loop of three vertices. The parameters 
are:

<P>
<TABLE   STYLE="width:181;">
<TR><TD><SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img23.svg"
 ALT="$&lt;$"></SPAN>name<SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img24.svg"
 ALT="$&gt;$"></SPAN>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>The name of the function that defines the `vertices'. 
This must always be the first parameter.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>arguments=number
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>Only occurrences of the vertex function with the 
specified number of arguments will be considered. The specification of this 
parameter is mandatory.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>loopsize=number
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>Only a loop with this number of vertices will be 
considered.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>loopsize=all
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>All loop<A NAME="10373"></A> sizes will be considered and the 
smallest loop is substituted.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>loopsize<SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img23.svg"
 ALT="$&lt;$"></SPAN>number
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>Only loops with fewer vertices than `number' will be 
considered and the smallest looop will be substituted.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>outfun=<SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img23.svg"
 ALT="$&lt;$"></SPAN>name<SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img24.svg"
 ALT="$&gt;$"></SPAN>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>Name of an output function in which the remaining 
arguments of all the vertex functions will be given. This parameter is 
mandatory.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>include-<SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img23.svg"
 ALT="$&lt;$"></SPAN>name<SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img24.svg"
 ALT="$&gt;$"></SPAN>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>Name of a summable index that must be one of the links in 
the loop. This parameter is optional.</TD></TR>
</TABLE>
    <BR>

<P>
The loopsize<A NAME="6179"></A> parameter is mandatory. Hence one of 
its options must be specified. The order of the parameters is not 
important. The only important thing is that the name of the vertex function 
must be first. The names of the keywords may be abbreviated as in
<PRE>
    ReplaceLoop f,a=3,l=all,o=ff,i=i2;
</PRE>
although this does not improve the readability of the program. Hence a more 
readable abbreviated version might be
<PRE>
    ReplaceLoop f,arg=3,loop=all,out=ff,inc=i2;
</PRE>

<P>
The action of the statement is to remove the vertex functions 
that constitute the loop and replace them by the output function. This 
outfun will have the arguments of all the vertex functions minus the 
contracted indices that define the loop. The order of the arguments is the 
order in which they are encountered when following the loop. The order of 
the arguments in the outfun depends however on the order in which FORM 
encounters the vertices. Hence the outfun will often be 
cyclesymmetric<A NAME="6184"></A><A NAME="6185"></A> (see 
<A HREF="#substafunctions">7.62</A> and <A HREF="#substacyclesymmetrize">7.28</A>). If FORM has to 
exchange indices to make a `proper loop' (i.e. giving relevance to the 
first index as if it is something incoming and the second index as if it is 
something outgoing) and if the vertex function is 
antisymmetric<A NAME="6188"></A><A NAME="6189"></A>, each exchange will 
result in a minus sign. Examples:
<PRE>
    Functions f(antisymmetric),ff(cyclesymmetric);
    Indices i1,...,i8;
    Local F = f(i1,i4,i2)*f(i5,i2,i3)*f(i3,i1,i6)*f(i4,i7,i8);
    ReplaceLoop f,arg=3,loop=3,out=ff;
</PRE>
would result in
<PRE>
    -f(i4,i7,i8)*ff(i4,i5,i6)
</PRE>
and
<PRE>
    Functions f(antisymmetric),ff(cyclesymmetric);
    Indices i1,...,i9;
    Local F = f(i1,i4,i2)*f(i5,i2,i3)*f(i3,i1,i6)*f(i4,i7,i8)
            *f(i6,i7,i8);
    ReplaceLoop f,arg=3,loop=all,out=ff;
</PRE>
would give
<PRE>
    -f(i1,i4,i2)*f(i5,i2,i3)*f(i3,i1,i6)*ff(i4,i6)
</PRE>
because the smallest loop will be taken. A number of examples can be found 
in the package<A NAME="6198"></A> `color'<A NAME="6199"></A> for group 
theory<A NAME="6200"></A> invariants that is part of the FORM 
distribution. 

<P>
A related object is the findloop<A NAME="6201"></A> option of the 
if<A NAME="6202"></A> statement (see <A HREF="#substaif">7.71</A>). This option just probes 
whether a loop is present but makes no replacements.
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081270000000000000000"></A>
<A ID="substasave"></A>
<BR>
save
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Declaration statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">sa[ve] <SPAN style="font-family:monospace">&lt;</SPAN>filename<SPAN style="font-family:monospace">&gt;</SPAN> [<SPAN style="font-family:monospace">&lt;</SPAN>names of global expressions<SPAN style="font-family:monospace">&gt;</SPAN>];</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">load (<A HREF="#substaload">7.83</A>)</TD>
</TR>
</TABLE>
<BR>
<BR>

<P>
Saves<A NAME="6216"></A> the contents of the store<A NAME="6217"></A> 
file<A NAME="6218"></A> (all global expressions that were stored in 
.store<A NAME="6219"></A> 
instructions) to a file with the indicated name. If a list of expressions 
is provided only those expressions are saved and the others are ignored. 

<P>
Together with the load<A NAME="6220"></A> statement (see 
<A HREF="#substaload">7.83</A>) the save statement provides a mechanism to transfer data 
in internal notation from one program to another. It is the preferred method 
to keep results of a lengthy job for further analysis without the need for 
the long initial running time.

<P>
In order to avoid confusion .sav<A ID="ex:sav"></A><A NAME="6223"></A> is the 
preferred extension<A NAME="6224"></A> of saved files.
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081280000000000000000"></A>
<A ID="substaselect"></A>
<BR>
select
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">select <SPAN style="font-family:monospace">&lt;</SPAN>list of sets<SPAN style="font-family:monospace">&gt;</SPAN> <SPAN style="font-family:monospace">&lt;</SPAN>pattern<SPAN style="font-family:monospace">&gt;</SPAN> = <SPAN style="font-family:monospace">&lt;</SPAN>expression<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">identify (<A HREF="#substaidentify">7.68</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
This statement<A NAME="6239"></A> is identical to the select option of 
the id<A NAME="6240"></A> statement (see <A HREF="#substaidentify">7.68</A>). Hence
<PRE>
   select ....
</PRE>
is just a shorthand notation for
<PRE>
   id select ....
</PRE>
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081290000000000000000"></A>
<A ID="substaset"></A>
<BR>
set
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Declaration statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">set <SPAN style="font-family:monospace">&lt;</SPAN>set to be declared<SPAN style="font-family:monospace">&gt;</SPAN>[(option)]:<SPAN style="font-family:monospace">&lt;</SPAN>element<SPAN style="font-family:monospace">&gt;</SPAN> [<SPAN style="font-family:monospace">&lt;</SPAN>more elements<SPAN style="font-family:monospace">&gt;</SPAN>];</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
Declares a single set<A NAME="6259"></A> and specifies its 
elements<A NAME="6260"></A>. Sets have a type of variables connected to them. 
There can be sets of symbols, sets of functions, sets of vectors, sets of 
indices and sets of numbers. For the purpose of sets tensors<A NAME="6261"></A> 
and tables<A NAME="6262"></A> count as functions.

<P>
There can also be mixed sets<A NAME="6263"></A> of indices and 
numbers. When a number could be either a fixed index or just a number FORM 
will keep the type of the set unfixed. This can change either when the next 
element is a symbolic index or a number that cannot be a fixed index (like 
a negative number). If the status does not get resolved the set can be used 
in the wildcarding of both symbols and indices. Normally sets of numbers 
can be used only in the wildcarding of symbols.

<P>
Currently the only option is the ordered 
set<A NAME="6264"></A><A NAME="6265"></A>, indicated by
<PRE>
    Set name(ordered):x4,x3,x1,x6,x2;
</PRE>
which would be stored as x1,x2,x3,x4,x6 if that would be the order of 
declaration.

<P>
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081300000000000000000"></A>
<A ID="substasetexitflag"></A>
<BR>
setexitflag
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">setexitflag;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">exit (<A HREF="#substaexit">7.52</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
Causes<A NAME="6276"></A> termination<A NAME="6277"></A> of the 
program after execution<A NAME="6278"></A> of the current module has 
finished. <BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081310000000000000000"></A>
<A ID="substashuffle"></A>
<BR>
shuffle
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">shuffle,functionname;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">shuffle,once,functionname;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">stuffle (<A HREF="#substastuffle">7.137</A>)</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">merge (<A HREF="#substamerge">7.87</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
This statement is exactly the same as the merge<A NAME="6288"></A> 
statement. It takes two occurrences of the mentioned function and outputs 
terms, each with one function in which the two argument lists have been 
merged in all different ways, keeping the relative ordering of the two 
lists preserved. It is the opposite of the 
distrib_<A NAME="6289"></A><A NAME="6290"></A> function (see 
<A HREF="#fundistrib">8.12</A>). Hence
<PRE>
   Local F = f(a,b)*f(c,d);
   shuffle,f;
</PRE>
will result in
<PRE>
      +f(a,b,c,d)+f(a,c,b,d)+f(a,c,d,b)+f(c,a,b,d)+f(c,a,d,b)+f(c,d,a,b)
</PRE>
One can also obtain the same result with the statements
<PRE>
   Multiply,ff;
   repeat id f(x1?,?a)*f(x2?,?b)*ff(?c) =
            +f(?a)*f(x2,?b)*ff(?c,x1)
            +f(x1,?a)*f(?b)*ff(?c,x2);
   id f(?a)*f(?b)*ff(?c) = f(?c,?a,?b);
</PRE>
but the advantage of the shuffle statement is that is also does a certain 
amount of combinatorics when there are identical arguments. Unfortunately 
the combinatorics doesn't extend over groups of arguments that are 
identical as in
<PRE>
    CF  f;
    L   F = f(0,1,0,1,0,1)*f(0,1,0,1,0,1);
    Shuffle,f;
    .end

Time =       0.00 sec    Generated terms =        141
               F         Terms in output =         32
                         Bytes used      =        892
</PRE>
It does get the combinatorics between two zeroes or two ones, but it cannot 
handle the groups. The explicit method above however doesn't do any 
combinatorics and generates 924 terms.

<P>
One of the applications of this statement is in the field of harmonic 
sums<A NAME="6300"></A>, 
harmonic polylogarithms<A NAME="6301"></A> and multiple zeta 
values<A NAME="6302"></A><A NAME="6303"></A>. Its twin brother is the 
stuffle statement<A NAME="6304"></A> (see <A HREF="#substastuffle">7.137</A>).

<P>
When the option once is mentioned, only one pair will be contracted this 
way. Without this option all occurrences of the function inside a term will 
be treated till there are only terms with a single occurrence of the 
function.
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081320000000000000000"></A>
<A ID="substaskip"></A>
<BR>
skip
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Specification statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">skip;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">skip <SPAN style="font-family:monospace">&lt;</SPAN>list of expressions<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">nskip (<A HREF="#substanskip">7.100</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
In the first<A NAME="6316"></A> variety this statement marks all 
active<A NAME="6317"></A> expressions that are in existence at the moment this 
statement is compiled, to be skipped. In the second variety this is done 
only to the active expressions that are specified. If an expression is 
skipped in a given module, the statements in the module have no effect on 
it. Also it will not be sorted<A NAME="6318"></A> again at the end of the module. 
This means that any bracket<A NAME="6319"></A> information (see 
<A HREF="#substabracket">7.11</A>) in the expression remains the way it was. Consult also 
the nskip<A NAME="6321"></A> statement in <A HREF="#substanskip">7.100</A>. <BR>
<BR>

<P>
Skipped expressions can be used in the expressions in the r.h.s. 
of id<A NAME="6324"></A> statements (see <A HREF="#substaidentify">7.68</A>) or 
multiply<A NAME="6326"></A> statements (see <A HREF="#substamultiply">7.92</A>), etc. 
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081330000000000000000"></A>
<A ID="substasort"></A>
<BR>
sort
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">sort;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">term (<A HREF="#substaterm">7.145</A>), endterm (<A HREF="#substaendterm">7.50</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
Statement<A NAME="6337"></A> to be used inside the term<A NAME="6338"></A> 
environment<A NAME="6339"></A> (see <A HREF="#substaterm">7.145</A> and 
<A HREF="#substaendterm">7.50</A>). It forces a sort in the same way as a 
.sort<A NAME="6342"></A> instruction forces a sort for entire expressions. 
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081340000000000000000"></A>
<A ID="substasplitarg"></A>
<BR>
splitarg
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">splitarg options <code>{</code><SPAN style="font-family:monospace">&lt;</SPAN>name of function/set<SPAN style="font-family:monospace">&gt;</SPAN>
             [<SPAN style="font-family:monospace">&lt;</SPAN>argument specifications<SPAN style="font-family:monospace">&gt;</SPAN>]<code>}</code>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">splitfirstarg (<A HREF="#substasplitfirstarg">7.135</A>),
             splitlastarg (<A HREF="#substasplitlastarg">7.136</A>),
             factarg (<A HREF="#substafactarg">7.54</A>)</TD>
</TR>
</TABLE>
<BR>
<BR>

<P>
Takes<A NAME="6357"></A> the indicated argument<A NAME="6358"></A> of a 
function and if such an argument is a subexpression that consists on more 
than one term, all terms become single arguments of the function as in
<PRE>
   f(a+b-5*c*d) --&gt; f(a,b,-5*c*d)
</PRE>
The way arguments are indicated is rather similar to the way this is done 
in the argument<A NAME="6361"></A> statement (see 
<A HREF="#substaargument">7.9</A>). One can however indicate only a single group of 
functions in one statement. Additionally there are other options. All 
options are in the order that they should be specified:

<P>
<TABLE   STYLE="width:227;">
<TR><TD>(term)
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:499;">
<TR><TD>Only terms that are a numerical multiple of the given 
term are split off. The terms that are split off will trail the remainder.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:227;">
<TR><TD>((term))
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:499;">
<TR><TD>Only terms that contain the given term will be split off. 
The terms that are split off will trail the remainder.</TD></TR>
</TABLE>
    <BR>

<P>
The statement is terminated with a sequence of functions or 
sets<A NAME="6371"></A> of functions. The splitting action will apply only to the 
specified functions or to members of the set(s). If no functions or sets of 
functions are specified all functions will be treated, including the built 
in functions.

<P>
The argument specifications consist of a list of numbers, 
indicating the arguments that should be treated. If no arguments are 
specified, all arguments will be treated. <BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081350000000000000000"></A>
<A ID="substasplitfirstarg"></A>
<BR>
splitfirstarg
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">splitfirstarg <code>{</code><SPAN style="font-family:monospace">&lt;</SPAN>name of function/set<SPAN style="font-family:monospace">&gt;</SPAN>
         [<SPAN style="font-family:monospace">&lt;</SPAN>argument specifications<SPAN style="font-family:monospace">&gt;</SPAN>]<code>}</code>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">splitarg (<A HREF="#substasplitarg">7.134</A>),
             splitlastarg (<A HREF="#substasplitlastarg">7.136</A>)</TD>
</TR>
</TABLE>
<BR>
<BR>

<P>
A little<A NAME="6385"></A> bit like the 
SplitArg<A NAME="6386"></A> statement (see <A HREF="#substasplitarg">7.134</A>). Splits the 
given argument(s) into its first term and a remainder. Then replaces the 
argument by the remainder<A NAME="6388"></A>, followed by the first term.

<P>
The statement is terminated with a sequence of functions or sets 
of functions. The splitting action will apply only to the specified 
functions or to members of the set(s). If no functions or sets<A NAME="6389"></A> 
of functions are specified all functions will be treated, including the 
built in functions.

<P>
The argument specifications consist of a list of numbers, 
indicating the arguments that should be treated. If no arguments are 
specified all arguments will be treated. <BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081360000000000000000"></A>
<A ID="substasplitlastarg"></A>
<BR>
splitlastarg
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">splitlastarg <code>{</code><SPAN style="font-family:monospace">&lt;</SPAN>name of function/set<SPAN style="font-family:monospace">&gt;</SPAN>
         [<SPAN style="font-family:monospace">&lt;</SPAN>argument specifications<SPAN style="font-family:monospace">&gt;</SPAN>]<code>}</code>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">splitarg (<A HREF="#substasplitarg">7.134</A>),
             splitfirstarg (<A HREF="#substasplitfirstarg">7.135</A>)</TD>
</TR>
</TABLE>
<BR>
<BR>

<P>
A little<A NAME="6403"></A> bit like the 
SplitArg<A NAME="6404"></A> statement (see <A HREF="#substasplitarg">7.134</A>). Splits the 
given argument(s) into its last term and a remainder. Then replaces the 
argument by the remainder, followed by the last term.

<P>
The statement is terminated with a sequence of functions or sets 
of functions. The splitting action will apply only to the specified 
functions or to members of the set(s). If no functions or sets<A NAME="6406"></A> 
of functions are specified all functions will be treated, including the 
built in functions.

<P>
The argument specifications consist of a list of numbers, 
indicating the arguments that should be treated. If no arguments are 
specified all arguments will be treated. <BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081370000000000000000"></A>
<A ID="substastuffle"></A>
<BR>
stuffle
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">stuffle,functionname+;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">stuffle,functionname-;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">stuffle,once,functionname+;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">stuffle,once,functionname-;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">shuffle (<A HREF="#substashuffle">7.131</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
This statement 
takes two occurrences of the mentioned function and outputs 
terms, each with one function in which the two argument lists have been 
merged according to the rules for nested sums. The plus and minus signs 
refer to ones favorite definition for nested sums. In the case of the plus 
sign, the definition is
<BR>
<DIV ALIGN="CENTER">

<!-- MATH
 \begin{eqnarray}
\sum_{i=1}^N \sum_{i=1}^N & = & \sum_{i=1}^N \sum_{j=1}^{i-1}
        + \sum_{j=1}^N \sum_{i=1}^{j-1}
        + \sum_{i=j=1}^N
\end{eqnarray}
 -->
<TABLE CELLPADDING="0" ALIGN="CENTER" WIDTH="100%">
<TR VALIGN="MIDDLE"><TD NOWRAP ALIGN="RIGHT"><IMG STYLE="height: 7.06ex; vertical-align: -2.91ex; " SRC="img72.svg"
 ALT="$\displaystyle \sum_{i=1}^N \sum_{i=1}^N$"></TD>
<TD ALIGN="CENTER" NOWRAP><IMG STYLE="height: 1.06ex; vertical-align: -0.11ex; " SRC="img42.svg"
 ALT="$\textstyle =$"></TD>
<TD ALIGN="LEFT" NOWRAP><IMG STYLE="height: 7.50ex; vertical-align: -3.24ex; " SRC="img73.svg"
 ALT="$\displaystyle \sum_{i=1}^N \sum_{j=1}^{i-1}
+ \sum_{j=1}^N \sum_{i=1}^{j-1}
+ \sum_{i=j=1}^N$"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
(<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">4</SPAN>)</TD></TR>
</TABLE></DIV>
<BR CLEAR="ALL"><P></P>
while in the case of the minus the definition is
<BR>
<DIV ALIGN="CENTER">

<!-- MATH
 \begin{eqnarray}
\sum_{i=1}^N \sum_{i=1}^N & = & \sum_{i=1}^N \sum_{j=1}^{i}
        + \sum_{j=1}^N \sum_{i=1}^{j}
        - \sum_{i=j=1}^N
\end{eqnarray}
 -->
<TABLE CELLPADDING="0" ALIGN="CENTER" WIDTH="100%">
<TR VALIGN="MIDDLE"><TD NOWRAP ALIGN="RIGHT"><IMG STYLE="height: 7.06ex; vertical-align: -2.91ex; " SRC="img72.svg"
 ALT="$\displaystyle \sum_{i=1}^N \sum_{i=1}^N$"></TD>
<TD ALIGN="CENTER" NOWRAP><IMG STYLE="height: 1.06ex; vertical-align: -0.11ex; " SRC="img42.svg"
 ALT="$\textstyle =$"></TD>
<TD ALIGN="LEFT" NOWRAP><IMG STYLE="height: 7.50ex; vertical-align: -3.24ex; " SRC="img74.svg"
 ALT="$\displaystyle \sum_{i=1}^N \sum_{j=1}^{i}
+ \sum_{j=1}^N \sum_{i=1}^{j}
- \sum_{i=j=1}^N$"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
(<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">5</SPAN>)</TD></TR>
</TABLE></DIV>
<BR CLEAR="ALL"><P></P>
It is assumed that we have harmonic sums<A NAME="6441"></A> (see the 
summer library in the FORM distribution). For such sums we expect 
functions with lists of nonzero integer arguments. Example:
<PRE>
    CF  S,R;
    Symbols N,n;
    L   F = S(R(1,-3),N)*S(R(-5,1),N);
    id  S(R(?a),n?)*S(R(?b),n?) = S(?a)*S(?b)*R(n);
    Stuffle,S-;
    id  S(?a)*R(n?) = S(R(?a),n);
    Print +s;
    .end

Time =       0.00 sec    Generated terms =         12
               F         Terms in output =         12
                         Bytes used      =        462

   F =
       + S(R(-6,-4),N)
       - S(R(-6,-3,1),N)
       - S(R(-6,1,-3),N)
       - S(R(-5,1,-4),N)
       + S(R(-5,1,-3,1),N)
       + 2*S(R(-5,1,1,-3),N)
       - S(R(-5,2,-3),N)
       - S(R(1,-5,-4),N)
       + S(R(1,-5,-3,1),N)
       + S(R(1,-5,1,-3),N)
       + S(R(1,-3,-5,1),N)
       - S(R(1,8,1),N)
      ;
</PRE>
The above program is equivalent to the basis procedure in the summer 
library. As with the shuffle<A NAME="6444"></A> statement (see 
<A HREF="#substashuffle">7.131</A>) a certain amount of combinatorics has been built in.

<P>
When the option once is mentioned, only one pair will be contracted this 
way. Without this option all occurrences of the function inside a term will 
be treated till there are only terms with a single occurrence of the 
function.

<P>
The stuffle command takes also the effect of roots of 
unity&nbsp;<A HREF="#rootofunity">7.140</A><A NAME="6447"></A> into account in the same way 
that the signs of alternating sums are taken into account. This means that 
the sum indices don't have to be integers, but could be multiples of a 
single symbol that has been declared to be a root of 
unity&nbsp;<A HREF="#substasymbols">7.140</A>.
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081380000000000000000"></A>
<A ID="substasum"></A>
<BR>
sum
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">sum <SPAN style="font-family:monospace">&lt;</SPAN>list of indices<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">renumber (<A HREF="#substarenumber">7.124</A>)</TD>
</TR>
</TABLE>
<BR>
<BR>

<P>
The given indices will be summed<A NAME="6459"></A> over. There are two 
varieties. In the first the index is followed by a sequence of nonnegative 
short integers. In that case the summation means that for each of the 
integers a new instance of the term is created in which the index is 
replaced by that integer. In the second variety the index is either the 
last object in the statement or followed by another index. In that case the 
index is replaced by an internal dummy<A NAME="6460"></A> 
index<A NAME="6461"></A> of the type <code>N1_?</code> (or with another number 
instead of the 1). Such indices have the current
default<A NAME="6462"></A> dimension<A NAME="6463"></A> and can 
be renamed at will by FORM to bring terms into standard notation. For 
example:
<PRE>
   f(N2_?,N1_?)*g(N2_?,N1_?)
</PRE>
will be changed into
<PRE>
   f(N1_?,N2_?)*g(N1_?,N2_?).
</PRE>
The user can use these dummy indices in the left hand side of 
id<A NAME="6468"></A> statements.
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081390000000000000000"></A>
<A ID="substaswitch"></A>
<BR>
switch
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">switch,$-variable;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">case (<A HREF="#substacase">7.13</A>), break (<A HREF="#substabreak">7.12</A>),
		 default(<A HREF="#substadefault">7.30</A>), endswitch (<A HREF="#substaendswitch">7.49</A>).</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
The argument of the switch statement should be a dollar variable 
which evaluates into an integer that first inside a FORM word.
On a 64-bit processor this would be an integer in the range <SPAN CLASS="MATH"><IMG STYLE="height: 2.33ex; vertical-align: -0.30ex; " SRC="img19.svg"
 ALT="$-2^{31}$"></SPAN> to 
<SPAN CLASS="MATH"><IMG STYLE="height: 2.33ex; vertical-align: -0.30ex; " SRC="img18.svg"
 ALT="$2^{31}-1$"></SPAN>. The switch statement should be paired with an endswitch 
statement. Between the two there will be a number of cases, each marked by 
an integer. If the value of the dollar variable corresponds to the value of 
one of these cases, execution will continue with the first statement after 
the corresponding case statement. Example:
<PRE>
    id  f(x?$x) = f(x);
    switch $x;
      case -1;
        some statements
      break;
      case 3;
        more statements
      break;
      case 4;
      case 5;
        and a few more
      break;
      default;
        and the default action
      break;
    endswitch;
</PRE>
In principle the action is the same as in any computer language that has a 
switch construction, including the fall-through between case 4 and case 5. 
Whether the selection of the cases goes by binary search in a sorted list 
or by jumptable is determined by the endswitch statement.

<P>
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081400000000000000000"></A>
<A ID="substasymbols"></A>
<BR>
symbols
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Declaration statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">s[ymbols] <SPAN style="font-family:monospace">&lt;</SPAN>list of symbols to be declared<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
</TABLE>
<BR>
<BR>

<P>
Declares one or more symbols<A NAME="6494"></A>. Each symbol can be 
followed by a number of options. These are (assuming that x is the symbol 
to be declared):

<P>
<TABLE   STYLE="width:109;">
<TR><TD>x#r
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:626;">
<TR><TD>The symbol is real<A NAME="10455"></A>. This is the default.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:109;">
<TR><TD>x#c
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:626;">
<TR><TD>The symbol is complex<A NAME="10470"></A>. This means that two 
spaces are reserved for this symbol, one for x and one for x#(the 
complex conjugate).</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:109;">
<TR><TD>x#i
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:626;">
<TR><TD>The symbol is imaginary<A NAME="10486"></A>.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:109;">
<TR><TD>x#=number
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:626;">
<TR><TD>The symbol is a number-th root of
unity<A NAME="10501"></A><A ID="rootofunity"></A> This means that the number-th 
power of the symbol will be replaced by one and half this power (if even) 
by -1. Negative powers will be replaced by corresponding positive powers.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:109;">
<TR><TD>x(:5)
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:626;">
<TR><TD>The symbol has the maximum power 5. This means that <SPAN CLASS="MATH"><IMG STYLE="height: 2.14ex; vertical-align: -0.11ex; " SRC="img75.svg"
 ALT="$x^6$"></SPAN> 
and higher powers are automatically eliminated during the 
normalization<A NAME="10515"></A> of a term. Of course any other number, 
positive or negative, is allowed.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:109;">
<TR><TD>x(-3:)
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:626;">
<TR><TD>The symbol has the minimum power -3. This means that 
<SPAN CLASS="MATH"><IMG STYLE="height: 2.14ex; vertical-align: -0.11ex; " SRC="img76.svg"
 ALT="$x^{-4}$"></SPAN> and lower powers are automatically eliminated during the 
normalization of a term. Of course any other number, positive or negative, 
is allowed. Note that when the minimum power is positive, terms that have 
no power of x should technically be eliminated, but FORM will not do so. 
Such an action can be achieved at any moment with a combination of the 
count<A NAME="10529"></A><A NAME="10530"></A> option of an if<A NAME="10531"></A> statement (see 
<A HREF="#substaif">7.71</A>) and a discard<A NAME="10533"></A> statement (see 
<A HREF="#substadiscard">7.34</A>).</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:109;">
<TR><TD>x(-3:5)
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:626;">
<TR><TD>The combination of a maximum and a minimum power 
restriction (see above).</TD></TR>
</TABLE>
    <BR>
<BR>
<BR>

<P>
Complexity properties and power restrictions can be combined. In 
that case the complexity properties come first and then the power 
restrictions.
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081410000000000000000"></A>
<A ID="substasymmetrize"></A>
<BR>
symmetrize
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">symm[etrize] <code>{</code><SPAN style="font-family:monospace">&lt;</SPAN>name of function/tensor<SPAN style="font-family:monospace">&gt;</SPAN>
         [<SPAN style="font-family:monospace">&lt;</SPAN>argument specifications<SPAN style="font-family:monospace">&gt;</SPAN>];<code>}</code></TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">antisymmetrize (<A HREF="#substaantisymmetrize">7.4</A>), cyclesymmetrize 
(<A HREF="#substacyclesymmetrize">7.28</A>), rcyclesymmetrize (<A HREF="#substarcyclesymmetrize">7.121</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
The arguments<A NAME="6545"></A> consist of the name of a function 
(or a tensor), possibly followed by some specifications. Hence we have the 
following varieties: <BR>

<P>
<TABLE   STYLE="width:227;">
<TR><TD><SPAN style="font-family:monospace">&lt;</SPAN>name<SPAN style="font-family:monospace">&gt;</SPAN>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:499;">
<TR><TD>The function is symmetrized in all its arguments.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:227;">
<TR><TD><SPAN style="font-family:monospace">&lt;</SPAN>name<SPAN style="font-family:monospace">&gt;&lt;</SPAN>numbers<SPAN style="font-family:monospace">&gt;</SPAN>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:499;">
<TR><TD>The function is symmetrized in the arguments that are 
mentioned. If there are fewer arguments than the highest number mentioned 
in the list or arguments, no symmetrization will take place.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:227;">
<TR><TD><SPAN style="font-family:monospace">&lt;</SPAN>name<SPAN style="font-family:monospace">&gt;:&lt;</SPAN>number<SPAN style="font-family:monospace">&gt;</SPAN>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:499;">
<TR><TD>Only functions with the specified number of arguments 
will be considered. Note: the number should follow the colon directly 
without intermediate space or comma.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:227;">
<TR><TD><SPAN style="font-family:monospace">&lt;</SPAN>name<SPAN style="font-family:monospace">&gt;:&lt;</SPAN>number<SPAN style="font-family:monospace">&gt;&lt;</SPAN>numbers<SPAN style="font-family:monospace">&gt;</SPAN>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:499;">
<TR><TD>If there is a number immediately following the colon, 
only functions with exactly that number of arguments will be considered. If 
the list of arguments contains numbers greater than this number, they will 
be ignored. If no number follows the colon directly, this indicates that 
symmetrization will take place, no matter the number of arguments of the 
function. If the list of arguments has numbers greater than the number of 
arguments of the function, these numbers will be ignored.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:227;">
<TR><TD><SPAN style="font-family:monospace">&lt;</SPAN>name<SPAN style="font-family:monospace">&gt;</SPAN>

<P>
<SPAN style="font-family:monospace">&lt;</SPAN>(groups of numbers)<SPAN style="font-family:monospace">&gt;</SPAN>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:499;">
<TR><TD>The groups are specified as lists of numbers of arguments 
between parenthesis. All groups must have the same number of arguments or 
there will be a compile error. The groups are symmetrized as groups. The 
arguments do not have to be adjacent. Neither do they have to be ordered. 
The symmetrization<A NAME="10624"></A> takes place in a way that the first elements of the 
groups are most significant, etc. If any argument number is greater than 
the number of arguments of the function, no symmetrization will take place.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:227;">
<TR><TD><SPAN style="font-family:monospace">&lt;</SPAN>name<SPAN style="font-family:monospace">&gt;:&lt;</SPAN>number<SPAN style="font-family:monospace">&gt;</SPAN>

<P>
<SPAN style="font-family:monospace">&lt;</SPAN>(groups of numbers)<SPAN style="font-family:monospace">&gt;</SPAN>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:499;">
<TR><TD>The groups are specified as lists of numbers of arguments 
between parenthesis. All groups must have the same number of arguments or 
there will be a compile error. The groups are symmetrized as groups. The 
arguments do not have to be adjacent. Neither do they have to be ordered. 
The symmetrization takes place in a way that the first elements of the 
groups are most significant, etc. If no number follows the colon directly 
symmetrization takes place no matter the number of arguments of the 
function. Groups that contain a number that is greater than the number of 
arguments of the function will be ignored. If a number follows the colon 
directly, only functions with that number of arguments will be symmetrized. 
Again, groups that contain a number that is greater than the number of 
arguments of the function will be ignored.</TD></TR>
</TABLE>
    <BR>
<BR>
<BR>

<P>
The action of this statement is to symmetrize the 
(specified) arguments of the functions that are mentioned. This means that 
the arguments are brought to `natural order' in the notation of FORM by 
trying permutations<A NAME="6587"></A> of the arguments or groups of 
arguments. The `natural order' may depend on the order of declaration of 
the variables. <BR>
<BR>

<P>
Examples:
<PRE>
   Symmetrize Fun;
   Symmetrize Fun 1,2,4;
   Symmetrize Fun:5;
   Symmetrize Fun: 1,2,4;
   Symmetrize Fun:5 1,2,4;
   Symmetrize Fun (1,6),(7,3),(5,2);
   Symmetrize Fun:8 (1,6),(7,3),(5,2);
   Symmetrize Fun: (1,6),(7,3),(5,2);
</PRE>
 <BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081420000000000000000"></A>
<A ID="substatable"></A>
<BR>
table
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Declaration statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">table <SPAN style="font-family:monospace">&lt;</SPAN>options<SPAN style="font-family:monospace">&gt;</SPAN> <SPAN style="font-family:monospace">&lt;</SPAN>table to be 
declared<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">functions (<A HREF="#substafunctions">7.62</A>), ctable (<A HREF="#substactable">7.26</A>),
        ntable (<A HREF="#substantable">7.101</A>), fill (<A HREF="#substafill">7.57</A>)</TD>
</TR>
</TABLE>
<BR>
<BR>

<P>
The statement declares a single table<A NAME="6606"></A>. A table is a 
very special instance of a function. Hence it can be either 
commuting<A NAME="6607"></A> or noncommuting<A NAME="6608"></A>. The table 
statement declares its function to be commuting. A noncommuting table is 
declared with the ntable<A NAME="6609"></A> statement (see <A HREF="#substantable">7.101</A>). 
A table has a number of table<A NAME="6611"></A> indices (in the case of 
zero indices the table has to be sparse) and after that it can have a 
number of regular function arguments with or without wildcarding. The table 
indices can come in two varieties: matrix<A NAME="6612"></A> like or 
sparse<A NAME="6613"></A>. In the case of a matrix like table<A NAME="6614"></A>, for each of the indices a range has to be specified. FORM then 
reserves a location for each of the potential elements. For a sparse 
table<A NAME="6615"></A> one only specifies the number of indices. Sparse 
tables take less space, but they require more time searching whether an 
element has been defined. For a matrix like table FORM can look directly 
whether an element has been defined. Hence one has a tradeoff between space 
and speed. A zero-dimensional (sparse) table has of course only a single 
element.
<BR>
<BR>

<P>
Table elements are defined with the fill<A NAME="6617"></A> statement (see 
<A HREF="#substafill">7.57</A>). Fill statements for table elements cannot be used before 
the table has been declared with a table or ntable statement.
<BR>
<BR>

<P>
When FORM encounters an unsubstituted table it will look for its 
indices. Then it can check whether the table element has been defined. If 
not, it can either complain (when the `strict'<A NAME="6620"></A> option is 
used) or continue without substitution. Note that an unsubstituted table 
element is a rather expensive object as FORM will frequently check whether 
it can be substituted (new elements can be defined in a variety of 
ways....). If the indices match a defined table element, FORM will check 
whether the remaining arguments of the table will match the function-type 
arguments given in the table declaration in the same way regular function 
arguments are matched. Hence these arguments can contain 
wildcards<A NAME="6621"></A> and even argument<A NAME="6622"></A> field 
wildcards. If a match occurs, the table is replaced immediately.

<P>
The options are

<P>
<TABLE   STYLE="width:181;">
<TR><TD>check<A NAME="10654"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>A check is executed on table boundaries. An element that is 
outside the table boundaries (regular matrix type tables only) will cause 
an error message and execution will be halted.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>relax<A NAME="10667"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>Normally all elements of a table should be defined during 
execution and an undefined element will give an error message. The relax 
option switches this off and undefined elements will remain as if they are 
regular functions.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>sparse<A NAME="10680"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>The table is considered to be sparse. In the case of a sparse 
table only the number of indices should be specified. Ranges are not 
relevant. Each table element is stored separately. Searching for table 
elements is done via a balanced tree<A NAME="10687"></A>. This takes of 
course more time than the matrix type search with is just by indexing. A 
matrix like table<A NAME="10688"></A> is the default.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>strict<A NAME="10695"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>If this option is specified all table elements that are 
encountered during execution should be defined. An undefined table element 
will result in an error and execution is halted. Additionally all table 
elements should be properly defined at the end of the module in which the 
table has been defined.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>zerofill<A NAME="10708"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>Any undefined table element is considered to be 
zero.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>onefill<A NAME="10721"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>Any undefined table element is considered to be 
one.</TD></TR>
</TABLE>
    <BR>
<BR>
<BR>
<BR>

<P>
The defaults are that the table is matrix like and table elements 
that cannot be substituted will result in an error.
<BR>
<BR>

<P>
Ranges for indices in matrix like tables are indicated with a 
colon as in
<PRE>
   Symbol x;
   Table t1(1:3,-2:4);
   Table t2(0:3,0:3,x?);
   Table sparse,t3(4);
</PRE>
The table <code>t1</code> is two dimensional and has 21 elements. The table 
<code>t2</code> is also two dimensional and has 16 elements. In addition there is 
an extra argument which can be anything that a wildcard symbol will match. 
The table <code>t3</code> is a sparse table with 4 indices.
<BR>
<BR>

<P>
If the computer on which FORM runs is a 32<A NAME="6641"></A> bit 
computer no table can have more than <!-- MATH
 $2^{15} = 32768$
 -->
<SPAN CLASS="MATH"><IMG STYLE="height: 2.14ex; vertical-align: -0.11ex; " SRC="img77.svg"
 ALT="$2^{15} = 32768$"></SPAN> elements. On a 
64<A NAME="6643"></A> bit computer the limit is <SPAN CLASS="MATH"><IMG STYLE="height: 2.14ex; vertical-align: -0.11ex; " SRC="img52.svg"
 ALT="$2^{31}$"></SPAN>, but one should take 
into account that each element declared causes some overhead. <BR>
<BR>

<P>
If the wildcarding in the declaration of a table involves the 
definition of a dollar variable<A NAME="6646"></A> (this is allowed! See 
<A HREF="#dollars">6</A>) parallel execution of the entire remainder of the FORM 
program is switched off. This is of course only relevant for parallel 
versions of FORM. But if at all possible one should try to find better 
solutions than this use of dollar variables, allowing future parallel 
processing of the program.

<P>
In some cases tables are built up slowly during the execution of 
a program and used incrementally. This means that more and more CPU memory 
is needed. Eventually this can cause a crash by lack of memory. In the case 
that the earlier elements of the table aren't needed anymore, one could use 
the ClearTable&nbsp;<A HREF="#substacleartable">7.18</A> statement.
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081430000000000000000"></A>
<A ID="substatablebase"></A>
<BR>
tablebase
</H1>

<P>
This statement is explained in the chapter on 
tablebases<A NAME="6652"></A> (<A HREF="#tablebase">12</A>).
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081440000000000000000"></A>
<A ID="substatensors"></A>
<BR>
tensors
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Declaration statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">t[ensors] <SPAN style="font-family:monospace">&lt;</SPAN>list of tensors to be declared<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">functions (<A HREF="#substafunctions">7.62</A>), ctensors 
        (<A HREF="#substactensors">7.27</A>), ntensors (<A HREF="#substantensors">7.102</A>)</TD>
</TR>
</TABLE>
<BR>
<BR>

<P>
A tensor<A NAME="6666"></A> is a special function that can have only 
indices for its arguments. If an index a contracted with the index of a 
vector Schoonschip<A NAME="6667"></A> notation is used. This means that the 
vector is written as a pseudo argument of the tensor. It should always be 
realized that in that case in principle the actual argument is a dummy 
index. Tensors come in two varieties: commuting<A NAME="6668"></A> and 
noncommuting<A NAME="6669"></A>. The tensor statement declares a tensor to 
be commuting. In order to declare a tensor to be noncommuting one should 
use the ntensor<A NAME="6670"></A> statement (see <A HREF="#substantensors">7.102</A>).

<P>
The options that exist for properties of tensors are the same as 
those for functions (see <A HREF="#substafunctions">7.62</A>). <BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081450000000000000000"></A>
<A ID="substaterm"></A>
<BR>
term
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">term;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">endterm (<A HREF="#substaendterm">7.50</A>), sort (<A HREF="#substasort">7.133</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
Begins the term<A NAME="6682"></A> environment<A NAME="6683"></A>. 
This environment is terminated with the endterm<A NAME="6684"></A> statement 
(see <A HREF="#substaendterm">7.50</A>). The action is that temporarily the current term 
is seen as a little expression by itself. The statements inside the 
environment are applied to it and one can even sort the results with the 
sort<A NAME="6686"></A> statement (see <A HREF="#substasort">7.133</A>) which should not be 
confused with the .sort<A NAME="6688"></A> instruction that terminates a module. 
Inside the term environment one can have only executable statements and 
possibly term-wise print statements (see <A HREF="#substaprint">7.113</A>). When the end 
of the term environment is reached, the results are sorted (as would be 
done with an expression at the end of a module) and execution continues 
with the resulting terms. This environment can be nested<A NAME="6690"></A>. 
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081460000000000000000"></A>
<A ID="substatestuse"></A>
<BR>
testuse
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">testuse ["<SPAN style="font-family:monospace">&lt;</SPAN>tablename(s)<SPAN style="font-family:monospace">&gt;</SPAN>"];</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">tablebases (<A HREF="#tablebase">12</A>), testuse (<A HREF="#tbltestuse">12.10</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
This statement<A NAME="6702"></A> is explained in the chapter on 
tablebases<A NAME="6703"></A>.
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081470000000000000000"></A>
<A ID="substathreadbucketsize"></A>
<BR>
threadbucketsize
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Declaration</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">ThreadBucketSize,number;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">the section on TFORM(<A HREF="#tform">18.1</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
This statement<A NAME="6712"></A> is only active in 
TFORM<A NAME="6713"></A>. In all other versions of FORM it is ignored. It sets 
the size of the buckets<A NAME="6714"></A> that the master<A NAME="6715"></A> thread 
prepares for treatment by the workers. Bigger buckets means less overhead 
in signals, but when the buckets are too big the workers may have to wait 
too long before getting tasks. The best bucket size is usually between 100 
and 1000, although this depends very much on the problem. The default value 
is currently 500. For more ways to set this variable one should consult the 
section on TFORM (<A HREF="#tform">18.1</A>). To find out what its value is, use the
`ON,setup;' statement (<A HREF="#substaon">7.107</A> and <A HREF="#setup">17</A>). <BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081480000000000000000"></A>
<A ID="substatopolynomial"></A>
<BR>
topolynomial
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">topolynomial[,OnlyFunctions[,<SPAN style="font-family:monospace">&lt;</SPAN>list of functions<SPAN style="font-family:monospace">&gt;</SPAN>]];</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">factarg (<A HREF="#substafactarg">7.54</A>), FromPolynomial 
(<A HREF="#substafrompolynomial">7.61</A>), ArgToExtraSymbol (<A HREF="#substaargtoextrasymbol">7.8</A>)</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">and ExtraSymbols (<A HREF="#substaextrasymbols">7.53</A>,
<A HREF="#sect-extrasymbols">2.11</A>).</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
Starting with version 4.0 of FORM some built in operations or
statements can only deal with symbols and numbers. Examples of this are 
factorization&nbsp;(<A HREF="#substafactarg">7.54</A>) and output simplification (still to be 
implemented). The ToPolynomial statement takes each term, looks for objects 
that are not symbols to positive powers and replaces them by symbols. If 
the object has been encountered before, the same symbol will be used, 
otherwise a new symbol will be defined. The object represented by the 
`extra symbol' is stored internally and can be printed if needed with the 
%X option in the #write instruction (<A HREF="#prewrite">3.64</A>). Note that negative 
powers of symbols will also be replaced.

<P>
In some cases one would like to do this only for a subset of objects. It is 
possible to do this only for functions, using the OnlyFunctions option. If 
no functions are specified, all functions will be replaced by extra 
symbols. If a list of functions is specified, only those functions will be 
replaced.
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081490000000000000000"></A>
<A ID="substatospectator"></A>
<BR>
tospectator
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">tospectator <SPAN style="font-family:monospace">&lt;</SPAN>spectator;<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
See chapter<A HREF="#spectators">20</A> on spectators.
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081500000000000000000"></A>
<A ID="substatotensor"></A>
<BR>
totensor
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">totensor [nosquare] [functions] [!<SPAN style="font-family:monospace">&lt;</SPAN>vector or set<SPAN style="font-family:monospace">&gt;</SPAN>] <SPAN style="font-family:monospace">&lt;</SPAN>vector<SPAN style="font-family:monospace">&gt;</SPAN> <SPAN style="font-family:monospace">&lt;</SPAN>tensor<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">totensor [nosquare] [functions] [!<SPAN style="font-family:monospace">&lt;</SPAN>vector or set<SPAN style="font-family:monospace">&gt;</SPAN>] <SPAN style="font-family:monospace">&lt;</SPAN>tensor<SPAN style="font-family:monospace">&gt;</SPAN> <SPAN style="font-family:monospace">&lt;</SPAN>vector<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">tovector (<A HREF="#substatovector">7.151</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
Looks for multiple<A NAME="6766"></A> occurrences of the given 
vector, either inside dotproducts, contracted with a tensor, as argument of 
a function or as a loose vector with an index. In all occurrences in 
which the vector has been contracted a dummy index is introduced to make 
the contraction apparent. Then all these vectors with their indices are 
replaced by the specified tensor with all the indices of these vectors. To 
make this clearer:
<BR>
<DIV ALIGN="CENTER">

<!-- MATH
 \begin{eqnarray}
p^{\mu_1}p^{\mu_2}p^{\mu_3} \rightarrow t^{\mu_1\mu_2\mu_3} \nonumber
\end{eqnarray}
 -->
<TABLE CELLPADDING="0" ALIGN="CENTER" WIDTH="100%">
<TR VALIGN="MIDDLE"><TD NOWRAP ALIGN="RIGHT"><IMG STYLE="height: 2.35ex; vertical-align: -0.56ex; " SRC="img78.svg"
 ALT="$\displaystyle p^{\mu_1}p^{\mu_2}p^{\mu_3} \rightarrow t^{\mu_1\mu_2\mu_3}$"></TD>
<TD>&nbsp;</TD>
<TD>&nbsp;</TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
&nbsp;</TD></TR>
</TABLE></DIV>
<BR CLEAR="ALL"><P></P>
and hence
<PRE>
   p.p1^2*f(p,p1)*p(mu)*tt(p1,p,p2,p)
</PRE>
gives after <code>totensor p,t;</code>
<PRE>
   f(N1_?,p1)*tt(p1,N2_?,p2,N3_?)*t(p1,p1,mu,N1_?,N2_?,N3_?)
</PRE>
<BR>
<BR>

<P>
The options are

<P>
<TABLE   STYLE="width:159;">
<TR><TD>nosquare<A NAME="10742"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Dotproducts with twice the specified vector (square of 
the vector) are not taken into account.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>functions<A NAME="10755"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Vectors that are arguments of regular functions will also 
be considered. By default this is not done.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>!vector<A NAME="10768"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Dotproducts involving the specified vector are not 
treated.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>!set<A NAME="10781"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>The set should be a set of vectors. All dotproducts 
involving a vector of the set are not treated.</TD></TR>
</TABLE>
    <BR>
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081510000000000000000"></A>
<A ID="substatovector"></A>
<BR>
tovector
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">tovector <SPAN style="font-family:monospace">&lt;</SPAN>tensor<SPAN style="font-family:monospace">&gt;</SPAN> <SPAN style="font-family:monospace">&lt;</SPAN>vector<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">tovector <SPAN style="font-family:monospace">&lt;</SPAN>vector<SPAN style="font-family:monospace">&gt;</SPAN> <SPAN style="font-family:monospace">&lt;</SPAN>tensor<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">totensor (<A HREF="#substatotensor">7.150</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
The opposite<A NAME="6812"></A> of the totensor<A NAME="6813"></A> 
statement. The tensor is replaced by a product of the given vectors, each 
with one of the indices of the tensor as in:
<BR>
<DIV ALIGN="CENTER">

<!-- MATH
 \begin{eqnarray}
t^{\mu_1\mu_2\mu_3} \rightarrow p^{\mu_1}p^{\mu_2}p^{\mu_3} \nonumber
\end{eqnarray}
 -->
<TABLE CELLPADDING="0" ALIGN="CENTER" WIDTH="100%">
<TR VALIGN="MIDDLE"><TD NOWRAP ALIGN="RIGHT"><IMG STYLE="height: 2.35ex; vertical-align: -0.56ex; " SRC="img79.svg"
 ALT="$\displaystyle t^{\mu_1\mu_2\mu_3} \rightarrow p^{\mu_1}p^{\mu_2}p^{\mu_3}$"></TD>
<TD>&nbsp;</TD>
<TD>&nbsp;</TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
&nbsp;</TD></TR>
</TABLE></DIV>
<BR CLEAR="ALL"><P></P>
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081520000000000000000"></A>
<A ID="substatrace"></A>
<BR>
trace4
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">trace4 [<SPAN style="font-family:monospace">&lt;</SPAN>options<SPAN style="font-family:monospace">&gt;</SPAN>] <SPAN style="font-family:monospace">&lt;</SPAN>index<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">tracen (<A HREF="#substatracen">7.153</A>), chisholm (<A HREF="#substachisholm">7.17</A>),
    unittrace (<A HREF="#substaunittrace">7.158</A>)</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">and the chapter on gamma algebra (<A HREF="#gammaalgebra">14</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
Takes the trace<A NAME="6837"></A> of the gamma<A NAME="6838"></A> 
matrices with the given trace<A NAME="6839"></A> line 
index<A NAME="6840"></A>. It assumes that the matrices are 
defined in four dimensions, hence it uses some relations that are only 
valid in four dimensions. For details about these relations and other 
methods used, consult chapter&nbsp;<A HREF="#gammaalgebra">14</A> on gamma matrices. The 
options are: <BR>
<BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>contract<A NAME="10794"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>Try to use the Chisholm<A NAME="10801"></A> identity to eliminate this 
trace and contract it with other gamma matrices. See also 
<A HREF="#substachisholm">7.17</A>. This is the default.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>nocontract<A NAME="10809"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>Do not use the Chisholm<A NAME="10816"></A> identity to eliminate this 
trace and contract it with other gamma matrices. See also 
<A HREF="#substachisholm">7.17</A>.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>nosymmetrize<A NAME="10824"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>When using the Chisholm<A NAME="10831"></A> identity to eliminate this 
trace and contract it with other gamma matrices, do not do it in the 
symmetric fashion, but use the first contraction encountered. See also 
<A HREF="#substachisholm">7.17</A>.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>notrick<A NAME="10839"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>The final stage of trace taking, when all indices are different 
and there are no contractions with identical vectors, as well as no 
<SPAN CLASS="MATH"><IMG STYLE="height: 1.66ex; vertical-align: -0.56ex; " SRC="img48.svg"
 ALT="$\gamma_5$"></SPAN> matrices present, is done with n-dimensional methods, rather 
than with 4-dimensional tricks.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>symmetrize
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>When using the Chisholm identity to eliminate this trace and 
contract it with other gamma matrices, try to do it in the symmetric 
fashion. See also <A HREF="#substachisholm">7.17</A>.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>trick
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>The final stage of trace taking, when all indices are different 
and there are no contractions with identical vectors is done using the 
4-dimensional relation

<P>
<!-- MATH
 $\gamma^a\gamma^b\gamma^c = \epsilon^{abcd}\gamma_5\gamma^d
    +\gamma^a\delta^{bc}-\gamma^b\delta^{ac}+\gamma^c\delta^{ab}$
 -->
<SPAN CLASS="MATH"><IMG STYLE="height: 2.68ex; vertical-align: -0.56ex; " SRC="img80.svg"
 ALT="$\gamma^a\gamma^b\gamma^c = \epsilon^{abcd}\gamma_5\gamma^d
+\gamma^a\delta^{bc}-\gamma^b\delta^{ac}+\gamma^c\delta^{ab}$"></SPAN>

<P>
This gives a shorter result for long traces. It is the default.
</TD></TR>
</TABLE>
    <BR> <BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081530000000000000000"></A>
<A ID="substatracen"></A>
<BR>
tracen
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">tracen <SPAN style="font-family:monospace">&lt;</SPAN>index<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">trace4 (<A HREF="#substatrace">7.152</A>), chisholm (<A HREF="#substachisholm">7.17</A>),
    unittrace (<A HREF="#substaunittrace">7.158</A>)</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">and the chapter on gamma algebra (<A HREF="#gammaalgebra">14</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
Takes<A NAME="6874"></A> the trace of the gamma<A NAME="6875"></A> 
matrices with the spin<A NAME="6876"></A> line indicated by the index. It is 
assumed that the trace is over a symbolic number of dimensions. Hence no 
special 4-dimensional tricks are used. The presence of <SPAN CLASS="MATH"><IMG STYLE="height: 1.66ex; vertical-align: -0.56ex; " SRC="img48.svg"
 ALT="$\gamma_5$"></SPAN>, 
<SPAN CLASS="MATH"><IMG STYLE="height: 1.66ex; vertical-align: -0.56ex; " SRC="img81.svg"
 ALT="$\gamma_6$"></SPAN> or <SPAN CLASS="MATH"><IMG STYLE="height: 1.66ex; vertical-align: -0.56ex; " SRC="img82.svg"
 ALT="$\gamma_7$"></SPAN> is not tolerated. When indices are contracted 
FORM will try to use the special symbol for the dimension<SPAN CLASS="MATH"><IMG STYLE="height: 1.90ex; vertical-align: -0.30ex; " SRC="img83.svg"
 ALT="$-4$"></SPAN> if it has 
been defined in the declaration of the index (see <A HREF="#substaindex">7.74</A>. This 
results in relatively compact expressions. For more details on the 
algorithm used, see chapter&nbsp;<A HREF="#gammaalgebra">14</A> on gamma matrices. 
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081540000000000000000"></A>
<A ID="substatransform"></A>
<BR>
transform
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">transform,function(s),<SPAN style="font-family:monospace">&lt;</SPAN>one or more transformations<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
Statement<A NAME="6889"></A> to manipulation function arguments and 
fields of arguments. Allows speedy transformations without the need of 
multiple statements or repeat loops.

<P>
The function(s) is/are indicated as individual, comma or blank space 
separated, functions or sets of functions.

<P>
If there is more than one transformation, the transformations are separated 
by comma's (or blanks, unless the blank space would not induce a comma).

<P>
Each transformation consists of its keyword, indicating its type, followed 
by a range of arguments that is enclosed by parentheses. After that 
specific information may follow. The range<A NAME="6890"></A><A NAME="6891"></A> is as 
in
<PRE>
	(1,4)
	(3,last)
	(last-6,last-2)
</PRE>
hence two indicators, separated by a comma. If the first number is bigger 
than the second the arguments will be processed in reverse order whenever 
this is relevant. In the descriptions below we will indicate the range by 
(r1,r2). The numbers in the above examples may be also dollar variables, 
provided they evaluate into numbers at the time of execution. Hence
<PRE>
	($x,$y)
	($x,last)
	(last-$x,last-2)
</PRE>
are potentially legal ranges. One may not use <code>$x+2</code> or other 
expressions that still need evaluation.

<P>
The transformations that are allowed currently are:

<P>
<TABLE   STYLE="width:145;">
<TR><TD>replace<A NAME="10882"></A><A NAME="10883"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>replace(r1,r2)=(from1,to1,from2,to2,...,fromn,ton) in 
which the from-to pairs are as in the replace_ function. Here however 
there are more options than in the replace_ function as we can specify 
(small) numbers as well as in 
<BR>
replace(1,last)=(0,1,1,0) which would replace arguments that are zero by 
one and arguments that are one by zero. Generic arguments are indicated by 
the new variables xarg_, iarg_, parg_ and farg_ as in 
<BR>
replace(1,last)=(xarg_,2xarg_+1,p) which would replace f(2,a) by f(5,
2a+1,p) if a is a symbol and p a vector. To catch p one would need to use 
parg_.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:145;">
<TR><TD>encode<A NAME="10896"></A><A NAME="10897"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>encode(r1,r2):base=number will interprete the arguments as 
the digits in a base 2 number system, compute the complete number and 
replace the arguments by a single argument that is that number. The number 
must fit inside a single FORM word and so must each of the original 
arguments. They should actually be smaller than the number of the base.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:145;">
<TR><TD>decode<A NAME="10910"></A><A NAME="10911"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>decode(r1,r2):base=number will do the opposite of encode. 
It will take a single argument (the smallest of the two given) and expand 
it into digits in a number system given by the base. It will create the 
specified number of digits and replace the original number by the given 
number of arguments representing these digits. If r2 is less than r1 the 
digits will be in reverse order.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:145;">
<TR><TD>tosumnotation<A NAME="10924"></A><A NAME="10925"></A>
<A NAME="10926"></A><A NAME="10927"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>tosumnotation(r1,r2) or implode(r1,r2) realizes an 
encoding in which zeroes are absorbed as extra values in the first nonzero 
argument that is following. This is used when dealing with harmonic sums 
and harmonic polylogarithms. An example is that (0,0,1,0,a,0,0,0,-1) (which 
is in integral notation) goes into (3,2*a,-4) (which is in sum notation). 
Currently only a single symbol is allowed and the numbers should be (small) 
integers because otherwise the reverse operation (explode) would generate 
too many arguments. Instead of &ldquo;tosumnotation&rdquo; one may also use the word 
&ldquo;implode&rdquo; in accordance with the argimplode statement.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:145;">
<TR><TD>tointegralnotation<A NAME="10940"></A>
<A NAME="10941"></A><A NAME="10942"></A><A NAME="10943"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>tointegralnotation(r1,r2) or explode(r1,r2) undoes what 
implode might have done. Hence each integer with an absolute value <SPAN CLASS="MATH"><IMG STYLE="height: 1.21ex; vertical-align: -0.11ex; " SRC="img84.svg"
 ALT="$n$"></SPAN> 
generates <SPAN CLASS="MATH"><IMG STYLE="height: 1.90ex; vertical-align: -0.30ex; " SRC="img85.svg"
 ALT="$n-1$"></SPAN> zeroes and leaves something with absolute value one. 
Instead of &ldquo;tointegralnotation&rdquo; one may also use the word 
&ldquo;explode&rdquo; in accordance with the argexplode statement.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:145;">
<TR><TD>permute<A NAME="10956"></A><A NAME="10957"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>permute(1,3,5)(2,6) will permute the arguments 
according to the cycles indicated. The cycles are executed in order and may 
overlap. Their number is not restricted. In the above example
f(a1,a2,a3,a4,a5,a6,a7) <SPAN CLASS="MATH"><IMG STYLE="height: 1.06ex; vertical-align: -0.11ex; " SRC="img86.svg"
 ALT="$\rightarrow$"></SPAN> f(a3,a6,a5,a4,a1,a2,a7).
It is allowed to use $-variables in the cycles, including $-variables 
that are obtained by matching argument field wildcards.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:145;">
<TR><TD>reverse<A NAME="10970"></A><A NAME="10971"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>reverse(r1,r2) reverses the order of the arguments in 
specified range.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:145;">
<TR><TD>dedup<A NAME="10984"></A><A NAME="10985"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>dedup(r1,r2) removes duplicates from the arguments in the range, keeping the first.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:145;">
<TR><TD>cycle<A NAME="10998"></A><A NAME="10999"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>cycle(r1,r2)=+/-number will perform a cyclic permutation 
of the indicated range of arguments. If the number is preceeded by a - the 
cycling is to the left. If there is a plus sign the cycling is to the 
right. Note that either the plus or the minus sign is mandatory. The number 
following the +/- sign is also allowed to be a dollar variable provided it 
evaluates to a legal number during execution.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:145;">
<TR><TD>islyndon<A NAME="11012"></A><A NAME="11013"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>islyndon(r1,r2)=(yes,no) will test whether the indicated 
range of arguments forms a Lyndon word<A NAME="11020"></A> according to the 
ordering of arguments in FORM. The yes and no arguments are what the main 
term will be multiplied by when the range forms a Lyndon word or does not 
respectively. Because the definition of a Lyndon word is the unique minimal 
cyclic permutation of the arguments, and because often we may need the 
unique maximal cyclic permutation there are varieties: for the minimum one 
may also use islyndon<SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img23.svg"
 ALT="$&lt;$"></SPAN>(r1,r2)=(yes,no) or islyndon-(r1,r2)=(yes,no), 
while for the maximum one may use islyndon<SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img24.svg"
 ALT="$&gt;$"></SPAN>(r1,r2)=(yes,no) or 
islyndon+(r1,r2)=(yes,no).</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:145;">
<TR><TD>tolyndon<A NAME="11027"></A><A NAME="11028"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>tolyndon(r1,r2)=(yes,no) will permute the given range in 
a cyclic manner till it is (if possible) a Lyndon word<A NAME="11035"></A> 
according to the ordering of arguments in FORM. The yes and no arguments 
are what the main term will be multiplied by when afterwards the range 
forms a Lyndon word or does not respectively. Because the definition of a 
Lyndon word is the unique minimal cyclic permutation of the arguments, and 
because often we may need the unique maximal cyclic permutation there are 
varieties: for the minimum one may also use tolyndon<SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img23.svg"
 ALT="$&lt;$"></SPAN>(r1,r2)=(yes,no) or 
tolyndon-(r1,r2)=(yes,no), while for the maximum one may use 
tolyndon<SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img24.svg"
 ALT="$&gt;$"></SPAN>(r1,r2)=(yes,no) or tolyndon+(r1,r2)=(yes,no). If the output is 
not a Lyndon word, this will be due to that it is a minimum or maximum that 
is not unique.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:145;">
<TR><TD>addargs<A NAME="11042"></A><A NAME="11043"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>addargs(r1,r2) replaces the indicated range of arguments 
by their sum. This is effectively the inverse of the SplitArg statement.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:145;">
<TR><TD>mulargs<A NAME="11056"></A><A NAME="11057"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>mulargs(r1,r2) replaces the indicated range of arguments 
by their product. This is effectively the inverse of the FactArg statement.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:145;">
<TR><TD>dropargs<A NAME="11070"></A><A NAME="11071"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>dropargs(r1,r2) removes the indicated range of arguments.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:145;">
<TR><TD>selectargs<A NAME="11084"></A><A NAME="11085"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>selectargs(r1,r2) removes all arguments with the exception 
of the indicated range of arguments.</TD></TR>
</TABLE>
    <BR>

<P>
Some Examples. Assume that we have some Multiple Zeta Values<A NAME="6975"></A><A NAME="6976"></A> (see the papers on harmonic sums<A NAME="6977"></A>, harmonic polylogarithms<A NAME="6978"></A> and the MZV 
data mine<A NAME="6979"></A>) in the sum notation, but for calculational 
reason we want to use a binary encoding (as used in the MZV programs). We 
could have
<PRE>
    Symbol x,x1,x2;
    CF  H,H1;
    Off Statistics;
    L   F = H(3,4,2,6,1,1,1,2);
    repeat id H(?a,x?!{0,1},?b) = H(?a,0,x-1,?b);
    Print;
    .sort

   F =
      H(0,0,1,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,0,1);

    Multiply H1;
    repeat id H(x?,?a)*H1(?b) = H(?a)*H1(?b,1-x);
    id  H1(?a)*H = H(?a);
    Print;
    .sort

   F =
      H(1,1,0,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,1,0);

    repeat id H(x1?,x2?,?a) = H(2*x1+x2,?a);
    Print;
    .end

   F =
      H(907202);
</PRE>
The new version of the same program would be
<PRE>
    Symbol x,x1,x2;
    CF  H,H1;
    Off Statistics;
    L   F = H(3,4,2,6,1,1,1,2);
    Transform,H,explode(1,last),
                replace(1,last)=(0,1,1,0),
                encode(1,last):base=2;
    Print;
    .end

   F =
      H(907202);
</PRE>
It should be clear that this is simpler and faster. On a 64-bits computer 
it is faster by more than a factor 100.

<P>
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081550000000000000000"></A>
<A ID="substatryreplace"></A>
<BR>
tryreplace
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">tryreplace <code>{</code><SPAN style="font-family:monospace">&lt;</SPAN>name<SPAN style="font-family:monospace">&gt;</SPAN> <SPAN style="font-family:monospace">&lt;</SPAN>replacement<SPAN style="font-family:monospace">&gt;</SPAN><code>}</code>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">the replace_ function (<A HREF="#funreplace">8.59</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
The list<A NAME="6996"></A> of potential replacements should be 
similar to the arguments of the replace_<A NAME="6997"></A> 
function<A NAME="6998"></A> (see <A HREF="#funreplace">8.59</A>). FORM will 
make a copy of the current term, try the replacement and if the replacement 
results in a term which, by the internal ordering of FORM, comes before 
the current term, the current term is replaced by the new variety. 
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081560000000000000000"></A>
<A ID="substaunfactorize"></A>
<BR>
unfactorize
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Output control statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">unfactorize <code>{</code><SPAN style="font-family:monospace">&lt;</SPAN>name of expression(s)<SPAN style="font-family:monospace">&gt;</SPAN><code>}</code>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">the chapter on polynomials&nbsp;<A HREF="#polynomials">11</A> and the 
factorize statement&nbsp;<A HREF="#substafactorize">7.56</A>.</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
Without arguments the statement causes all expressions that were 
factorized to be 'unfactorized'. This means that all factors are multiplied 
and the expression is replaced by this new version. Like the factorize 
statement this statement is an output control statement, which means that 
it takes effect after an expression has been processed in the current 
module (see also the factorize&nbsp;<A HREF="#substafactorize">7.56</A> statement).

<P>
Because an immediate multiplication of all factors is sometimes 
far from optimal, FORM uses a binary scheme to combine factors. After each 
step there will be a sort operation. This means that when statistics are 
printed, there may be several statistics for this step.

<P>
When the statement has arguments, these arguments should be names 
of expressions. In that case the unfactorization is applied only to the 
expressions that are specified.

<P>
If one likes to unfactorized all expressions except for a few 
ones, one can use the unfactorize statement without arguments and then 
exclude the few expressions that should not be treated with the 
nunfactorize statement (see <A HREF="#substanunfactorize">7.103</A>).
<BR>
<BR>
<BR> 

<P>

<H1><A ID="SECTION0081570000000000000000"></A>
<A ID="substaunhide"></A>
<BR>
unhide
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Specification statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">unhide;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">unhide <SPAN style="font-family:monospace">&lt;</SPAN>list of expressions<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">hide (<A HREF="#substahide">7.67</A>),
              nhide (<A HREF="#substanhide">7.96</A>),
              nunhide (<A HREF="#substanunhide">7.104</A>),
              pushhide (<A HREF="#substapushhide">7.118</A>),
              pophide (<A HREF="#substapophide">7.112</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
In its<A NAME="7029"></A> first variety this statement causes all 
statements in the hide<A NAME="7030"></A> file<A NAME="7031"></A> to become 
active<A NAME="7032"></A> expressions again. In its second variety only the 
specified expressions are taken from the hide system and become active 
again. An expression that is made active again can be manipulated again in 
the module in which the unhide statement occurs. For more information one 
should look at the hide statement in <A HREF="#substahide">7.67</A>. <BR>
<BR>

<P>
Note that if only a number of expressions is taken from the hide 
system, the hide file may be left with `holes', i.e. space between the 
remaining expressions that contain no relevant information any longer. 
FORM contains no mechanism to use the space in these holes. Hence if 
space is at a premium and many holes develop one should unhide all 
expressions (this causes the hide system to be started from zero size 
again) and then send the relevant expressions back to the hide system. 
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081580000000000000000"></A>
<A ID="substaunittrace"></A>
<BR>
unittrace
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Declaration statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">u[nittrace] <SPAN style="font-family:monospace">&lt;</SPAN>value<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">trace4 (<A HREF="#substatrace">7.152</A>), tracen (<A HREF="#substatracen">7.153</A>),
    chisholm (<A HREF="#substachisholm">7.17</A>)</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">and the chapter on gamma algebra (<A HREF="#gammaalgebra">14</A>).</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
Sets<A NAME="7049"></A> the value of the trace of the 
unit<A NAME="7050"></A> matrix<A NAME="7051"></A> in the Dirac<A NAME="7052"></A> 
algebra<A NAME="7053"></A> (i.e. the object <code>g1_(n)</code> for trace line 
<code>n</code>)). The parameter <code>value</code> can be either a short positive 
number or any symbol with the exception of <code>i_</code>. See also 
chapter&nbsp;<A HREF="#gammaalgebra">14</A>. <BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081590000000000000000"></A>
<A ID="substavectors"></A>
<BR>
vectors
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Declaration statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">v[ectors] <SPAN style="font-family:monospace">&lt;</SPAN>list of vectors to be declared<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
Used for the declaration of vectors<A NAME="7064"></A>. Example:
<PRE>
   Vectors p,q,q1,q2,q3;
</PRE>
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081600000000000000000"></A>
<A ID="substawhile"></A>
<BR>
while
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Executable statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">while ( condition );</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">endwhile (<A HREF="#substaendwhile">7.51</A>), repeat (<A HREF="#substarepeat">7.125</A>),
            if (<A HREF="#substaif">7.71</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
This statement<A NAME="7077"></A> starts the while 
environment<A NAME="7078"></A>. It should be paired with an 
endwhile<A NAME="7079"></A> statement (see <A HREF="#substaendwhile">7.51</A>) which 
terminates the while environment. The statements between the while and the 
endwhile statements will be executed as long as the condition is met. For 
the description of the condition one should consult the if<A NAME="7081"></A> 
statement (see <A HREF="#substaif">7.71</A>). The while/endwhile combination is 
equivalent to the construction
<PRE>
   repeat;
      if ( condition );


      endif;
   endrepeat;
</PRE>
If only a single statement is inside the environment one can also use
<PRE>
   while ( condition ) statement;
</PRE>
Of course one should try to avoid infinite<A NAME="7087"></A> 
loops<A NAME="7088"></A>. In order to maximize the speed of FORM not 
all internal stacks are protected and hence the result may be that FORM 
may crash. It is also possible that FORM may detect a shortage of buffer 
space and quit with an error message. <BR>
<BR>

<P>
For each term for which execution reaches the endwhile statement, 
control is brought back to the while statement. For each term that reaches 
the while statement the condition is checked and if it is met, the 
statements inside the environment are executed again on this term. If the 
condition is not met, execution continues after the endwhile statement. 
<BR>
<BR>
<BR>

<P>

<H1><A ID="SECTION0081610000000000000000"></A>
<A ID="substawrite"></A>
<BR>
write
</H1>

<P>
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Type</TD>
<TD CLASS="LEFT">Declaration statement</TD>
</TR>
<TR><TD CLASS="LEFT">Syntax</TD>
<TD CLASS="LEFT">w[rite] <SPAN style="font-family:monospace">&lt;</SPAN>keyword<SPAN style="font-family:monospace">&gt;</SPAN>;</TD>
</TR>
<TR><TD CLASS="LEFT">See also</TD>
<TD CLASS="LEFT">on (<A HREF="#substaon">7.107</A>), off (<A HREF="#substaoff">7.106</A>)</TD>
</TR>
</TABLE> <BR>
<BR>

<P>
This statement<A NAME="7104"></A> is considered 
obsolete<A NAME="7105"></A>. All its varieties have been taken over by the 
on<A NAME="7106"></A> statement (see <A HREF="#substaon">7.107</A>) and the off<A NAME="7108"></A> 
statement (see <A HREF="#substaoff">7.106</A>). The current version of FORM will still 
recognize it, but the user is advised to avoid its usage. In future 
versions of FORM it is scheduled to be used for a different kind of 
writing and hence its syntax may change considerably. The conversion 
program conv2to3 should help in the conversion of programs written for 
version 2. For completeness we still give the syntax and how it should be 
converted. The keywords are: <BR>
<BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>allnames<A NAME="11106"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Same as: On allnames;</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>allwarnings<A NAME="11119"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Same as: On allwarnings;</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>highfirst<A NAME="11132"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Same as: On highfirst;</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>lowfirst<A NAME="11145"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Same as: On lowfirst;</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>names<A NAME="11158"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Same as: On names;</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>powerfirst<A NAME="11171"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Same as: On powerfirst;</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>setup<A NAME="11184"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Same as: On setup;</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>shortstatistics<A NAME="11197"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Same as: On shortstatistics;</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>shortstats<A NAME="11210"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Same as: On shortstats;</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>statistics<A NAME="11223"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Same as: On statistics;</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>stats<A NAME="11236"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Same as: On stats;</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:159;">
<TR><TD>warnings<A NAME="11249"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>Same as: On warnings;</TD></TR>
</TABLE>
    <BR>

<P>
<BR>
<BR>
<BR>

<P>

<P>

<H1><A ID="SECTION00900000000000000000"></A>
<A ID="functions"></A>
<BR>
Functions
</H1>

<P>
Functions<A NAME="14314"></A> are objects that can have arguments. 
There exist several types of functions in FORM. First there is the 
distinction between commuting<A NAME="14315"></A> and 
noncommuting<A NAME="14316"></A> functions. Commuting functions commute 
with all other objects. This property is used by the normalization routines 
that bring terms into standard form. Noncommuting functions do not commute 
necessarily with other noncommuting functions. They do however commute with 
objects that are considered to be commuting, like symbols, vectors and 
commuting functions. Various instances of the same noncommuting function 
but with different arguments do not commute either.

<P>
The next subdivision of the category of functions is in regular 
functions<A NAME="14317"></A>, tensors<A NAME="14318"></A> and 
tables<A NAME="14319"></A>. Tensors are special functions that can have only 
indices or vectors for their arguments. If an argument is a vector, it is 
assumed that this vector is there as the result of an index contraction. 
Tables are functions with automatic substitution rules. A table must have 
at least one table<A NAME="14320"></A> index<A NAME="14321"></A>. Each time 
during normalization FORM will check whether an instance of a table can be 
substituted. This means that undefined table elements will slow the program 
down somewhat.

<P>
All the various types of functions are declared with their own 
declaration statements. These are described in the chapter for the 
statements (see chapter&nbsp;<A HREF="#statements">7</A>).

<P>
One of the useful properties of functions is the 
wildcarding<A NAME="14323"></A> of their arguments during pattern matching. The 
following argument wildcards are possible:

<P>
<TABLE   STYLE="width:91;">
<TR><TD>x?
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:635;">
<TR><TD>Here x is a symbol. This symbol can match either a 
symbol, any numerical argument, or a complete subexpression argument that 
is not vectorlike or indexlike.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:91;">
<TR><TD>i?
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:635;">
<TR><TD>Here i is an index. This index can match either an index, 
a vector (actually the dummy<A NAME="14938"></A> index<A NAME="14939"></A> of the 
vector that was contracted), or a complete subexpression that is vector like 
(again actually the contracted dummy index).</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:91;">
<TR><TD>v?
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:635;">
<TR><TD>Here v is a vector. This vector can match either a vector 
or a complete subexpression that is vector like.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:91;">
<TR><TD>f?
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:635;">
<TR><TD>Here f is any functiontype. This function can match any 
function. It is the responsibility of the user to avoid problems in the 
right-hand side if f happens to match a tensor.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:91;">
<TR><TD>?a
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:635;">
<TR><TD>This is an argument<A NAME="14976"></A> field 
wildcard<A NAME="14977"></A>. This can match a 
complete set of arguments. The set can be empty. Argument field wildcards 
have a name that starts with a question mark followed by a name. They do 
not have to be declared as there cannot be confusion.</TD></TR>
</TABLE>
    <BR>

<P>
In addition to the above syntax FORM knows a number of special 
functions with well defined properties. All these functions have a name 
that ends in an underscore. In addition the names of these built in objects 
are case insensitive. This means for instance that the factorial function 
can be referred to as <code>fac_</code>, <code>Fac_</code> or <code>FAC_</code> or whatever 
the user considers more readable. The built in functions are:

<P>

<H1><A ID="SECTION00910000000000000000"></A><A NAME="14347"></A><A NAME="14348"></A>
<A ID="funabs"></A>
<BR>
abs_
</H1>
With one argument that is numerical it evaluates into the 
absolute value of the argument.

<P>

<H1><A ID="SECTION00920000000000000000"></A><A NAME="14351"></A><A NAME="14352"></A>
<A ID="funbernoulli"></A>
<BR>
bernoulli_
</H1>
If it has one nonzero integer argument n, it evaluates into 
the n-th coefficient in the power series expansion of <SPAN CLASS="MATH"><IMG STYLE="height: 2.65ex; vertical-align: -0.69ex; " SRC="img87.svg"
 ALT="$x/(1-e^{-x})$"></SPAN>.

<P>

<H1><A ID="SECTION00930000000000000000"></A><A NAME="14356"></A><A NAME="14357"></A>
<A ID="funbinom"></A>
<BR>
binom_
</H1>
binom_(n,i) <!-- MATH
 $= n!/(i!(n-i)!)$
 -->
<SPAN CLASS="MATH"><IMG STYLE="height: 2.53ex; vertical-align: -0.69ex; " SRC="img88.svg"
 ALT="$= n!/(i!(n-i)!)$"></SPAN>. If the arguments are non 
integer or negative, no substitution is made.

<P>

<H1><A ID="SECTION00940000000000000000"></A><A NAME="14360"></A><A NAME="14361"></A>
<A ID="funconjg"></A>
<BR>
conjg_
</H1>
Currently not doing anything.

<P>

<H1><A ID="SECTION00950000000000000000"></A><A NAME="14364"></A><A NAME="14365"></A>
<A ID="funcontent"></A>
<BR>
content_
</H1>
This function expects the name of a single expression or a dollar 
variable for its 
argument. If it finds this the content of this expression or dollar 
variable is returned. The 
content is defined as a term that has

<UL>
<LI>for its numerator the GCD of the numerators of all terms in the 
expression.
</LI>
<LI>for its denominator the LCM of the denominators of all terms in the 
expression.
</LI>
<LI>all the common subexpressions in all terms of the expression.
</LI>
<LI>the most negative powers of all symbols and dotproducts with negative 
powers in the terms of the expression.
</LI>
</UL>
When there are no negative powers and no denominators in the coefficients, 
this definition of the content coıncides with the classical definition 
of the content of a polynomial over the integers. Our content has the 
property that if we divide the expression by it, we are left with an 
expression of which the coefficients are all integer, there are no negative 
powers and the GCD of all terms combined is one.

<P>
This function has one limitation. It will not consider 
noncommuting objects. Neither will it consider denominator functions.

<P>
Caveat: this function is evaluated each time it is encountered. 
Therefore the best thing is to evaluate it once in the definition of a 
dollar variable or an expression as in
<PRE>
   #$x = content_(F);
   Local G = (a+b)^10*$x;
</PRE>
Here the content is computed only once. In
<PRE>
   Local G = (a+b)^10*content_(F);
</PRE>
11 terms are generated and the content is only worked out when the 
terms are normalized. This means that it will be evaluated 11 times. If one 
does not like dollar variables and still wants to evaluate the content only 
once the code would be
<PRE>
   Local G = ab^10*content_(F);
   id ab = a+b;
</PRE>
because now the term will be normalized before the substitution makes it 
into eleven terms. This assumes of course that the content does not contain 
the variable ab.

<P>

<H1><A ID="SECTION00960000000000000000"></A><A NAME="14377"></A><A NAME="14378"></A>
<A ID="funcount"></A>
<BR>
count_
</H1>
Similar to the count object in the if statement (see 
<A HREF="#substaif">7.71</A>). This function expects the same arguments as the count 
object and returns the corresponding count value for the current term.

<P>

<H1><A ID="SECTION00970000000000000000"></A><A NAME="14382"></A><A NAME="14383"></A>
<A ID="fund"></A>
<BR>
d_
</H1>
The kronecker<A NAME="14385"></A> delta<A NAME="14386"></A>. 
Should have two indices for arguments. Often indicated as 
<!-- MATH
 $\delta^{\mu\nu}$
 -->
<SPAN CLASS="MATH"><IMG STYLE="height: 1.82ex; vertical-align: -0.11ex; " SRC="img89.svg"
 ALT="$\delta^{\mu\nu}$"></SPAN>. In automatic summation over the indices the d_ often 
vanishes again as in
<code>d_(mu,nu)*p(mu)*q(nu)</code> <SPAN CLASS="MATH"><IMG STYLE="height: 1.06ex; vertical-align: -0.11ex; " SRC="img86.svg"
 ALT="$\rightarrow$"></SPAN> <code>p.q</code> and similar 
replacements. Internally this object is treated in a rather special way. 
Hence it will not match a function wildcard.

<P>

<H1><A ID="SECTION00980000000000000000"></A><A NAME="14389"></A><A NAME="14390"></A>
<A ID="fundd"></A>
<BR>
dd_
</H1>
This is a combinatorics<A NAME="14392"></A> function. The tensor 
dd_ with an even number of indices is equal to the totally symmetric 
tensor built up from products of kronecker delta's. Each term in this 
symmetric combination is normalized to one. In principle there are 
<!-- MATH
 $n!/(2^{n/2}(n/2)!$
 -->
<SPAN CLASS="MATH"><IMG STYLE="height: 2.90ex; vertical-align: -0.69ex; " SRC="img90.svg"
 ALT="$n!/(2^{n/2}(n/2)!$"></SPAN> terms in this combination. The profit comes when some 
or all the indices are contracted with vectors and some of these vectors 
are identical. In that case FORM will use combinatorics to generate only 
different terms, each with the proper prefactor. This can result in great 
time and space savings.

<P>

<H1><A ID="SECTION00990000000000000000"></A><A NAME="14395"></A><A NAME="14396"></A>
<A ID="fundelta"></A>
<BR>
delta_
</H1>
With one numerical argument the result is one if 
the argument is zero and zero otherwise. With two arguments the result is 
one if the arguments are numerical and identical. If they are numerical and 
they differ the result is zero. In all other cases nothing is done.

<P>

<H1><A ID="SECTION009100000000000000000"></A><A NAME="14399"></A><A NAME="14400"></A>
<A ID="fundeltap"></A>
<BR>
deltap_
</H1>
If one argument and it is numerical the result is zero if 
the argument is zero and one otherwise. If two arguments, the result is 
zero if the arguments are numerical and identical. If they are numerical and 
they differ the result is one. In all other cases nothing is done.

<P>

<H1><A ID="SECTION009110000000000000000"></A><A NAME="14403"></A><A NAME="14404"></A>
<A ID="fundenom"></A>
<BR>
denom_
</H1>
Internal function to describe denominators. Has a single 
argument. <code>den(a+b)</code> is printed as <code>1/(a+b)</code>.

<P>

<H1><A ID="SECTION009120000000000000000"></A><A NAME="14407"></A><A NAME="14408"></A>
<A ID="fundistrib"></A>
<BR>
distrib_
</H1>
This is a combinatorics<A NAME="14410"></A> function. It should 
have at least five arguments. If we have
<PRE>
    distrib_(type,n,f1,f2,x1,...,xm)
</PRE>
with type and n integers, f1 and f2 functions and then a number of 
arguments there can be action if <SPAN CLASS="MATH"><IMG STYLE="height: 2.02ex; vertical-align: -0.42ex; " SRC="img91.svg"
 ALT="$-2 \le$"></SPAN> type <SPAN CLASS="MATH"><IMG STYLE="height: 2.02ex; vertical-align: -0.42ex; " SRC="img92.svg"
 ALT="$\le 2$"></SPAN>. The typical action 
is that the arguments <code>x1,...,xm</code> will be divided over the two 
functions in all possible ways. For each possibility a new term is 
generated. The relative order of the arguments is kept. If type is negative 
it is assumed that the collection of x-arguments is 
antisymmetric<A NAME="14413"></A> and hence the number of permutations 
needed to make the split will determine whether there will be a minus sign 
on the resulting term. When type is zero all possible divisions are 
generated. Hence there will be <SPAN CLASS="MATH"><IMG STYLE="height: 1.78ex; vertical-align: -0.11ex; " SRC="img93.svg"
 ALT="$2^m$"></SPAN> divisions. The second argument is then 
not relevant. If type is 1 or -1 the second parameter says that the first 
function should obtain n arguments. The remaining arguments go to the 
second function. If type is 2 or -2 the second function should obtain n 
arguments. Example:
<PRE>
    Symbols x1,...,x4;
    CFunctions f,f1,f2;
    Local F = f(x1,...,x4);
    id  f(?a) = distrib_(-1,2,f1,f2,?a);
    Print +s;
    .end

   F =
       + f1(x1,x2)*f2(x3,x4)
       - f1(x1,x3)*f2(x2,x4)
       + f1(x1,x4)*f2(x2,x3)
       + f1(x2,x3)*f2(x1,x4)
       - f1(x2,x4)*f2(x1,x3)
       + f1(x3,x4)*f2(x1,x2)
      ;
</PRE>
When adjacent x-arguments are identical FORM uses combinatorics to avoid 
generating more terms than necessary.

<P>

<H1><A ID="SECTION009130000000000000000"></A><A NAME="14417"></A><A NAME="14418"></A>
<A ID="fundiv"></A>
<BR>
div_
</H1>
<code>div_(x1,x2)</code> is replaced by the quotient of the arguments. 
The arguments can be any valid subexpressions, provided the whole function 
fits inside a term. When an argument is only an active expression or a 
$-expression it is only expanded during the division. This way the 
contents of such expressions can exceed the maximum term size. One should 
however realize that in that case the operation takes place in allocated 
memory. This function replaces the experimental function 
polydiv_<A NAME="14420"></A><A NAME="14421"></A> that existed in 
version 3.

<P>

<H1><A ID="SECTION009140000000000000000"></A><A NAME="14423"></A><A NAME="14424"></A>
<A ID="fundum"></A>
<BR>
dum_
</H1>
Special function for printing virtual<A NAME="14426"></A> 
brackets<A NAME="14427"></A>. <code>dum_(a+b)</code> is printed as <code>(a+b)</code>: the 
name of this function is not printed!

<P>

<H1><A ID="SECTION009150000000000000000"></A><A NAME="14429"></A><A NAME="14430"></A>
<A ID="fundummy"></A>
<BR>
dummy_
</H1>
For internal use only.

<P>

<H1><A ID="SECTION009160000000000000000"></A><A NAME="14433"></A><A NAME="14434"></A>
<A ID="fundummyten"></A>
<BR>
dummyten_
</H1>
For internal use only.

<P>

<H1><A ID="SECTION009170000000000000000"></A><A NAME="14437"></A><A NAME="14438"></A>
<A ID="fune"></A>
<BR>
e_
</H1>
The Levi-Civita<A NAME="14440"></A> 
tensor<A NAME="14441"></A>. It is a totally 
antisymmetric<A NAME="14442"></A> tensor with well defined contraction 
rules (see <A HREF="#substacontract">7.23</A>).

<P>

<H1><A ID="SECTION009180000000000000000"></A><A NAME="14445"></A><A NAME="14446"></A>
<A ID="funexp"></A>
<BR>
exp_
</H1>
Internal function with two arguments. Represents 
argument1 to the power argument2. Of course it is printed in the standard 
power notation.

<P>

<H1><A ID="SECTION009190000000000000000"></A><A NAME="14449"></A><A NAME="14450"></A>
<A ID="funexteuclidean"></A>
<BR>
exteuclidean_
</H1>

<P>
This is a number function. It expects two positive integer 
arguments. It then computes the Greatest Common Divider of these arguments 
with the use of the extended Euclidean algoritm. The answer will be in the 
same function but now there will be four arguments as in:
<PRE>
    Symbols x1,x2,x3,x4;
    Local F = exteuclidean_(54,84);
    Print;
    .sort

   F =
      exteuclidean_(54,84,-3,2);

    id exteuclidean_(x1?,x2?,x3?,x4?) = x1*x3+x2*x4;
    Print;
    .end

   F =
      6;
</PRE>
We can see that we obtain the GCD with the relation that is 
characteristic for the extended Euclidean algorithm. When the two arguments 
are relative prime, one obtains the so-called modinverses of these numbers:
<PRE>
    Symbols x1,x2,x3,x4,a,b;
    Local F = exteuclidean_(97,101);
    Print;
    .sort

   F =
      exteuclidean_(97,101,25,-24);

    id exteuclidean_(x1?,x2?,x3?,x4?) = x1*x3+x2*x4
        +a*mod2_(1/97,101)+b*mod2_(1/101,97);
    Print;
    .end

   F =
      1 - 24*b + 25*a;
</PRE>
Here 25 is the inverse of 97 when we calculate modulus 101 and 
-24 is the inverse of 101 when we calculate modulus 97.

<P>
This function can be very handy when a calculation has been done 
modulus various prime numbers and one would like to know the result modulus 
the product of these numbers. This combination is done with the aid of the 
Chinese remainder theorem<A NAME="14456"></A>:
<PRE>
   #procedure ChineseRemainder(NAME,NAME1,NAME2,M1,M2,PAR)
   *
   *   Assumes that NAME1 is an expression mod $M1
   *   Assumes that NAME2 is an expression mod $M2
   *   Creates $ch1r and $ch2r with the property that
   *   the expression NAME = NAME1*$ch1r+NAME2*$ch2rn
   *   is the corresponding equation mod $M1*$M2
   *
   Modulus 0; * we need to switch off previous settings.
   #$ch1r = exteuclidean_($`M1',$`M2');
   #inside $ch1r;
       id exteuclidean_(xxx1?,xxx2?,xxx3?,xxx4?) = xxx2*xxx4;
   #endinside;
   #$ch2r = exteuclidean_($`M1',$`M2');
   #inside $ch2r;
       id exteuclidean_(xxx1?,xxx2?,xxx3?,xxx4?) = xxx1*xxx3;
   #endinside;
   #$MM12 = $`M1'*$`M2';
   Modulus,plusmin,`$MM12';
   Local `NAME' = `NAME1i'*$ch1r+`NAME2i'*$ch2r;
   .sort
   *
   #endprocedure
</PRE>

<P>

<H1><A ID="SECTION009200000000000000000"></A><A NAME="14460"></A><A NAME="14461"></A>
<A ID="funextrasymbol"></A>
<BR>
extrasymbol_
</H1>

<P>
This function expects a single argument. This argument can be a 
number or an extra symbol(see <A HREF="#extrasymbols">2.11</A>). In either case the 
function is replaced by the expression that the corresponding extra symbol 
stands for.

<P>
If there are more arguments or the argument does not represent a 
legal extra symbol, no substitution is made.

<P>

<H1><A ID="SECTION009210000000000000000"></A><A NAME="14465"></A><A NAME="14466"></A>
<A ID="funfac"></A>
<BR>
fac_
</H1>
The factorial<A NAME="14468"></A> function. If it has a single nonzero 
integer argument n it is replaced by n! but if the result is bigger than 
the maximum allowable number an error will result.

<P>

<H1><A ID="SECTION009220000000000000000"></A><A NAME="14470"></A><A NAME="14471"></A>
<A ID="funfactorin"></A>
<BR>
factorin_
</H1>
When the argument is a single $-variable<A NAME="14473"></A> or 
an expression<A NAME="14474"></A> the function is replaced by the common 
factor in the terms of that <code>$</code>-variable or expression. This common 
factor consists in the first place of all symbolic objects that occur in 
all terms. In addition the numerical factor consists of the GCD<A NAME="14475"></A> 
of all numerators and the LCM<A NAME="14476"></A> of all denominators. Hence if the 
<code>$</code>-variable or expression is divided by the result of factorin_ all 
coefficients become integer.

<P>

<H1><A ID="SECTION009230000000000000000"></A><A NAME="14478"></A><A NAME="14479"></A>
<A ID="funfarg"></A>
<BR>
farg_
</H1>
For internal use only.

<P>

<H1><A ID="SECTION009240000000000000000"></A><A NAME="14482"></A><A NAME="14483"></A>
<A ID="funfirstbracket"></A>
<BR>
firstbracket_
</H1>
In the case that there is a single argument and this 
single argument is the name of an expression, this function is replaced by 
the part that is outside brackets in the first term of the expression. If 
there are no brackets the function is replaced by one.

<P>

<H1><A ID="SECTION009250000000000000000"></A><A NAME="14486"></A><A NAME="14487"></A>
<A ID="funfirstterm"></A>
<BR>
firstterm_
</H1>

<P>
This function expects the name of an expression or a dollar 
variable for its (single) argument. It will return the first term in this 
expression or dollar variable. When it has to obtain the first term of an 
expression, FORM uses the expression in the representation in which it was 
stored at the end of the previous module. If the expression did not exist 
in the previous module, it will attempt to use the expression as defined 
and processed in the current expression. If the expression has only been 
defined in the current module and has not yet been processed (as is the 
case when referring to the first term in the current expression) the answer 
will be unspecified. This use is considered illegal, even though it does 
not generate an error message.

<P>

<H1><A ID="SECTION009260000000000000000"></A><A NAME="14490"></A><A NAME="14491"></A>
<A ID="fungfive"></A>
<BR>
g5_
</H1>
The <SPAN CLASS="MATH"><IMG STYLE="height: 1.66ex; vertical-align: -0.56ex; " SRC="img48.svg"
 ALT="$\gamma_5$"></SPAN> Dirac gamma matrix. We assume here that it 
anticommutes with the other Dirac<A NAME="14493"></A> gamma<A NAME="14494"></A> 
matrices. Anybody who does not like that should program private libraries 
(this should not be too difficult with the cycle symmetric functions 
(see&nbsp;<A HREF="#substafunctions">7.62</A>). There should be a single index to indicate 
the spinline.

<P>

<H1><A ID="SECTION009270000000000000000"></A><A NAME="14497"></A><A NAME="14498"></A>
<A ID="fungsix"></A>
<BR>
g6_
</H1>
There should be a single index to indicate the spinline. 
As in Schoonschip<A NAME="14500"></A> we use <!-- MATH
 $\gamma_6 = 1+\gamma_5$
 -->
<SPAN CLASS="MATH"><IMG STYLE="height: 2.15ex; vertical-align: -0.56ex; " SRC="img46.svg"
 ALT="$\gamma_6 = 1+\gamma_5$"></SPAN>.

<P>

<H1><A ID="SECTION009280000000000000000"></A><A NAME="14502"></A><A NAME="14503"></A>
<A ID="fungseven"></A>
<BR>
g7_
</H1>
There should be a single index to indicate the spinline. 
As in Schoonschip<A NAME="14505"></A> we use <!-- MATH
 $\gamma_7 = 1-\gamma_5$
 -->
<SPAN CLASS="MATH"><IMG STYLE="height: 2.15ex; vertical-align: -0.56ex; " SRC="img47.svg"
 ALT="$\gamma_7 = 1-\gamma_5$"></SPAN>.

<P>

<H1><A ID="SECTION009290000000000000000"></A><A NAME="14507"></A><A NAME="14508"></A>
<A ID="fung"></A>
<BR>
g_
</H1>
The Dirac<A NAME="14510"></A> gamma<A NAME="14511"></A> matrix. Its 
first argument should be an index (either symbolic or numeric). Then follow 
zero, one or more indices to indicate a string of gamma matrices that 
belong together. Gamma matrices with the same first index are considered to 
belong together, but as long as the indices are symbolic no assumptions are 
made about whether they go together or not. Hence no commutation or 
anticommutation properties are applied for different spin lines unless the 
spinline indices are both numeric.

<P>

<H1><A ID="SECTION009300000000000000000"></A><A NAME="14513"></A><A NAME="14514"></A>
<A ID="fungcd"></A>
<BR>
gcd_
</H1>
<code>gcd_(x1,...,xn)</code> is replaced by the greatest common divisor 
of the arguments. The arguments can be any valid subexpressions, provided 
the whole function fits inside a term. When an argument is only an active 
expression or a $-expression it is only expanded during evaluation of the 
GCD. This way the contents of such expressions can exceed the maximum term 
size. One should however realize that in that case the operation takes 
place in allocated memory.
This function replaces the experimental function 
polygcd_<A NAME="14516"></A><A NAME="14517"></A> that existed in 
version 3.

<P>

<H1><A ID="SECTION009310000000000000000"></A><A NAME="14519"></A><A NAME="14520"></A>
<A ID="fungi"></A>
<BR>
gi_
</H1>
The unit Dirac gamma matrix. Should have a single index 
to indicate its spin line. Its is identical to a regular gamma matrix with 
no Lorenz indices: <code>gi_(n) = g_(n)</code>

<P>

<H1><A ID="SECTION009320000000000000000"></A><A NAME="14523"></A><A NAME="14524"></A>
<A ID="funid"></A>
<BR>
id_
</H1>
This function is a crossbreed between the 
replace_<A NAME="14526"></A>&nbsp;<A HREF="#funreplace">8.59</A> function and the id 
statement<A NAME="14528"></A>&nbsp;<A HREF="#substaidentify">7.68</A>. To become active it 
needs an even number of arguments. The odd numbered arguments can be 
anything of the types:
<DL>
<DT></DT>
<DD>a single symbol, possibly to an integer power.
</DD>
<DT></DT>
<DD>a single dotproducts, possibly to an integer power.
</DD>
<DT></DT>
<DD>a single function, possibly with any number and type of arguments.
</DD>
</DL>
When FORM encounters an id_ function the last step of normalizing a term 
is to replace the id function by a number substitutions in which the odd 
arguments are replaced by the following even arguments. These are not 
wildcard substitutions as in the replace_ function, but substitutions as 
in regular id statements. The matching of the odd arguments is done in a 
single step as in an id-al construction&nbsp;<A HREF="#substaalso">7.2</A>. Hence
<PRE>
    id_(x^2,y+z,y,u+v,x,z+u)
</PRE>
effectively becomes
<PRE>
    id x^2 = y+z;
    al y = u+v;
    al x = z+u;
</PRE>
FORM treats multiple occurrences of the id_ function one at a time. It 
takes the leftmost occurrence first, takes the patterns from the term, 
expands the right hand sides, tries to normalize the resulting terms and 
only then continues with the next id_ function. For this reason the id_ 
function is noncommuting.

<P>

<H1><A ID="SECTION009330000000000000000"></A><A NAME="14540"></A><A NAME="14541"></A>
<A ID="funinteger"></A>
<BR>
integer_
</H1>
This is a rounding<A NAME="14543"></A> function. It should have 
either one or two arguments. If there is a single argument and it is 
numeric, it will be rounded down to become an integer. If there are two 
arguments of which the first is numeric and the second is either 1, 0 or 
-1, the result will be the rounded value of the first argument. If the 
second argument is 1, the rounding will be down, when it is -1, the 
rounding will be up and when it is zero the rounding will be towards zero. 
In all other cases nothing is done.

<P>

<H1><A ID="SECTION009340000000000000000"></A><A NAME="14545"></A><A NAME="14546"></A>
<A ID="funinverse"></A>
<BR>
inverse_
</H1>
<code>inverse_(x1,x2)</code> expects two arguments which are 
polynomials in the same single variable. The return expression <SPAN CLASS="MATH"><IMG STYLE="height: 1.56ex; vertical-align: -0.45ex; " SRC="img94.svg"
 ALT="$x_3$"></SPAN> 
has the property that <SPAN CLASS="MATH"><IMG STYLE="height: 1.56ex; vertical-align: -0.45ex; " SRC="img95.svg"
 ALT="$x_1 x_3$"></SPAN> divided by <SPAN CLASS="MATH"><IMG STYLE="height: 1.56ex; vertical-align: -0.45ex; " SRC="img96.svg"
 ALT="$x_2$"></SPAN> has remainder 1. Or in 
other words: <SPAN CLASS="MATH"><IMG STYLE="height: 1.56ex; vertical-align: -0.45ex; " SRC="img94.svg"
 ALT="$x_3$"></SPAN> is the inverse of <SPAN CLASS="MATH"><IMG STYLE="height: 1.56ex; vertical-align: -0.45ex; " SRC="img97.svg"
 ALT="$x_1$"></SPAN> modulus <SPAN CLASS="MATH"><IMG STYLE="height: 1.56ex; vertical-align: -0.45ex; " SRC="img96.svg"
 ALT="$x_2$"></SPAN>.
The arguments can be any valid subexpressions, provided the whole function 
fits inside a term. When an argument is an active expression or a 
$-expression it is only expanded during the division. This way the 
contents of such expressions can exceed the maximum term size. One should 
however realize that in that case the operation takes place in allocated 
memory. 

<P>

<H1><A ID="SECTION009350000000000000000"></A><A NAME="14549"></A><A NAME="14550"></A>
<A ID="funinvfac"></A>
<BR>
invfac_
</H1>
One divided by the factorial<A NAME="14552"></A> function. If it has 
a single nonzero integer argument n, it is replaced by 1/n!, but if this 
results in a number bigger than the maximum allowable number an error will 
result.

<P>

<H1><A ID="SECTION009360000000000000000"></A><A NAME="14554"></A><A NAME="14555"></A>
<A ID="funmakerational"></A>
<BR>
makerational_
</H1>

<P>
This function takes two arguments. Both are integers. We assume 
calculus modulus the second argument. The function is then replaced by a 
fraction of which both elements are less than the square root of the second 
argument and that, in calculus modulus this second number would give the 
same result as the first number modulus the second number. Example:
<PRE>
    #$m = prime_(1);
    #write &lt;&gt; "The prime number is %$",$m
The prime number is 2147483587
    L	F = MakeRational_(12345678,$m);
    Print;
    .sort

   F =
      9719/38790;

    Modulus `$m';
    Print;
    .end

   F =
      12345678;
</PRE>
This function can be used to reconstruct fractions when calculus 
has been done modulus one or more prime numbers.

<P>

<H1><A ID="SECTION009370000000000000000"></A><A NAME="14560"></A><A NAME="14561"></A>
<A ID="funmatch"></A>
<BR>
match_
</H1>
Currently not active. Replaced automatically by 1.

<P>

<H1><A ID="SECTION009380000000000000000"></A><A NAME="14564"></A><A NAME="14565"></A>
<A ID="funmax"></A>
<BR>
max_
</H1>
If all its arguments are numeric, this function returns 
the maximum value of these arguments.

<P>

<H1><A ID="SECTION009390000000000000000"></A><A NAME="14568"></A><A NAME="14569"></A>
<A ID="funmaxpowerof"></A>
<BR>
maxpowerof_
</H1>
If this function has a single argument that is a symbol, it 
returns the maximum power restriction of this symbol. If none was given it 
will be the installation dependent value MAXPOWER which is 10000 on 
32<A NAME="14571"></A> bit machines and 500000000 on 64<A NAME="14572"></A> bit 
machines.

<P>

<H1><A ID="SECTION009400000000000000000"></A><A NAME="14574"></A><A NAME="14575"></A>
<A ID="funmin"></A>
<BR>
min_
</H1>
If all its arguments are numeric, this function returns 
the minimum value of these arguments.

<P>

<H1><A ID="SECTION009410000000000000000"></A><A NAME="14578"></A><A NAME="14579"></A>
<A ID="funminpowerof"></A>
<BR>
minpowerof_
</H1>
If this function has a single argument that is a symbol, it 
returns the minimum power restriction of this symbol. If none was given it 
will be the installation dependent value -MAXPOWER which is -10000 on 32 bit 
machines.

<P>

<H1><A ID="SECTION009420000000000000000"></A><A NAME="14582"></A><A NAME="14583"></A>
<A ID="funmod"></A>
<BR>
mod_
</H1>
If there are two integer arguments and the second 
argument is a positive short integer (less than <SPAN CLASS="MATH"><IMG STYLE="height: 2.14ex; vertical-align: -0.11ex; " SRC="img51.svg"
 ALT="$2^{15}$"></SPAN> on 32 bit 
computers and less than <SPAN CLASS="MATH"><IMG STYLE="height: 2.14ex; vertical-align: -0.11ex; " SRC="img52.svg"
 ALT="$2^{31}$"></SPAN> on 64 bit computers) the return value is 
the first argument modulus the second. Note that if the second argument is 
not a prime number and the first argument contains a denominator, division 
by zero could occur. It is up to the user to avoid such cases. See also the 
mod2_ function&nbsp;<A HREF="#funmod2">8.43</A> and the rem_ function&nbsp;<A HREF="#funrem">8.58</A>.

<P>
The function has one peculiarity: when the second argument is one, the 
function is left untouched.

<P>

<H1><A ID="SECTION009430000000000000000"></A><A NAME="14590"></A><A NAME="14591"></A>
<A ID="funmod2"></A>
<BR>
mod2_
</H1>
This gives basically the same action as the mod_ function (see 
<A HREF="#funmod">8.42</A>), but the answer will be in the range <SPAN CLASS="MATH"><IMG STYLE="height: 2.53ex; vertical-align: -0.69ex; " SRC="img98.svg"
 ALT="$-[(p-1)/2]$"></SPAN> to 
<SPAN CLASS="MATH"><IMG STYLE="height: 2.53ex; vertical-align: -0.69ex; " SRC="img99.svg"
 ALT="$+[(p+1)/2]$"></SPAN>.

<P>

<H1><A ID="SECTION009440000000000000000"></A><A NAME="14595"></A><A NAME="14596"></A>
<A ID="funmoebius"></A>
<BR>
moebius_
</H1>
The Moebius function. It has the property:

<UL>
<LI>moebius_(1) = 1
</LI>
<LI>moebius_(n) = 0 if n can be divided by the square of a prime number
</LI>
<LI>moebius_(n) = 1 if n contains an even number of different prime factors
</LI>
<LI>moebius_(n) = -1 if n contains an odd number of different prime factors
</LI>
</UL>
The number n must be a positive integer for the evaluation to take place. 
The argument should be no bigger than can be allowed by the biggest primes 
in Form. This means for a 64-bit computer arguments above <SPAN CLASS="MATH"><IMG STYLE="height: 2.14ex; vertical-align: -0.11ex; " SRC="img52.svg"
 ALT="$2^{31}$"></SPAN> may not 
give a correct result with the current algorithms that try for prime 
factors. There is a second algorithm that does not suffer from this 
problem:
<PRE>
    id moebius_(n) = 1-sum_(j,1,n-1,integer_(n/j)*moebius_(j));
</PRE>
but this algorithm needs all lower values and hence is inherently 
quadratic. Therefore we did not use it.

<P>

<H1><A ID="SECTION009450000000000000000"></A><A NAME="14604"></A><A NAME="14605"></A>
<A ID="funmul"></A>
<BR>
mul_
</H1>
<code>mul_(x,y)</code> is replaced by <code>x*y</code>, but internally
the multiplication is performed via polynomial routines introduced in
FORM version 4. This can be faster than the normal way of multiplications
for big polynomials: e.g., <code>mul_($x,$y)</code> where the $-variables <code>$x</code>
and <code>$y</code> store big polynomials.

<P>
A drawback is, because the polynomial routines accept only symbols, all
non-symbolic objects in the operands are temporarily translated to (commuting)
extra symbols. This process breaks the ordering of non-commutative objects
in the result.

<P>

<H1><A ID="SECTION009460000000000000000"></A><A NAME="14609"></A><A NAME="14610"></A>
<A ID="funnargs"></A>
<BR>
nargs_
</H1>
Is replaced by an integer indicating the number of 
arguments that the function has.

<P>

<H1><A ID="SECTION009470000000000000000"></A><A NAME="14613"></A><A NAME="14614"></A>
<A ID="funtonode"></A>
<BR>
node_
</H1>
For a description of this function, please see the section on 
diagrams&nbsp;<A HREF="#diagrams">21</A>.

<P>

<H1><A ID="SECTION009480000000000000000"></A><A NAME="14618"></A><A NAME="14619"></A>
<A ID="funnterms"></A>
<BR>
nterms_
</H1>
If this function has only one argument it is replaced by 
the number of terms inside this argument.

<P>

<H1><A ID="SECTION009490000000000000000"></A><A NAME="14622"></A><A NAME="14623"></A>
<A ID="funnumfactors"></A>
<BR>
numfactors_
</H1>

<P>
This function returns the number of factors in a factorized 
expression (see the chapter on polynomials&nbsp;<A HREF="#polynomials">11</A>) or dollar 
variable&nbsp;<A HREF="#dollars">6</A>. It expects a single argument which should be the 
name of an expression or a dollar variable. If the expression or dollar 
variable has not been factorized, the function returns zero.

<P>

<H1><A ID="SECTION009500000000000000000"></A><A NAME="14628"></A><A NAME="14629"></A>
<A ID="funpartitions"></A>
<BR>
partitions_
</H1>
This function generates all partitions of a list of arguments into
<SPAN CLASS="MATH"><IMG STYLE="height: 1.21ex; vertical-align: -0.11ex; " SRC="img84.svg"
 ALT="$n$"></SPAN> parts. Each part consists of a function name and a size.
This function exploits symmetries of the arguments to make sure that no argument
is generated twice. Instead, a combinatorial prefactor is computed.

<P>
The syntax distinguishes three cases:
<PRE>
1] partitions_(n,[function,n1,]_1,...,[function,nn,]_n,arguments)
2] partitions_(n,[function,n1,]_1,...,[function,0],arguments)
3] partitions_(0,function,n1,arguments)
</PRE>
In the first case, the first entry specifies the number of partitions <SPAN CLASS="MATH"><IMG STYLE="height: 1.21ex; vertical-align: -0.11ex; " SRC="img84.svg"
 ALT="$n$"></SPAN>.
It should be followed by <SPAN CLASS="MATH"><IMG STYLE="height: 1.21ex; vertical-align: -0.11ex; " SRC="img84.svg"
 ALT="$n$"></SPAN> parts, defined by a function name
and the number of arguments for that function. The final entries are the arguments
that will be distributed over the functions.
The number of arguments should be the same as the sum of
all the function argument sizes.
There are no restrictions on the type of arguments.

<P>
The second case is the same as the first, except that the last partition
has a 0 for the size. This means that any leftover arguments are collected
in this term. Thus partitions_(2,f1,3,f2,0,arguments) yields the same
as <SPAN  CLASS="texttt">distrib_(1,3,f1,f2,arguments)</SPAN>.

<P>
The third case, determined by a 0 for the number of partitions followed by one part, spreads
the arguments over a repeated instance of that part. Thus partitions_(0,f1,2,arguments) is similar to <SPAN  CLASS="texttt">dd_(arguments)</SPAN>.

<P>
In case of a deviation from the above rules, no action will be taken.
Some examples are given below:
<PRE>
partitions_(2,f1,2,f2,1,x1,x1,x3) =
       + f1(x1,x1)*f2(x3) + 2*f1(x1,x3)*f2(x1)
       ;
partitions_(3,f1,2,f2,1,f3,0,x1,x1,x1,x2,x2,x2) =
       + 3*f1(x1,x1)*f2(x1)*f3(x2,x2,x2)
       + 9*f1(x1,x1)*f2(x2)*f3(x1,x2,x2)
       + 18*f1(x1,x2)*f2(x1)*f3(x1,x2,x2)
       + 18*f1(x1,x2)*f2(x2)*f3(x1,x1,x2)
       + 9*f1(x2,x2)*f2(x1)*f3(x1,x1,x2)
       + 3*f1(x2,x2)*f2(x2)*f3(x1,x1,x1)
      ;
partitions_(0,f1,3,x1,x1,x1,x4,x5,x6) =
       + f1(x1,x1,x1)*f1(x4,x5,x6)
       + 3*f1(x1,x1,x4)*f1(x1,x5,x6)
       + 3*f1(x1,x1,x5)*f1(x1,x4,x6)
       + 3*f1(x1,x1,x6)*f1(x1,x4,x5)
      ;
</PRE>

<P>

<H1><A ID="SECTION009510000000000000000"></A><A NAME="14640"></A><A NAME="14641"></A>
<A ID="funpattern"></A>
<BR>
pattern_
</H1>
Currently not active. Replaced automatically by 1.

<P>

<H1><A ID="SECTION009520000000000000000"></A><A NAME="14644"></A><A NAME="14645"></A>
<A ID="funperm"></A>
<BR>
perm_
</H1>
Generates all permutations of the arguments, with exception 
of the first argument which should be the name of a function. This function 
will then have the permuted arguments as in:
<PRE>
    CFunction f;
    Symbols x1,...,x3;
    Local F = perm_(f,x1,x2,x3);
    Print +s;
    .end

   F =
       + f(x1,x2,x3)
       + f(x1,x3,x2)
       + f(x2,x1,x3)
       + f(x2,x3,x1)
       + f(x3,x1,x2)
       + f(x3,x2,x1)
       ;
</PRE>
The permutations are generated with an algorithm that takes subsequent 
cyclic permutations. If one puts a nonzero integer before the function 
argument the output terms will be multiplied by -1 when the permutation is 
odd.

<P>
When the function name is the only argument the answer will be just this 
function without arguments. One could argue that technically the answer 
should be zero, but this way the attention of the user may be attracted to 
the occurrence which might not be the case when the term 'just vanishes'. 
It is however rather simple to add a statement that makes such a function 
zero.

<P>

<H1><A ID="SECTION009530000000000000000"></A><A NAME="14650"></A><A NAME="14651"></A>
<A ID="funpoly"></A>
<BR>
poly_
</H1>
This was an experimental function in version 3. It was for 
internal use with a whole category of other experimental functions of which 
the functionality has been replaced by better working functions that are 
more general. This category included the functions 
polyadd_<A NAME="14653"></A><A NAME="14654"></A>,
polydiv_<A NAME="14655"></A><A NAME="14656"></A>,
polygcd_<A NAME="14657"></A><A NAME="14658"></A>,
polyintfac_<A NAME="14659"></A><A NAME="14660"></A>,
polymul_<A NAME="14661"></A><A NAME="14662"></A>,
polynorm_<A NAME="14663"></A><A NAME="14664"></A>,
polyrem_<A NAME="14665"></A><A NAME="14666"></A> and
polysub_<A NAME="14667"></A><A NAME="14668"></A>.
See also the chapter on polynomials&nbsp;<A HREF="#polynomials">11</A> and the functions 
gcd_&nbsp;<A HREF="#fungcd">8.30</A>, div_&nbsp;<A HREF="#fundiv">8.13</A> and rem_&nbsp;<A HREF="#funrem">8.58</A>.

<P>

<H1><A ID="SECTION009540000000000000000"></A><A NAME="14674"></A><A NAME="14675"></A>
<A ID="funprime"></A>
<BR>
prime_
</H1>

<P>
For a number of internal operations FORM needs prime numbers that 
are neither very large nor very small. Hence it generates, when needed 
prime numbers that still fit inside a single FORM word, but are maximal 
within that limitation. Hence for a 64-bits computer in which the largest 
positive `small' integer in FORM is <SPAN CLASS="MATH"><IMG STYLE="height: 2.33ex; vertical-align: -0.30ex; " SRC="img18.svg"
 ALT="$2^{31}-1$"></SPAN>, it works its way down from 
there. Once it has determined that a number is prime it stores it in a 
list. The function prime_ gives access to this list. The single argument 
n (n a positive integer) makes that <code>prime_(n)</code> will be replaced by 
the n-th member of the list. There is a limitation to the size of the list 
which is implementation dependent. The number will anyway never be smaller 
than the maximum power that is allowed for symbols. Example:
<PRE>
    Symbols x1,x2,x3,x4;
    ON highfirst;
    Local F = x1*prime_(1)+x2*prime_(2)
             +x3*prime_(3)+x4*prime_(4);
    Print;
    .end

   F =
      2147483587*x1 + 2147483579*x2 + 2147483563*x3 + 2147483549*x4;
</PRE>
This function is useful when calculations generate very large intermediate 
coefficients, but in the end the answer is relatively simple again. In that 
case one can do the calculation modulus one or more prime numbers. If more 
prime numbers are used the Chinese remainder theorem<A NAME="14680"></A>. can be used (see the exteuclidean_ 
function&nbsp;<A HREF="#funexteuclidean">8.19</A> to combine the results and the 
makerational_ function&nbsp;<A HREF="#funmakerational">8.36</A> can be used if fractions have 
to be reconstructed. An example of this kind of use is given in the simple 
Groebner basis procedure that is in the packages library in the FORM site.

<P>

<H1><A ID="SECTION009550000000000000000"></A><A NAME="14684"></A><A NAME="14685"></A>
<A ID="funputfirst"></A>
<BR>
putfirst_
</H1>

<P>
This function allows one to select a given argument by its number. The 
syntax is:
<PRE>
      putfirst_(functionname,numberofargument,arguments.....);
</PRE>
It will select the indicated argument in the argument field indicated by 
arguments and output this as the first argument in the indicated function. 
This argument will then be followed by the remaining arguments.
Example:
<PRE>
    S   a,a1,...,a10;
    CF  f,g;
    L   F = g(a,a1,...,a10);
    id  g(?a) = putfirst_(f,4,?a);
    Print;
    .end
   F =
      f(a3,a,a1,a2,a4,a5,a6,a7,a8,a9,a10);
</PRE>

<P>

<H1><A ID="SECTION009560000000000000000"></A><A NAME="14692"></A><A NAME="14693"></A>
<A ID="funrandom"></A>
<BR>
random_
</H1>
A random number generator. When the function has a single 
positive integer argument, the function will return a pseudo random number 
in the range of one to that number inclusive. Hence one can imitate a die 
roll with the call random_(6). The program uses a random number generator 
as described in vol 2 of the "Art of computer programming, vol2" by D. 
Knuth with the parameters set at 89,38 to give as long a cycle as possible. 
For very large numbers the program pastes several random numbers together. 
The generator can be initialized with the preprocessor 
#setrandom&nbsp;<A HREF="#presetrandom">3.54</A><A NAME="14696"></A> instruction. When running 
with TFORM or ParFORM each worker runs an independent generator with its 
own seed. The seeds of the workers are derived from the seed of the master 
and the number of the worker in a non-trivial way. It should be noted 
however that with workers it may be impossible to reproduce previous runs 
as it is non-deterministic which term ends up in which worker.

<P>

<H1><A ID="SECTION009570000000000000000"></A><A NAME="14698"></A><A NAME="14699"></A>
<A ID="funranperm"></A>
<BR>
ranperm_
</H1>
Generates a random permutation of the arguments, with exception 
of the first argument which should be the name of a function. This function 
will then have the permuted arguments as in:
<PRE>
    CFunction f;
    Symbols x1,...,x5;
    Local F = ranperm_(f,1,2,3,4,5,6)
             +ranperm_(f,x1,x2,x3+x1,x4,x5);
    Print +s;
    .end

   F =
       + f(x5,x1,x3 + x1,x4,x2)
       + f(3,1,6,2,4,5)
      ;
</PRE>
The permutation is generated with the same random number generator that is 
used by the function 
random_&nbsp;<A HREF="#funrandom">8.56</A><A NAME="14704"></A><A NAME="14705"></A> and hence 
is susceptible to the same initialization procedure that can be executed 
with the #setrandom&nbsp;<A HREF="#presetrandom">3.54</A><A NAME="14707"></A> instruction.

<P>

<H1><A ID="SECTION009580000000000000000"></A><A NAME="14709"></A><A NAME="14710"></A>
<A ID="funrem"></A>
<BR>
rem_
</H1>
<code>rem_(x1,x2)</code> is replaced by the remainder of the division 
of <SPAN CLASS="MATH"><IMG STYLE="height: 1.56ex; vertical-align: -0.45ex; " SRC="img97.svg"
 ALT="$x_1$"></SPAN> by <SPAN CLASS="MATH"><IMG STYLE="height: 1.56ex; vertical-align: -0.45ex; " SRC="img96.svg"
 ALT="$x_2$"></SPAN>. The arguments can be any valid subexpressions, provided 
the whole function fits inside a term. When an argument is only an active 
expression or a $-expression it is only expanded during the division. This 
way the contents of such expressions can exceed the maximum term size. One 
should however realize that in that case the operation takes place in 
allocated memory.
This function replaces the experimental function 
polyrem_<A NAME="14712"></A><A NAME="14713"></A> that existed in 
version 3.

<P>

<H1><A ID="SECTION009590000000000000000"></A><A NAME="14715"></A><A NAME="14716"></A>
<A ID="funreplace"></A>
<BR>
replace_
</H1>
This function defines a rather general purpose 
replacement<A NAME="14718"></A> mechanism. It should have pairs of 
arguments. Each pair consists of a single symbol, index, vector or 
function, followed by what this object should be replaced by in the entire 
term. Functions can only be replaced by functions, indices only by indices. 
A vector can be replaced by a single vector or by a vector like expression. 
A symbol can be replaced by a single symbol, a numerical expression or a 
complete subexpression that is not index like or vector like. This 
mechanism is sometimes needed to make replacements in ways that are very 
hard with the id<A NAME="14719"></A> statements because those do not make 
replacements automatically inside function arguments (see 
<A HREF="#substaidnew">7.69</A>). It also allows to exchange two variables as the 
replacements are executed simultaneously by the wildcard substitution 
mechanism.
<PRE>
    Multiply replace_(x,y,y,x);
</PRE>
will exchange x and y. Because there is no definite order in which multiple 
replace_ functions are treated, one should not use more than a single one 
at the same time inside a term. At times multiple replace_ functions may 
lead to confusion inside FORM.

<P>

<H1><A ID="SECTION009600000000000000000"></A><A NAME="14724"></A><A NAME="14725"></A>
<A ID="funreverse"></A>
<BR>
reverse_
</H1>
Can only occur as an argument of a function. Is replaced 
by the reversed string of its own arguments.

<P>

<H1><A ID="SECTION009610000000000000000"></A><A NAME="14728"></A><A NAME="14729"></A>
<A ID="funroot"></A>
<BR>
root_
</H1>
If we have <code>root_(n,x)</code> and <code>n</code> is a positive 
integer and <code>x</code> is a rational number and <code>y</code> is a rational number 
with <SPAN CLASS="MATH"><IMG STYLE="height: 2.23ex; vertical-align: -0.56ex; " SRC="img100.svg"
 ALT="$y^n = x$"></SPAN> (no imaginary numbers are considered and negative numbers 
are avoided if possible. Only one root is given) then <code>root_(n,x)</code> is 
replaced by <code>y</code>. This function was originally intended for internal 
use. Do not hold it against the author that <code>root_(2,1)</code> is replaced 
by <code>1</code>. In the case that it is needed the user should manipulate the 
sign or the complexity properties externally.

<P>

<H1><A ID="SECTION009620000000000000000"></A><A NAME="14732"></A><A NAME="14733"></A>
<A ID="funsetfun"></A>
<BR>
setfun_
</H1>
Currently not active.

<P>

<H1><A ID="SECTION009630000000000000000"></A><A NAME="14736"></A><A NAME="14737"></A>
<A ID="funsig"></A>
<BR>
sig_
</H1>
Is replaced by the sign of the (numerical) argument, i.e. by -1 
if there is a single negative argument and by +1 if there is a single 
numerical argument that is greater or equal to zero.

<P>

<H1><A ID="SECTION009640000000000000000"></A><A NAME="14740"></A><A NAME="14741"></A>
<A ID="funsign"></A>
<BR>
sign_
</H1>
<code>sign_(n)</code> is replaced by <code>(-1)^n</code> if n is an 
integer.

<P>

<H1><A ID="SECTION009650000000000000000"></A><A NAME="14744"></A><A NAME="14745"></A>
<A ID="funsizeof"></A>
<BR>
sizeof_
</H1>
If there is a single argument and this argument is the name of an 
active (or previously active during the current job) expression, the 
function is replaced by the number<A NAME="14747"></A> of FORM
words in this expression. Stored expressions that were entered via a load 
statement (see <A HREF="#substaload">7.83</A>) are excluded from this because for them 
this information is not readily available.

<P>

<H1><A ID="SECTION009660000000000000000"></A><A NAME="14750"></A><A NAME="14751"></A>
<A ID="funsum"></A>
<BR>
sum_
</H1>
General purpose sum<A NAME="14753"></A> function. The first argument should 
be the summation parameter (a symbol). The second argument is the starting 
point of summation, the third argument the `upper' limit and a potential 
fourth argument the increment. These numbers should all be integers. 
Summation stops when the summation parameter obtains a value that has 
passed the upper limit. The last argument is the summand, the object to be 
summed over. It can be any subexpression. If it contains the summation 
parameter, it will be replaced by its value for each generated term. 
Examples:
<PRE>
    sum_(j,1,4,sign_(j)*x^j/j)
    sum_(i,1,9,2,sign_((i-1)/2)*x^i*invfac_(i))
</PRE>

<P>

<H1><A ID="SECTION009670000000000000000"></A><A NAME="14757"></A><A NAME="14758"></A>
<A ID="funsump"></A>
<BR>
sump_
</H1>
Special sum function. Its arguments are like for the 
sum_ function, but each new term is the product of the previously 
generated term with the last argument in which the current value of the 
summation parameter has been substituted. The first term is always one. 
Example:
<PRE>
    Symbol i,x;
    Local F = sump_(i,0,5,x/i);
    Print;
    .end

   F =
      1 + x + 1/2*x^2 + 1/6*x^3 + 1/24*x^4 + 1/120*x^5;
</PRE>
This function is a leftover from the Schoonschip<A NAME="14762"></A> days. 
The ordinary sum_ function is much more readable.

<P>

<H1><A ID="SECTION009680000000000000000"></A><A NAME="14764"></A><A NAME="14765"></A>
<A ID="funtable"></A>
<BR>
table_
</H1>
For action the arguments should be the name of a table and then 
either the name of a function or one symbol for each dimension of the 
table. In the case of the list of symbols the return value will be a 
monomial in the given symbols in which the powers of the symbols correspond 
to the table indices of the defined table elements with the coefficients 
the table contents corresponding to those indices. In the case of a 
function name the return value will be a sum over terms in which the table 
elements are indicated by arguments in the given function while these 
functions are then multiplied by the corresponding table elements. This is 
one way to put a complete table inside an expression and store it (with the 
save statement of <A HREF="#substasave">7.127</A>) in a binary way for a future run in 
which the table can be filled again with the 
fillexpression<A NAME="14768"></A> (see <A HREF="#substafillexpression">7.58</A>) 
statement. Note that for obvious reasons one should avoid using symbols or 
functions that also occur inside the table definitions.

<P>

<H1><A ID="SECTION009690000000000000000"></A><A NAME="14771"></A><A NAME="14772"></A>
<A ID="funtbl"></A>
<BR>
tbl_
</H1>
This function is the `table stub function' as used by the 
tablebase<A NAME="14774"></A> construction. This is explained in chapter 
<A HREF="#tablebase">12</A>. It is mainly for internal use, but it could occur in the 
output.

<P>

<H1><A ID="SECTION009700000000000000000"></A><A NAME="14777"></A><A NAME="14778"></A>
<A ID="funterm"></A>
<BR>
term_
</H1>
This function has no arguments. It is replaced by the current 
term. It can be used to load the current term into a dollar variable as in
<PRE>
   $x = term_;
</PRE>

<P>

<H1><A ID="SECTION009710000000000000000"></A><A NAME="14783"></A><A NAME="14784"></A>
<A ID="funtermsin"></A>
<BR>
termsin_
</H1>
If there is a single argument and this argument is the name of an 
active (or previously active during the current job) expression, the 
function is replaced by the number<A NAME="14786"></A> of terms in this 
expression. Stored expressions that were entered via a load statement (see 
<A HREF="#substaload">7.83</A>) are excluded from this because for them FORM would have 
to actually count the terms.

<P>

<H1><A ID="SECTION009720000000000000000"></A><A NAME="14789"></A><A NAME="14790"></A>
<A ID="funtermsinbracket"></A>
<BR>
termsinbracket_
</H1>
If there is no argument, or the single argument is zero, the 
function is replaced by the number of terms in the current 
bracket<A NAME="14792"></A>, provided the expression has been bracketed at its 
last sort and a keep brackets statement (see <A HREF="#substakeep">7.80</A>) has been 
used. Note that the terms have to be counted. Hence this is a relatively 
expensive command. More options will be implemented in the future.

<P>

<H1><A ID="SECTION009730000000000000000"></A><A NAME="14795"></A><A NAME="14796"></A>
<A ID="funtheta"></A>
<BR>
theta_
</H1>
If there is a single numerical argument x the function is 
replaced by one if <SPAN CLASS="MATH"><IMG STYLE="height: 2.02ex; vertical-align: -0.42ex; " SRC="img101.svg"
 ALT="$x \ge 0$"></SPAN> and by zero if <SPAN CLASS="MATH"><IMG STYLE="height: 1.79ex; vertical-align: -0.20ex; " SRC="img102.svg"
 ALT="$x &lt; 0$"></SPAN>. If there are two 
numerical arguments <SPAN CLASS="MATH"><IMG STYLE="height: 1.56ex; vertical-align: -0.45ex; " SRC="img97.svg"
 ALT="$x_1$"></SPAN> and <SPAN CLASS="MATH"><IMG STYLE="height: 1.56ex; vertical-align: -0.45ex; " SRC="img96.svg"
 ALT="$x_2$"></SPAN> the function is replaced by one if <SPAN CLASS="MATH"><IMG STYLE="height: 1.56ex; vertical-align: -0.45ex; " SRC="img103.svg"
 ALT="$x_1
= x_2$"></SPAN> or if the arguments are in natural order (if theta_ would be a 
symmetric function there would be no reason to exchange the arguments) and 
by zero if the arguments are not in natural order (they would be exchanged 
in a symmetric function). In all other cases nothing is done.

<P>

<H1><A ID="SECTION009740000000000000000"></A><A NAME="14799"></A><A NAME="14800"></A>
<A ID="funthetap"></A>
<BR>
thetap_
</H1>
If there is a single numerical argument x the function is 
replaced by one if <SPAN CLASS="MATH"><IMG STYLE="height: 1.79ex; vertical-align: -0.20ex; " SRC="img104.svg"
 ALT="$x &gt; 0$"></SPAN> and by zero if <SPAN CLASS="MATH"><IMG STYLE="height: 2.02ex; vertical-align: -0.42ex; " SRC="img105.svg"
 ALT="$x \le 0$"></SPAN>. If there are two 
numerical arguments <SPAN CLASS="MATH"><IMG STYLE="height: 1.56ex; vertical-align: -0.45ex; " SRC="img97.svg"
 ALT="$x_1$"></SPAN> and <SPAN CLASS="MATH"><IMG STYLE="height: 1.56ex; vertical-align: -0.45ex; " SRC="img96.svg"
 ALT="$x_2$"></SPAN> the function is replaced by zero if <SPAN CLASS="MATH"><IMG STYLE="height: 1.56ex; vertical-align: -0.45ex; " SRC="img103.svg"
 ALT="$x_1
= x_2$"></SPAN> or if the arguments are not in natural order. If the arguments are 
in natural order the function is replaced by one. In all other cases 
nothing is done.

<P>

<H1><A ID="SECTION009750000000000000000"></A><A NAME="14803"></A><A NAME="14804"></A>
<A ID="funtopologies"></A>
<BR>
topologies_
</H1>
For a description of this function, please see the section on 
diagrams&nbsp;<A HREF="#diagrams">21</A>.

<P>

<H1><A ID="SECTION009760000000000000000">
Extra reserved names</A>
</H1>

<P>
In addition there are some names that have been reserved for 
future use. At the moment these functions do not do very much. It is hoped 
that in the future some simplifications of the arguments can be 
implemented. These functions are:

<P>
<TABLE   STYLE="width:136;">
<TR><TD>sqrt_
</TD></TR>
</TABLE>
<BR><A NAME="14810"></A><A NAME="14811"></A>
<TABLE   STYLE="width:590;">
<TR><TD>The regular square root.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:136;">
<TR><TD>ln_
</TD></TR>
</TABLE>
<BR><A NAME="14816"></A><A NAME="14817"></A>
<TABLE   STYLE="width:590;">
<TR><TD>The natural logarithm.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:136;">
<TR><TD>sin_
</TD></TR>
</TABLE>
<BR><A NAME="14822"></A><A NAME="14823"></A>
<TABLE   STYLE="width:590;">
<TR><TD>The sine function.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:136;">
<TR><TD>cos_
</TD></TR>
</TABLE>
<BR><A NAME="14828"></A><A NAME="14829"></A>
<TABLE   STYLE="width:590;">
<TR><TD>The cosine function.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:136;">
<TR><TD>tan_
</TD></TR>
</TABLE>
<BR><A NAME="14834"></A><A NAME="14835"></A>
<TABLE   STYLE="width:590;">
<TR><TD>The tangent function.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:136;">
<TR><TD>asin_
</TD></TR>
</TABLE>
<BR><A NAME="14840"></A><A NAME="14841"></A>
<TABLE   STYLE="width:590;">
<TR><TD>The inverse of the sine function.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:136;">
<TR><TD>acos_
</TD></TR>
</TABLE>
<BR><A NAME="14846"></A><A NAME="14847"></A>
<TABLE   STYLE="width:590;">
<TR><TD>The inverse of the cosine function.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:136;">
<TR><TD>atan_
</TD></TR>
</TABLE>
<BR><A NAME="14852"></A><A NAME="14853"></A>
<TABLE   STYLE="width:590;">
<TR><TD>The inverse of the tangent function.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:136;">
<TR><TD>atan2_
</TD></TR>
</TABLE>
<BR><A NAME="14858"></A><A NAME="14859"></A>
<TABLE   STYLE="width:590;">
<TR><TD>Another inverse of the tangent function.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:136;">
<TR><TD>sinh_
</TD></TR>
</TABLE>
<BR><A NAME="14864"></A><A NAME="14865"></A>
<TABLE   STYLE="width:590;">
<TR><TD>The hyperbolic sine function.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:136;">
<TR><TD>cosh_
</TD></TR>
</TABLE>
<BR><A NAME="14870"></A><A NAME="14871"></A>
<TABLE   STYLE="width:590;">
<TR><TD>The hyperbolic cosine function.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:136;">
<TR><TD>tanh_
</TD></TR>
</TABLE>
<BR><A NAME="14876"></A><A NAME="14877"></A>
<TABLE   STYLE="width:590;">
<TR><TD>The hyperbolic tangent function.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:136;">
<TR><TD>asinh_
</TD></TR>
</TABLE>
<BR><A NAME="14882"></A><A NAME="14883"></A>
<TABLE   STYLE="width:590;">
<TR><TD>The inverse of the hyperbolic sine function.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:136;">
<TR><TD>acosh_
</TD></TR>
</TABLE>
<BR><A NAME="14888"></A><A NAME="14889"></A>
<TABLE   STYLE="width:590;">
<TR><TD>The inverse of the hyperbolic cosine function.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:136;">
<TR><TD>atanh_
</TD></TR>
</TABLE>
<BR><A NAME="14894"></A><A NAME="14895"></A>
<TABLE   STYLE="width:590;">
<TR><TD>The inverse of the hyperbolic tangent function.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:136;">
<TR><TD>li2_
</TD></TR>
</TABLE>
<BR><A NAME="14900"></A><A NAME="14901"></A>
<TABLE   STYLE="width:590;">
<TR><TD>The dilogarithm function.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:136;">
<TR><TD>lin_
</TD></TR>
</TABLE>
<BR><A NAME="14906"></A><A NAME="14907"></A>
<TABLE   STYLE="width:590;">
<TR><TD>The polylogarithm function.</TD></TR>
</TABLE>
    <BR>

<P>
The user is allowed to use these functions, but it could be that 
in the future they will develop a nontrivial behaviour. Hence caution is 
required.

<P>

<H1><A ID="SECTION001000000000000000000"></A>
<A ID="brackets"></A>
<BR>
Brackets
</H1>

<P>
At times one would like to order the output in a specific way. In an 
expression which is for instance a polynomial in terms of the symbol <SPAN CLASS="MATH"><IMG STYLE="height: 1.21ex; vertical-align: -0.11ex; " SRC="img106.svg"
 ALT="$x$"></SPAN>, 
one might want to make this behaviour in terms of <SPAN CLASS="MATH"><IMG STYLE="height: 1.21ex; vertical-align: -0.11ex; " SRC="img106.svg"
 ALT="$x$"></SPAN> more apparent by 
printing the output in such a way, that all powers of <SPAN CLASS="MATH"><IMG STYLE="height: 1.21ex; vertical-align: -0.11ex; " SRC="img106.svg"
 ALT="$x$"></SPAN> are outside 
parentheses<A NAME="15522"></A>, and the whole rest is inside parentheses. 
This is done with the bracket<A NAME="15523"></A> statement:
<PRE>
    Bracket x;
</PRE>
or in short notation
<PRE>
    B x;
</PRE>
One can specify more than one object in the bracket statement, but only a 
single bracket statement (the last one) is considered. Bracket statements 
belong to the module in which they occur. Hence they are forgotten after 
the next end-of-module.

<P>
If a vector is mentioned in a bracket statement, 
all occurrences of this vector as a loose vector, a vector with any index, 
inside a dotproduct, or inside a tensor are taken outside brackets. If the 
vector occurs inside a non-commuting tensor, all other non commuting 
objects that are to the left of this tensor will also be taken outside the 
parentheses.

<P>
When a function or tensor is mentioned in a bracket statement, it is not 
allowed to have any arguments in the bracket statement. All occurrences of 
this function will be pulled outside brackets. If the function is 
non-commuting, all other functions and/or tensors that are non-commuting 
and are to the left of the specific function(s) or tensor(s) will also be 
outside parentheses.

<P>
The opposite of the bracket statement is the antibracket<A NAME="15528"></A> 
statement:
<PRE>
    AntiBracket x;
</PRE>
or
<PRE>
    ABracket x;
</PRE>
or
<PRE>
    AB x;
</PRE>
This statement causes also brackets in the output, but now everything is 
put outside brackets, except for powers of x and coefficients. This way one 
can make the <SPAN CLASS="MATH"><IMG STYLE="height: 1.21ex; vertical-align: -0.11ex; " SRC="img106.svg"
 ALT="$x$"></SPAN>-dependence apparent differently.

<P>
Because the bracket statement causes a different ordering of the terms when 
storing the expression, one can use this ordering in the next module. There 
are various ways to do this.

<P>
One can use the contents of a given bracket in a r.h.s. expression as in
<PRE>
    Symbols a,b,c,x;
    L  F = a*x^2+b*x+c;
    B x;
    .sort
    L  Discriminant = F[x]^2-4*F[x^2]*F[1];
    Print;
    .end
</PRE>
The outside of the bracket is placed between braces<A NAME="15537"></A> after the 
name of the expression. The bracket that has nothing outside is referred to 
with the number 1. If a bracket is empty, its contents will be represented 
by the value zero.

<P>
The regular algorithm by which FORM finds brackets in an expression, is 
to start from the beginning and inspect each term until it finds the 
appropriate bracket. This is fully in the spirit of the sequential 
treatment of expressions in FORM. This can however be rather 
slow<A NAME="15540"></A> in big 
expressions that reside on a disk. Hence there is the bracket<A NAME="15541"></A> 
index<A NAME="15542"></A> 
feature. It is invoked by putting a <SPAN CLASS="MATH"><IMG STYLE="height: 1.75ex; vertical-align: -0.30ex; " SRC="img7.svg"
 ALT="$+$"></SPAN>-sign after the bracket (or B) 
statement as in 
<PRE>
    Bracket+ x;
</PRE>
or
<PRE>
    B+ x;
</PRE>
This option causes FORM to build a tree of (disk) positions for the 
different brackets, with the condition that the whole storage of this tree 
of brackets does not exceed a given maximum space, named 
`bracketindexsize'<A NAME="15548"></A> 
(see chapter&nbsp;<A HREF="#setup">17</A> on the setup parameters). 
If the index would need more space FORM will start 
skipping brackets in the index. This means that it will have to look for 
the bracket in a sequential fashion, but starting from the position 
indicated by the previous bracket in the index. This will still be very 
fast, provided the index is not very small.

<P>
When the bracket index option is used, FORM will not compress the 
expressions that use such an index with the zlib compression, even if the 
user asked for this in an earlier statement. The use of the index indicates 
that the brackets are going to be used intensively, and hence the 
continuous decompression that would result would destroy most of the profit 
that comes from the index. If the brackets are only for cosmetics in the 
output, it is better not to use the index option. It does use resources to 
construct the index<A NAME="15551"></A> tree<A NAME="15552"></A>. Also when 
brackets are only used sequentially as in the features discussed below, the 
presence of the index is not beneficial. It should only be applied when 
contents of brackets are used in the above way (like with the 
discriminant).

<P>
There are several statements that make use of the bracket ordering:

<UL>
<LI>Keep<A NAME="15554"></A> Brackets;
	This statement takes from the input one term at a time as usual, but 
then it takes the part outside the brackets, executes the statements of the 
module only on that part of the term, and then, when all statements of the 
module have had their effect, the resulting term(s) is/are multiplied by 
the full content of the bracket. The next term taken from the input will be 
the first term of the next bracket. This way one can hide part of the terms 
for the pattern matcher. Also one can avoid that the same matching will 
occur many times, as in an expression of the type
<PRE>
      + f(y)*(x+x^2+x^3+x^4+1)
</PRE>
If we would want to make a replacement of the type
<PRE>
    Keep Brackets;
    id f?{f1,f2,f3}(u?) = f(u+1)/u;
</PRE>
the pattern matching and the substitution would have to be done only once, 
rather than 5 times, as would be the case if the Keep bracket statement 
would not be used.
</LI>
<LI>Collect<A NAME="15559"></A> FunctionName;
	The contents of the various brackets will be placed inside a function 
with the given name. Hence
<PRE>
      + f(y)*(x+x^2+x^3+x^4+1)
      + f(y^2)*(x+2*x^2+3*x^3+4*x^4+1)
</PRE>
with
<PRE>
    Collect h;
</PRE>
would result in:
<PRE>
      + f(y)*h(x+x^2+x^3+x^4+1)
      + f(y^2)*h(x+2*x^2+3*x^3+4*x^4+1)
</PRE>
This can be very useful to locate <SPAN CLASS="MATH"><IMG STYLE="height: 1.21ex; vertical-align: -0.11ex; " SRC="img106.svg"
 ALT="$x$"></SPAN>-dependence even further, because 
bracketing the new expression in terms of <SPAN CLASS="MATH"><IMG STYLE="height: 1.82ex; vertical-align: -0.11ex; " SRC="img107.svg"
 ALT="$h$"></SPAN> could make very clear 
whether a given polynomial in <SPAN CLASS="MATH"><IMG STYLE="height: 1.21ex; vertical-align: -0.11ex; " SRC="img106.svg"
 ALT="$x$"></SPAN> would factor the whole expression, or 
which factors are occurring. To bring <code>h(x+1)</code> and <code>h(2*x+2)</code> to 
multiples of the same objects one should consult the pages on the 
normalize<A NAME="15566"></A> 
(<A HREF="#substanormalize">7.97</A>) 
and makeinteger<A NAME="15568"></A> (<A HREF="#substamakeinteger">7.85</A>) statements.

<P>
The Collect statement, together with the PolyFun<A NAME="15570"></A> statement, 
can also be very useful, if the variable <SPAN CLASS="MATH"><IMG STYLE="height: 1.21ex; vertical-align: -0.11ex; " SRC="img106.svg"
 ALT="$x$"></SPAN> (or other variables) is 
temporarily not playing much of a role in the pattern matching. It can make 
the program much faster.

<P>
For more information on the collect statement one should consult 
section&nbsp;<A HREF="#substacollect">7.19</A>.
</LI>
</UL>

<P>
Restrictions: The bracket index can only be used with active expressions. 
Hence the access of specific brackets in stored expressions will always be 
of the slow variety. To make it faster, one can copy the expression into a 
local expression with indexed brackets, use it, and drop the expression 
when it is not needed any longer.

<P>
The brackets can also be used to save space on the disk in problems in 
which the expressions become rather large. Let us assume the following 
simple problem:
<PRE>
    Symbols x1,...,x12;
    Local F = (x1+...+x12)^10;
    .sort
    id  x1 = x4+x7;
    .end
</PRE>
If the program is run like this the expression F contains 352716 terms 
after the sort and after the id the sorting in the .end results in a final 
stage sort<A NAME="15575"></A> of which the statistics are:
<PRE>
Time =      46.87 sec
                F        Terms active    =     504240
                         Bytes used      =   13462248

Time =      52.09 sec    Generated terms =     646646
                F        Terms in output =     184756
                         Bytes used      =    4883306
</PRE>
We see, that the intermediate sort file still contains more than 500000 
terms and more than 13 Mbytes, while the final result contains less than 5 
Mbytes. Why is this? When the terms in FORM are sorted first come the 
powers of <code>x1</code>, because this is the variable that was declared first. 
Hence the terms that do not have powers of <code>x1</code> come much later in the 
input and will not be compared with the terms generated by the substitution 
of for instance a single power of <code>x1</code> until very late in the sorting. 
What can we do about this? We can try to group the terms in the first sort 
such that after the substitution like terms will be `very close' to each 
other and hence will add quickly. This is done in the program
<PRE>
    Symbols x1,...,x12;
    Local F = (x1+...+x12)^10;
    AntiBracket x1,x4,x7;
    .sort
    id  x1 = x4+x7;
    .end
</PRE>
Now all powers of the mentioned variables will be inside the brackets and 
all other variables will be outside. Because the terms inside the brackets 
are all following each other in the input of the second module, terms that 
will add will be generated closely together.
The result is visible in the final statistics:
<PRE>
Time =      47.23 sec
                F        Terms active    =     184761
                         Bytes used      =    4928008

Time =      48.40 sec    Generated terms =     646646
                F        Terms in output =     184756
                         Bytes used      =    4883306
</PRE>
Now the final step of the sorting has already almost the proper number of 
terms. The difference is due to brackets that are half in one `patch' on 
the disk and half in the next `patch' (for the meaning of the patches, one 
should read the part about sorting<A NAME="15582"></A> in chapter&nbsp;<A HREF="#setup">17</A> on 
the setup file. It should be rather clear now that this saves disk space 
and the corresponding amount of time. These early cancellations can also be 
seen in the first statistics message of the second module. In the first 
case it is
<PRE>
Time =      19.76 sec    Generated terms =      10431
                F   5216 Terms left      =       8065
                         Bytes used      =     239406
</PRE>
and in the second case it is
<PRE>
Time =      22.82 sec    Generated terms =      10124
                F   5835 Terms left      =       3186
                         Bytes used      =      96678
</PRE>
This also causes a more efficient use of the large buffer and again a 
better use of the disk. There have been cases in which this `trick' was 
essential to keep the sort file inside the available disk space.

<P>

<H1><A ID="SECTION001100000000000000000"></A>
<A ID="optimization"></A>
<BR>
Output optimization
</H1>

<P>
One of the uses of symbolic programs is to prepare formulas for further 
numerical processing<A NAME="15640"></A>. Technically speaking such 
processing is not part of computer algebra, although some packages may 
provide facilities for this. In FORM such facilities, such as
Monte Carlo integration, do not exist at the moment, but, starting with 
version 4.1, FORM does provide statements to construct outputs in C or 
Fortran that are highly optimized with respect to the number of arithmetic 
operations<A NAME="15641"></A> that are needed for their 
evaluation. The algorithms used for this are described in the papers

<UL>
<LI>Code Optimization in FORM - <kbd><A ID="tex2html1"
  HREF="https://arxiv.org/abs/1310.7007">https://arxiv.org/abs/1310.7007</A></kbd>
</LI>
<LI>Improving multivariate Horner schemes with Monte Carlo tree search - <kbd><A ID="tex2html2"
  HREF="https://arxiv.org/abs/1207.7079">https://arxiv.org/abs/1207.7079</A></kbd>
</LI>
<LI>Combining Simulated Annealing and Monte Carlo Tree Search for Expression Simplification - <kbd><A ID="tex2html3"
  HREF="https://arxiv.org/abs/1312.0841">https://arxiv.org/abs/1312.0841</A></kbd>
</LI>
<LI>Why Local Search Excels in Expression Simplification - <kbd><A ID="tex2html4"
  HREF="https://arxiv.org/abs/1409.5223">https://arxiv.org/abs/1409.5223</A></kbd>
</LI>
</UL>
In short, an optimal Horner scheme is constructed after
which common subexpressions are eliminated. The methods for finding the
optimal scheme can use a simple heuristic, Monte Carlo Tree Search,
or a Stochastic Local Search approach such as Simulated Annealing

<P>
In this section the precise 
format of the commands that concern the optimizations will be described.
In optimized output FORM needs temporary variables<A NAME="15648"></A>. In order to avoid conflicts with user defined objects FORM 
uses the extra symbols <A HREF="#substaextrasymbols">7.53</A><A NAME="15650"></A> for 
these variables. This means that the user can control their output 
representation in the standard way. In addition there are preprocessor 
variables that tell how many of these extra symbols were needed:
<DL>
<DT><STRONG>optimminvar_</STRONG></DT>
<DD>The number of extra symbols before the optimization 
process started<A NAME="15652"></A>.
</DD>
<DT><STRONG>optimmaxvar_</STRONG></DT>
<DD>The number of extra symbols after the optimization 
process finished<A NAME="15653"></A>.
</DD>
</DL>
Each new optimization will remove the old optimization results and start 
the extra symbols from the number there were before the optimization 
started. Because this may cause interference with the functioning of the 
extrasymbol statement, regular printing with output optimization and the 
extrasymbol statement cannot occur inside the same module. Such occurrence 
would result in an error message.

<P>
Because the output optimization is done for expressions that contain only 
symbols<A NAME="15655"></A>, FORM has to convert all non-symbols and negative 
powers of symbols to extra symbols<A NAME="15656"></A> before it starts 
the optimization. This is another reason why interference between the 
extrasymbol <A HREF="#substaextrasymbols">7.53</A><A NAME="15658"></A> statement and 
output optimizations is forbidden. When the results are printed, the 
definition of the extra symbols that are introduced this way are printed as 
well.

<P>
FORM has two ways to perform optimizations. The first and easiest is in 
the regular output. If one asks for optimization (by specifying the proper 
format for this) and follows this by a print statement, the output printed 
will be in optimized form. This is however just a representation of the 
expression and the next module will obtain the original expression for its 
input.

<P>
The more useful way to obtain an optimized output is with the #optimize 
instruction. To use this instruction properly one should understand what 
FORM does when it optimizes an expression. The whole process of 
optimization takes place inside the memory. Hence, FORM cannot optimize 
expressions that do not fit inside the CPU memory. The notation is however 
fairly compact and FORM needs far less space than for instance the 
compiler (and gives better results). The result of the optimization is 
stored inside a buffer. There is only a single optimization 
buffer<A NAME="15659"></A> and the preprocessor variables 
optimminvar_<A NAME="15660"></A> and optimmaxvar_<A NAME="15661"></A> 
refer to the contents of this buffer. When the #optimize instruction is 
used it loads this buffer and the contents stay around until either a 
#clearoptimize instruction is used or a new #optimize instruction is 
issued.

<P>
The #optimize instruction changes the original expression to its optimized 
shape in which it is usually a very short expression that refers to one or 
more extra symbols. The optimization information is automatically erased, 
and with it the expression that was optimized, when a second #optimize 
instruction is issued. Clearing the optimization buffer means that the 
information of the first expression is irretrievably lost and the contents 
of the first expression become meaningless, because its extra symbols have 
been erased. Hence if the user still needs this expression it is necessary 
to make a copy of it before optimization.

<P>
The optimization buffers, and the optimized expression, can be removed by 
the user with the #clearoptimize instruction. This is mandatory before the 
use of a ToPolynomial <A HREF="#substatopolynomial">7.148</A><A NAME="15663"></A> 
statement, because that may introduce new extra symbols.

<P>
The contents of the optimization buffer<A NAME="15664"></A> can be 
written with the %O combination in the format string in the #write 
instruction. This means that it is easy to write this output to file. 
Consider for instance the following program:
<PRE>
   CF  f;
   S   a,b,c;
   L   H = f(a)+f(b)+(a+b+c)^2;
   L   G = f(c)+(a+b+c)^3;
   Format O2;
   Print +f;
   .sort
   ExtraSymbols,array,w;
   Format Fortran;
   #optimize G
   #write &lt;outg.f&gt; "      REAL*8 w(`optimmaxvar_')"
   #write &lt;outg.f&gt; "%O"
   #write &lt;outg.f&gt; "      G = %e",G
   #clearoptimize
   .sort
   #optimize H
   #write &lt;outh.f&gt; "      REAL*8 w(`optimmaxvar_')"
   #write &lt;outh.f&gt; "%O"
   #write &lt;outh.f&gt; "      H = %e",H
   .end
</PRE>
This program shows the two different methods and shows what is left of the 
expressions G and H. It also shows that we have to deal with the 
expressions one by one when we use the #optimize instruction, while in the 
regular printing of the output this is not needed because the expression 
itself remains in its unoptimized version.

<P>

<H2><A ID="SECTION001101000000000000000">
Optimization options of the Format statement</A>
</H2>

<P>
The <code>Format</code> statement has a number of options to control the
code optimization. The easiest to use are the following:

<P>
<DL>
<DT><STRONG>O0</STRONG></DT>
<DD>Switches off all optimizations and prints the output the
  normal FORM way. This is the default.

<P>
</DD>
<DT><STRONG>O1</STRONG></DT>
<DD>Activates the lowest level of optimization. It is very fast,
  i.e., linear in the size of the expression, and gives reasonably
  efficient code.

<P>
</DD>
<DT><STRONG>O2</STRONG></DT>
<DD>Activates the medium level of optimization. This is slower
  than the previous setting, but usually gives better results.

<P>
</DD>
<DT><STRONG>O3</STRONG></DT>
<DD>Activates the highest level of optimization using MCTS. It can be
  rather slow, but usually gives even better results.

<P>
</DD>
<DT><STRONG>O4</STRONG></DT>
<DD>Activates the highest level of optimization using Local Stochastic Search. 
It is usually much faster than MCTS and may give better results.
</DD>
</DL>

<P>
Below we show how to use O4 and how it compares to O2:
<PRE>
  #-
  S   a,b,c,d,e,f,g,h,i,j,k,l,m,n;
  L   G = (4*a^4+b+c+d + i^4 + g*n^3)^10 + 
          (a*h + e + f*i*j + g + h)^8 + (i + j + k + l + m + n)^12;
  L   H = G;
  Format O2;
  .sort
  #optimize G
  #write "Optimized with O2:"
  #write "Optimized with Horner scheme: `optimscheme_'"
  #write "Number of operations in output: `optimvalue_'"
  #clearoptimize
  .sort
  Format O4,saIter=1000; * use 1000 iterations for optimization
  #optimize H
  #write "Optimized with O4:"
  #write "Optimized with Horner scheme: `optimscheme_'"
  #write "Number of operations in output: `optimvalue_'"
  .end
</PRE>
which gives the output:
<PRE>
Optimized with O2:
Optimized with Horner scheme: i,n,j,m,l,k,g,a,d,c,b,h,f,e
Number of operations in output: 2578

Optimized with O4:
Optimized with Horner scheme: m,h,k,a,l,e,n,g,j,c,f,b,i,d
Number of operations in output: 1937
</PRE>

<P>
The preprocessor variable optimscheme_ <A NAME="15674"></A> gives the best Horner scheme that the
program found and the preprocessor optimvalue_ <A NAME="15675"></A> gives the number of
arithmetic operations in the resulting expression.

<P>
These levels of optimization refer to some default settings of all
controlling parameters. These default values are in
Tab.&nbsp;<A HREF="#tbl:defaults">10.1</A>. It is also possible to set each parameter
individually to fine-tune the optimization process. The parameters
that can be set are divided in several categories. First, it is
possible to set which Horner schemes<A NAME="15677"></A> are tried:

<P>
<DL>
<DT><STRONG>Horner=(Occurrence <SPAN CLASS="MATH"><IMG STYLE="height: 2.53ex; vertical-align: -0.69ex; " SRC="img12.svg"
 ALT="$\vert$"></SPAN> MCTS <SPAN CLASS="MATH"><IMG STYLE="height: 2.53ex; vertical-align: -0.69ex; " SRC="img12.svg"
 ALT="$\vert$"></SPAN> SA)</STRONG></DT>
<DD>Determines whether an 
  occurrence order<A NAME="15679"></A> Horner scheme is used, or
  whether MCTS<A NAME="15680"></A><A NAME="15681"></A>, or Stochastic Local Search is employed to
  find Horner schemes.

<P>
</DD>
<DT><STRONG>HornerDirection=(Forward <SPAN CLASS="MATH"><IMG STYLE="height: 2.53ex; vertical-align: -0.69ex; " SRC="img12.svg"
 ALT="$\vert$"></SPAN> Backward <SPAN CLASS="MATH"><IMG STYLE="height: 2.53ex; vertical-align: -0.69ex; " SRC="img12.svg"
 ALT="$\vert$"></SPAN> ForwardOrBackward <SPAN CLASS="MATH"><IMG STYLE="height: 2.53ex; vertical-align: -0.69ex; " SRC="img12.svg"
 ALT="$\vert$"></SPAN></STRONG></DT>
<DD>
  <B>ForwardAndBackward)</B>
  Forward makes that the MCTS search in the O3 option will 
  determine the outermost variables in the multivariate Horner scheme first 
  and then work its way inward.
  In the case of backward, the tree search determines the innermost variable 
  first. In some cases this can give much better results when there are 
  many common subexpressions involving a limited number of variables.
  ForwardOrBackward tries both of these
  schemes. ForwardAndBackward fills the order from both sides
  simultaneously, resulting in more options, but also a much larger
  search tree. If there are many variables, it could make the search tree 
  too large to obtain good results. 
<BR>
When the option Horner=Occurrence is used the option backward will switch 
  to something called `anti-occurrence' which means that the most frequent 
  variable corresponds to the innermost brackets.
</DD>
</DL>

<P>
In the case of MCTS<A NAME="15684"></A><A NAME="15685"></A> there are 
various parameters that can control the search process:

<P>
<DL>
<DT><STRONG>MCTSConstant=<SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img23.svg"
 ALT="$&lt;$"></SPAN><SPAN  CLASS="textit">value</SPAN><SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img24.svg"
 ALT="$&gt;$"></SPAN></STRONG></DT>
<DD>This sets the constant <SPAN CLASS="MATH"><IMG STYLE="height: 2.15ex; vertical-align: -0.47ex; " SRC="img108.svg"
 ALT="$C_P$"></SPAN> in the UCT formula that governs 
  the Monte Carlo tree search. It is supposed to be given as a real number 
  with a decimal point (no floating point notation that includes powers).
</DD>
<DT><STRONG>MCTSNumExpand=<SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img23.svg"
 ALT="$&lt;$"></SPAN><SPAN  CLASS="textit">value</SPAN><SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img24.svg"
 ALT="$&gt;$"></SPAN></STRONG></DT>
<DD>The number of times the tree
  is traversed and hence the number of times that a Horner scheme is
  constructed.
</DD>
<DT><STRONG>MCTSNumKeep=<SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img23.svg"
 ALT="$&lt;$"></SPAN><SPAN  CLASS="textit">value</SPAN><SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img24.svg"
 ALT="$&gt;$"></SPAN></STRONG></DT>
<DD>During the MCTS procedure FORM only tries to construct 
  a proper ordering for the Horner scheme, followed by a common subexpression 
  elimination in the style of the O1 option. The best `value' schemes are 
  remembered and for those a common subexpression elimination in the style of 
  the O2 option is done afterward. This second style elimination is far more 
  costly. In nearly all cases the best O2-style scheme is in the very few top 
  O1-style schemes.
</DD>
<DT><STRONG>MCTSNumRepeat=<SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img23.svg"
 ALT="$&lt;$"></SPAN><SPAN  CLASS="textit">value</SPAN><SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img24.svg"
 ALT="$&gt;$"></SPAN></STRONG></DT>
<DD>Sometimes it is more advantageous to run
  a new tree search several times, each with a smaller number of
  expansions. This parameter tells how many times we will run with a
  new tree. The total number of tree traversals is the product of 
  MCTSNumRepeat and MCTSNumExpand.
</DD>
<DT><STRONG>MCTSNumExpand=<SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img23.svg"
 ALT="$&lt;$"></SPAN><SPAN  CLASS="textit">value1*value2</SPAN><SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img24.svg"
 ALT="$&gt;$"></SPAN></STRONG></DT>
<DD>Makes FORM to run `value1' trees, each with `value2' Horner scheme
  constructions. Hence this option is equivalent to the combination 
<BR>
MCTSNumRepeat=<SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img23.svg"
 ALT="$&lt;$"></SPAN><SPAN  CLASS="textit">value1</SPAN><SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img24.svg"
 ALT="$&gt;$"></SPAN>, MCTSNumExpand=<SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img23.svg"
 ALT="$&lt;$"></SPAN><SPAN  CLASS="textit">value2</SPAN><SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img24.svg"
 ALT="$&gt;$"></SPAN>.
</DD>
<DT><STRONG>MCTSTimeLimit=<SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img23.svg"
 ALT="$&lt;$"></SPAN><SPAN  CLASS="textit">value</SPAN><SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img24.svg"
 ALT="$&gt;$"></SPAN></STRONG></DT>
<DD>The maximum time in seconds
  that is used when searching through the tree.
</DD>
<DT><STRONG>MCTSDecayMode=<SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img23.svg"
 ALT="$&lt;$"></SPAN><SPAN  CLASS="textit">value</SPAN><SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img24.svg"
 ALT="$&gt;$"></SPAN></STRONG></DT>
<DD>Determines how the <SPAN CLASS="MATH"><IMG STYLE="height: 2.15ex; vertical-align: -0.47ex; " SRC="img108.svg"
 ALT="$C_P$"></SPAN> parameter
in the UCT formula decreases:

<P>
<DIV class="CENTER">
<TABLE class="PAD  BORDER" style="">
<TR><TD CLASS="CENTER">value</TD>
<TD CLASS="LEFT">effect</TD>
</TR>
<TR><TD CLASS="CENTER">0</TD>
<TD CLASS="LEFT">no decay</TD>
</TR>
<TR><TD CLASS="CENTER">1</TD>
<TD CLASS="LEFT">linear decay with iteration number</TD>
</TR>
<TR><TD CLASS="CENTER">2</TD>
<TD CLASS="LEFT">faster decay for the final iterations</TD>
</TR>
<TR><TD CLASS="CENTER">3</TD>
<TD CLASS="LEFT">decrease with iteration number and with node depth</TD>
</TR>
</TABLE>
</DIV>
</DD>
</DL>

<P>
For Stochastic Local Search the following parameters can be set:
<DL>
<DT><STRONG>saIter=<SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img23.svg"
 ALT="$&lt;$"></SPAN><SPAN  CLASS="textit">value</SPAN><SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img24.svg"
 ALT="$&gt;$"></SPAN></STRONG></DT>
<DD>Number of optimization steps that will be performed. This has the most influence on the quality of the simplification. The default value is 1000.
</DD>
<DT><STRONG>saMaxT=<SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img23.svg"
 ALT="$&lt;$"></SPAN><SPAN  CLASS="textit">value</SPAN><SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img24.svg"
 ALT="$&gt;$"></SPAN></STRONG></DT>
<DD>Maximum temperature used in Simulated Annealing. The higher the temperature,
the more exploration occurs. The default value is 2000.
</DD>
<DT><STRONG>saMinT=<SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img23.svg"
 ALT="$&lt;$"></SPAN><SPAN  CLASS="textit">value</SPAN><SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img24.svg"
 ALT="$&gt;$"></SPAN></STRONG></DT>
<DD>Minimum temperature used in Simulated Annealing. The lower the temperature,
the more exploitation occurs. The default value is 1.
</DD>
</DL>
The cooling rate from saMaxT to saMinT is exponential in saIter. More information can be
found in the research papers.

<P>
The Horner methods generate a number of Horner schemes: one or two in
the case of occurrence order schemes, depending of the direction
parameter, and a number equal to MCTSNumKeep in the case of
MCTS. Next, for each stored Horner scheme other optimizations are
performed as determined by the following parameter:

<P>
<DL>
<DT><STRONG>Method=(None <SPAN CLASS="MATH"><IMG STYLE="height: 2.53ex; vertical-align: -0.69ex; " SRC="img12.svg"
 ALT="$\vert$"></SPAN> CSE <SPAN CLASS="MATH"><IMG STYLE="height: 2.53ex; vertical-align: -0.69ex; " SRC="img12.svg"
 ALT="$\vert$"></SPAN> Greedy <SPAN CLASS="MATH"><IMG STYLE="height: 2.53ex; vertical-align: -0.69ex; " SRC="img12.svg"
 ALT="$\vert$"></SPAN> CSEGreedy)</STRONG></DT>
<DD>Determines what
method is used for optimizing the generated Horner schemes. 
CSE<A NAME="15708"></A><A NAME="15709"></A> performs a simple 
common subexpression elimination and Greedy performs greedy 
optimizations<A NAME="15710"></A> (see the paper for more 
explanations) which are more sophisticated versions of CSE's. CSEGreedy 
performs CSE followed by greedy optimizations; usually this is somewhat 
faster than just greedy optimizations, but it gives slightly worse results. 
The option None does nothing after applying the Horner scheme and is only 
useful for debugging purposes.
</DD>
</DL>

<P>
When the method of greedy optimizations is used, repeatedly all
potential optimizations are determined and a few of them are performed. The 
following parameters are used to tune the greedy method:
<DL>
<DT><STRONG>GreedyMaxPerc</STRONG></DT>
<DD>The percentage of the possible optimizations that is
  performed.
</DD>
<DT><STRONG>GreedyMinNum</STRONG></DT>
<DD>The minimum number of possible optimizations that
  is performed.
</DD>
<DT><STRONG>GreedyTimeLimit</STRONG></DT>
<DD>The maximum time in seconds that is spent in
  the process of greedy optimization.
</DD>
</DL>

<P>
There are also two more general settings:
<DL>
<DT><STRONG>Stats=(On <SPAN CLASS="MATH"><IMG STYLE="height: 2.53ex; vertical-align: -0.69ex; " SRC="img12.svg"
 ALT="$\vert$"></SPAN> Off)</STRONG></DT>
<DD>This parameter determines whether statistics
  of the optimization are shown. Statistics are printed in the format

<P>
<SPAN style="font-family:monospace">*** STATS: original  1P 16M 5A : 23</SPAN>

<P>
<SPAN style="font-family:monospace">*** STATS: optimized 0P 10M 5A : 15</SPAN>

<P>
in which P indicates power operations (at least a third power), M the 
number of multiplications and A the number of additions/subtractions. The 
last number is the total number of operations in which an <SPAN CLASS="MATH"><IMG STYLE="height: 1.21ex; vertical-align: -0.11ex; " SRC="img84.svg"
 ALT="$n$"></SPAN>-th power counts 
as <SPAN CLASS="MATH"><IMG STYLE="height: 1.90ex; vertical-align: -0.30ex; " SRC="img85.svg"
 ALT="$n-1$"></SPAN> operations.
</DD>
<DT><STRONG>TimeLimit=<SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img23.svg"
 ALT="$&lt;$"></SPAN><SPAN  CLASS="textit">value</SPAN><SPAN CLASS="MATH"><IMG STYLE="height: 1.55ex; vertical-align: -0.20ex; " SRC="img24.svg"
 ALT="$&gt;$"></SPAN></STRONG></DT>
<DD>This set both the MCTSTimeLimit
  and the GreedyTimeLimit to half of the given value.
</DD>
</DL>

<P>
Finally there are some parameters that are of a rather specialized nature. 
They can be used for debugging<A NAME="15719"></A> purposes or in the case 
that one knows already what is the best Horner scheme. Their default values 
are Off.

<P>
<DL>
<DT><STRONG>DebugFlag=(On <SPAN CLASS="MATH"><IMG STYLE="height: 2.53ex; vertical-align: -0.69ex; " SRC="img12.svg"
 ALT="$\vert$"></SPAN> Off)</STRONG></DT>
<DD><A ID="optimdebugflag"></A>In the case that the value is On, the list of temporary variables is 
printed in reverse order with the string "id " in front. This makes 
them into a set of FORM substitutions that undo the optimizations. One 
can use this for instance to make sure that the optimized code is identical 
to the original.
</DD>
<DT><STRONG>PrintScheme=(On <SPAN CLASS="MATH"><IMG STYLE="height: 2.53ex; vertical-align: -0.69ex; " SRC="img12.svg"
 ALT="$\vert$"></SPAN> Off)</STRONG></DT>
<DD>This option (when On) will print the Horner scheme. That is the order in 
which the variables were taken outside parentheses.
</DD>
<DT><STRONG>Scheme=(list of symbols)</STRONG></DT>
<DD>The list should be enclosed by parentheses 
and the symbols should be separated by either blanks or comma's. This 
option will fix the Horner scheme<A NAME="15722"></A> to be used. One 
could for instance use the output of the PrintScheme option for this to 
avoid a lengthy search when a good order of the variables is already known. 
Things become a bit tricky when extra symbols are involved. One should make 
sure that their labelling is identical to when the scheme was created! When 
extra symbols are used in their array/vector notation, one needs to 
separate them by comma's, because blank spaces next to parentheses are 
eliminated by the preprocessor. If one specifies the wrong number of 
variables, the results can be quite unpredictable. At the moment of 
compilation FORM does not know the variables that are actually used. The 
safe thing is to verify the actual variables with a testrun using the 
PrintScheme option in the O1 mode.
</DD>
</DL>

<P>
 <SPAN CLASS="SPAN"></SPAN>
<BR><P></P>
<DIV class="CENTER"><A ID="15728"></A>
<TABLE>
<CAPTION><STRONG>Table 10.1:</STRONG>
Values for the various parameters in the predefined
  optimization levels. OR stands for ForwardOrBackward.</CAPTION>
<TR><TD>
<DIV class="CENTER"><TABLE class="PAD  BORDER" style="">
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">O1</TD>
<TD CLASS="CENTER">O2</TD>
<TD CLASS="CENTER">O3 (default)</TD>
<TD CLASS="CENTER">O4 (default)</TD>
</TR>
<TR><TD CLASS="LEFT">Horner</TD>
<TD CLASS="CENTER">occurrence</TD>
<TD CLASS="CENTER">occurrence</TD>
<TD CLASS="CENTER">MCTS</TD>
<TD CLASS="CENTER">SA</TD>
</TR>
<TR><TD CLASS="LEFT">HornerDirection</TD>
<TD CLASS="CENTER">OR</TD>
<TD CLASS="CENTER">OR</TD>
<TD CLASS="CENTER">OR</TD>
<TD CLASS="CENTER">OR</TD>
</TR>
<TR><TD CLASS="LEFT">MCTSConstant</TD>
<TD CLASS="CENTER">&mdash;</TD>
<TD CLASS="CENTER">&mdash;</TD>
<TD CLASS="CENTER">1.0</TD>
<TD CLASS="CENTER">&mdash;</TD>
</TR>
<TR><TD CLASS="LEFT">MCTSNumExpand</TD>
<TD CLASS="CENTER">&mdash;</TD>
<TD CLASS="CENTER">&mdash;</TD>
<TD CLASS="CENTER">1000</TD>
<TD CLASS="CENTER">&mdash;</TD>
</TR>
<TR><TD CLASS="LEFT">MCTSNumKeep</TD>
<TD CLASS="CENTER">&mdash;</TD>
<TD CLASS="CENTER">&mdash;</TD>
<TD CLASS="CENTER">10</TD>
<TD CLASS="CENTER">&mdash;</TD>
</TR>
<TR><TD CLASS="LEFT">MCTSNumRepeat</TD>
<TD CLASS="CENTER">&mdash;</TD>
<TD CLASS="CENTER">&mdash;</TD>
<TD CLASS="CENTER">1</TD>
<TD CLASS="CENTER">&mdash;</TD>
</TR>
<TR><TD CLASS="LEFT">MCTSTimeLimit</TD>
<TD CLASS="CENTER">&mdash;</TD>
<TD CLASS="CENTER">&mdash;</TD>
<TD CLASS="CENTER">0</TD>
<TD CLASS="CENTER">&mdash;</TD>
</TR>
<TR><TD CLASS="LEFT">MCTSDecayMode</TD>
<TD CLASS="CENTER">&mdash;</TD>
<TD CLASS="CENTER">&mdash;</TD>
<TD CLASS="CENTER">1</TD>
<TD CLASS="CENTER">&mdash;</TD>
</TR>
<TR><TD CLASS="LEFT">saIter</TD>
<TD CLASS="CENTER">&mdash;</TD>
<TD CLASS="CENTER">&mdash;</TD>
<TD CLASS="CENTER">&mdash;</TD>
<TD CLASS="CENTER">1000</TD>
</TR>
<TR><TD CLASS="LEFT">saMinT</TD>
<TD CLASS="CENTER">&mdash;</TD>
<TD CLASS="CENTER">&mdash;</TD>
<TD CLASS="CENTER">&mdash;</TD>
<TD CLASS="CENTER">1</TD>
</TR>
<TR><TD CLASS="LEFT">saMaxT</TD>
<TD CLASS="CENTER">&mdash;</TD>
<TD CLASS="CENTER">&mdash;</TD>
<TD CLASS="CENTER">&mdash;</TD>
<TD CLASS="CENTER">2000</TD>
</TR>
<TR><TD CLASS="LEFT">Method</TD>
<TD CLASS="CENTER">cse</TD>
<TD CLASS="CENTER">greedy</TD>
<TD CLASS="CENTER">greedy</TD>
<TD CLASS="CENTER">greedy</TD>
</TR>
<TR><TD CLASS="LEFT">GreedyMinNum</TD>
<TD CLASS="CENTER">&mdash;</TD>
<TD CLASS="CENTER">10</TD>
<TD CLASS="CENTER">10</TD>
<TD CLASS="CENTER">10</TD>
</TR>
<TR><TD CLASS="LEFT">GreedyMaxPerc</TD>
<TD CLASS="CENTER">&mdash;</TD>
<TD CLASS="CENTER">5</TD>
<TD CLASS="CENTER">5</TD>
<TD CLASS="CENTER">5</TD>
</TR>
<TR><TD CLASS="LEFT">GreedyTimeLimit</TD>
<TD CLASS="CENTER">&mdash;</TD>
<TD CLASS="CENTER">0</TD>
<TD CLASS="CENTER">0</TD>
<TD CLASS="CENTER">0</TD>
</TR>
<TR><TD CLASS="LEFT">Stats</TD>
<TD CLASS="CENTER">off</TD>
<TD CLASS="CENTER">off</TD>
<TD CLASS="CENTER">off</TD>
<TD CLASS="CENTER">off</TD>
</TR>
<TR><TD CLASS="LEFT">TimeLimit</TD>
<TD CLASS="CENTER">0</TD>
<TD CLASS="CENTER">0</TD>
<TD CLASS="CENTER">0</TD>
<TD CLASS="CENTER">0</TD>
</TR>
</TABLE>

<A ID="tbl:defaults"></A></DIV></TD></TR>
</TABLE>
</DIV><P></P>
<BR><SPAN CLASS="SPAN"></SPAN> 

<P>
All options should be specified in a single format statement and be
separated either by commas or blank spaces. When
<code>Format Optimize</code> is used, first the default settings are taken
and then the options that are specified overwrite them. It is allowed
to have the O1, O2, O3, O4 optimization specifications followed by
options. In that case the program first sets the values of those
specifications and then modifies according to what it encounters in
the rest of the statement.

<P>

<H1><A ID="SECTION001200000000000000000"></A>
<A ID="polynomials"></A>
<BR>
Polynomials and Factorization
</H1>

<P>
Starting with version 4, FORM is equipped with powerful handling 
of rational polynomials and with factorization capabilities. Because this 
creates many new possibilities, it brings a whole new category of commands 
with it. We will list most of these here.

<P>
First there are the rational polynomials. These work a bit like 
the PolyFun&nbsp;<A HREF="#substapolyfun">7.110</A>, but now with two arguments: a numerator and 
a denominator. Instead of PolyFun the function is designated as 
PolyRatFun&nbsp;<A HREF="#substapolyratfun">7.111</A> as in the example below:
<PRE>
    Symbol x,y;
    CFunction rat;
    PolyRatFun rat;
    L   F = rat(x+y,x-y)+rat(x-y,x+y);
    Print;
    .end

   F =
      rat(2*x^2 + 2*y^2,x^2 - y^2);
</PRE>
Dealing with a PolyRatFun can be very handy, but one should realize that 
there is a limit to the size of the arguments, because the PolyRatFun with 
its arguments is part of a term and hence is limited by the maximum size of 
a term&nbsp;<A HREF="#setupmaxtermsize">17</A>. One should also take into account that the 
manipulation of multivariate polynomials, and in particular the GCD 
operation, can be rather time consuming.

<P>
The PolyRatFun has one limitation as compared to the regular 
PolyFun: in its arguments one may use only symbols. Of course FORM is 
equipped with a mechanism to replace other objects by extra internally 
generated symbols&nbsp;<A HREF="#substaextrasymbols">7.53</A>. One could imagine FORM to 
automatically convert these objects to symbols, do the polynomial 
arithmetic and then convert back. This is done with factorization and the 
gcd_&nbsp;<A HREF="#fungcd">8.30</A><A NAME="15929"></A><A NAME="15930"></A>, 
div_&nbsp;<A HREF="#fundiv">8.13</A><A NAME="15932"></A><A NAME="15933"></A> 
and rem_&nbsp;<A HREF="#funrem">8.58</A><A NAME="15935"></A><A NAME="15936"></A> functions. But 
because the addition of PolyRatFun's is such a frequent event, this would 
be very costly in time. Hence it is better that the user does this once 
in a controlled way.

<P>
The PolyFun and PolyRatFun declarations are mutually exclusive. 
The PolyRatFun is considered a special type of PolyFun and there can be 
only one PolyFun at any moment. If one wants to switch back to a mode in 
which there is neither a PolyFun nor a PolyRatFun one can use
<PRE>
   PolyRatFun;
</PRE>
to indicate that after this there is no function with that status.

<P>
When a PolyRatFun has only a single argument, this argument is 
interpreted as the numerator of a fraction. FORM will add automatically a 
second argument which has the value 1.

<P>
The second important polynomial facility is factorization. This 
is not necessarily something trivial. First of all, with very lengthy 
multivariate input, this can be unpractically slow. Second of all, there 
are various types of objects that we may factorize and each has its special 
needs. One of those needs is access to the factors, which is different for 
the factors of function arguments, of $-expressions or even complete 
expressions. In addition $-expressions should be factorizable either from 
the preprocessor or on a term by term basis. Let us start with function 
arguments.

<P>
One can factorize function arguments with the FactArg 
statement&nbsp;<A HREF="#substafactarg">7.54</A>. The factors are each represented by a 
separate argument as in
<PRE>
    Symbol x,y;
    CFunction f1,f2;
    Local F = f1(x^4-y^4)+f2(3*y^4-3*x^4);
    FactArg,f1,f2;
    Print;
    .end

   F=
      f1(y-x,y+x,y^2+x^2,-1)+f2(y-x,y+x,y^2+x^2,3);
</PRE>
Overall constants and overall signs are taken separately as one can see. If 
one wants the factors in separate functions one can use the 
ChainOut&nbsp;<A HREF="#substachainout">7.16</A> command as in
<PRE>
    Symbol x,y;
    CFunction f1,f2;
    Local F = f2(3*y^4-3*x^4);
    FactArg,f2;
    Print;
    .sort

   F=
      f2(y-x,y+x,y^2+x^2,3);

    ChainOut,f2;
    id f2(x?number_) = x;
    Print;
    .end

   F=
      3*f2(y-x)*f2(y+x)*f2(y^2+x^2);
</PRE>

<P>
Factorization of expressions is a bit more complicated. Clearly 
this cannot be a command at the term level. Hence we had two options on how 
to implement this. One would have been as a preprocessor instruction, which 
we did not select, and the other is as some type of format statement, which 
is what we did opt for. In the case we factorize an expression, the 
original unfactorized expression is replaced by the factorized version. 
After that we keep the factorized version only and that may bring some 
restrictions with it. Of course, in the same way one can factorize an 
expression, one can unfactorize it. The corresponding statements are 
Factorize&nbsp;<A HREF="#substafactorize">7.56</A>, NFactorize&nbsp;<A HREF="#substanfactorize">7.94</A>, 
UnFactorize&nbsp;<A HREF="#substaunfactorize">7.156</A> and 
NUnFactorize&nbsp;<A HREF="#substanunfactorize">7.103</A>. These statements are used at the end 
of the module in the same place as one might use the bracket 
statement&nbsp;<A HREF="#substabracket">7.11</A>. It should be noticed however that a 
factorized expression will never apply the bracket mechanism. They are 
mutually exclusive, because internally we use the bracket mechanism with a 
built in symbol factor_ to indicate the factors. Here is an example:
<PRE>
    Symbol x,y;
    Local F = x^4-y^4;
    Print;
    .sort

Time =       0.00 sec    Generated terms =          2
               F         Terms in output =          2
                         Bytes used      =         64

   F=
      -y^4+x^4;

    Print;
    Factorize F;
    .end

Time =       0.00 sec    Generated terms =          2
               F         Terms in output =          2
                         Bytes used      =         64

Time =       0.00 sec    Generated terms =          7
               F         Terms in output =          7
               factorize Bytes used      =        288

   F=
       (-1)
      *(y-x)
      *(y+x)
      *(y^2+x^2);
</PRE>
We have printed the statistics in this example to show that the 
factorization prints its own statistics. This factorization is executed 
after the expression has been completed and before manipulations on the 
next expression start. This way it is possible to overwrite the first 
output by the factorized output and we do not loose diskspace 
unnecessarily.

<P>
The next question is of course how to find out how many factors 
an expression has and how to access individual factors. There is a function 
numfactors_ which gives the number of factors in an expression:
<PRE>
    Symbol x,y;
    Local F1 = x^4-y^4;
    Local F2 = 0;
    Local F3 = 1;
    Local F4 = x^4-y^4;
    Print;
    Factorize F1,F2,F3;
    .sort

   F1=
       (-1)
      *(y-x)
      *(y+x)
      *(y^2+x^2);
    
   F2=0;

   F3=
       (1);

   F4=
      -y^4+x^4;
    #do i = 1,4
    #$n`i' = numfactors_(F`i');
    #message expression F`i' has `$n`i&rdquo; factors
~~~expression F1 has 4 factors
    #enddo
~~~expression F2 has 1 factors
~~~expression F3 has 1 factors
~~~expression F4 has 0 factors
    .end
</PRE>
As we see, an expression that is zero still gives one factor when it is 
factorized. When the expression is not factorized it will return 0 in all 
cases. The factors can be accessed easily once one knows that the factors 
are stored by means of the bracket mechanism and the n-th factor is the 
bracket with the n-th power of the symbol factor_ outside the bracket:
<PRE>
    Symbol x,y;
    Local F = x^4-y^4;
    Factorize F;
    .sort
    #$n = numfactors_(F);
    #do i = 1,`$n'
    Local F`i' = F[factor_^`i'];
    #enddo
    Print;
    .end

   F=
       (-1)
      *(y-x)
      *(y+x)
      *(y^2+x^2);

   F1=
      -1;

   F2=
      y-x;

   F3=
      y+x;

   F4=
      y^2+x^2;
</PRE>

<P>
It is also possible to put an expression in the input in a 
factorized format. For this we have the 
LocalFactorized&nbsp;<A HREF="#substalfactorized">7.82</A> and 
GlobalFactorized&nbsp;<A HREF="#substagfactorized">7.64</A> commands. These commands can 
be abbreviated to LFactorized, GFactorized or even LF and GF. One should 
notice that these commands do not execute a factorization. They accept the 
factors as the user provides them:
<PRE>
    Symbol x,y;
    LocalFactorize E = -(x+1)*(x+2)*((x+3)*(x+4));
    Print;
    .end

   E =
         (  - 1 )
       * ( 1 + x )
       * ( 2 + x )
       * ( 12 + 7*x + x^2 );
</PRE>
This can go to some extremes when we feed in expressions 
containing powers and expressions that are potentially already factorized:
<PRE>
    Symbol x,y;
    LocalFactorize E = -(x+1)*(x+2)*((x+3)*(x+4));
    Local   F = -(x+1)*(x+2)*((x+3)*(x+4));
    Print;
    .sort

   E=
       (-1)
      *(1+x)
      *(2+x)
      *(12+7*x+x^2);

   F=
      -24-50*x-35*x^2-10*x^3-x^4;

    LF G = (x-1)*(x+2)^2*E^2*F^2;
    Print G;
    .end

   G=
       (-1+x)
      *(2+x)
      *(2+x)
      *(-1)
      *(1+x)
      *(2+x)
      *(12+7*x+x^2)
      *(-1)
      *(1+x)
      *(2+x)
      *(12+7*x+x^2)
      *(-24-50*x-35*x^2-10*x^3-x^4)
      *(-24-50*x-35*x^2-10*x^3-x^4);
</PRE>
To put some order in this one may factorize the new expression 
again:
<PRE>
    Symbol x,y;
    LocalFactorize E = -(x+1)*(x+2)*((x+3)*(x+4));
    Local   F = -(x+1)*(x+2)*((x+3)*(x+4));
    .sort
    LF G = (x-1)*(x+2)^2*E^2*F^2;
    Print G;
    Factorize G;
    .end

   G=
       (-1+x)
      *(1+x)
      *(1+x)
      *(1+x)
      *(1+x)
      *(2+x)
      *(2+x)
      *(2+x)
      *(2+x)
      *(2+x)
      *(2+x)
      *(3+x)
      *(3+x)
      *(3+x)
      *(3+x)
      *(4+x)
      *(4+x)
      *(4+x)
      *(4+x);
</PRE>
In this case all constants are multiplied, all factors are 
factorized, and all factors in the new format are sorted.

<P>
The case that one or more factors are zero is special. In 
principle the zero factors are kept as in:
<PRE>
    Symbol x,y;
    LocalFactorize E = -0*(x+1)*(x+2)*0*((x+3)*(x+4));
    Print;
    .end

   E=
       (-1)
      *(0)
      *(1+x)
      *(2+x)
      *(0)
      *(12+7*x+x^2);
</PRE>
This way one can see what has happened when a substitution makes 
a factor zero. When we factorize this expression again however the whole 
expression becomes zero. If this is not intended and one would like to 
continue with the factors that are nonzero we have the keepzero option in 
the factorize statement as in:
<PRE>
    Symbol x,y;
    Format Nospaces;
    LocalFactorize E = -0*3*(x+1)*(x+2)/2*0*((x+3)*(x+4));
    Print;
    .sort

   E=
       (-1)
      *(0)
      *(3)
      *(1+x)
      *(2+x)
      *(1/2)
      *(0)
      *(12+7*x+x^2);
    Print;
    Factorize(keepzero) E;
    .end

   E=
       (0)
      *(-3/2)
      *(1+x)
      *(2+x)
      *(3+x)
      *(4+x);
</PRE>
We see here that first all constants are separate factors and the 
new factorization combines them. The keepzero option does the same with the 
factors that are zero. The zero factor will always be the first. Hence it 
is rather easy to test for whether the total expression should actually be 
zero. We just have to look whether <code>E[factor_]</code> is zero.

<P>
The unfactorize&nbsp;<A HREF="#substaunfactorize">7.156</A> statement is the opposite 
of the factorize statement. It takes the factorized expression and 
multiplies out the factors. It also uses the current brackets for 
formatting the output.
<PRE>
    Symbol x,y;
    LFactorized F = (x+1)*(x+y)*(y+1);
    Print;
    .sort

   F=
       (1+x)
      *(y+x)
      *(1+y);

    Print;
    Bracket x;
    UnFactorize F;
    .end

   F=
      +x*(1+2*y+y^2)
      +x^2*(1+y)
      +y+y^2;
</PRE>
In principle there are various models by which the 
unfactorization can be done in an efficient way. In addition it would be 
less efficient when the master would do all the work as is the case with 
the factorize statement. Currently this statement is still being developed 
internally. It is possible to make ones own emulation of it. Here we give 
the `brute force' way:
<PRE>
    Symbol x,y;
    LFactorized F = (x+1)*(x+y)*(y+1);
    Print;
    .sort

   F=
       (1+x)
      *(y+x)
      *(1+y);

    #$num = numfactors_(F);
    Local   G = &lt;F[factor_^1]&gt;*...*&lt;F[factor_^`$num']&gt;;
    Bracket x;
    Print;
    .end

   F=
       (1+x)
      *(y+x)
      *(1+y);

   G=
      +x*(1+2*y+y^2)
      +x^2*(1+y)
      +y+y^2;
</PRE>

<P>
Factorization of $-expressions is yet a different thing. The 
$-expressions do not have a bracket mechanism. Hence we need different 
ways of storing the factors. In the case of expressions we have to work in 
a way that is potentially disk based. With $-expressions we work in 
allocated memory. Hence we also store the factors in allocated memory. In 
that case we can keep both the original and the factors. The factors are 
accessed by referring to their number between braces. The number zero 
refers to the number of factors:
<PRE>
    Symbol x,y;
    CFunction f;
    Off Statistics;
    #$a = x^4-y^4;
    Local F = f(x^4-y^4)+f(x^6-y^6);
    Print;
    .sort

   F=
      f(-y^4+x^4)+f(-y^6+x^6);
    #factdollar $a;
    #do i = 1,`$a[0]'
    #write &lt;&gt; "Factor `i' of `$a' is `$a[`i']'"
Factor 1 of -y^4+x^4 is -1
    #enddo
Factor 2 of -y^4+x^4 is y-x
Factor 3 of -y^4+x^4 is y+x
Factor 4 of -y^4+x^4 is y^2+x^2
    id  f(x?$b) = f(x);
    FactDollar $b;
    do $i = 1,$b[0];
      Print "Factor %$ of %$ is %$",$i,$b,$b[$i];
    enddo;
    Print;
    .end
Factor 1 of -y^4+x^4 is -1
Factor 2 of -y^4+x^4 is y-x
Factor 3 of -y^4+x^4 is y+x
Factor 4 of -y^4+x^4 is y^2+x^2
Factor 1 of -y^6+x^6 is -1
Factor 2 of -y^6+x^6 is y-x
Factor 3 of -y^6+x^6 is y+x
Factor 4 of -y^6+x^6 is y^2-x*y+x^2
Factor 5 of -y^6+x^6 is y^2+x*y+x^2

   F=
      f(-y^4+x^4)+f(-y^6+x^6);
</PRE>
We see here a variety of new features. The preprocessor can 
factorize $a with the #FactDollar instruction. We do indeed pick up the 
number of factors in the preprocessor as `$a[0]' and the factors 
themselves as `$a[1]' etc. For the $-variable that needs to be 
manipulated during running time things as a bit more complicated. We define 
$b as part of a wildcard pattern matching. This is still rather normal. 
Then we use the FactDollar statement. Notice that for each term we will 
have a different $b. To access the factors we cannot use the preprocessor 
methods because those are only available at compile time. Hence we cannot 
use the preprocessor #do instruction and therefore we need an execution 
time do statement. The loop parameter will have to be a $-variable as 
well. The do statement and the print statement show now how one can use the 
factors. In the output one can see that indeed we had two different 
contents for $b. And the arguments of the function f remain unaffected.

<P>
One may also ask for the number of factors in a $-expression 
with the numfactors_ function as in:
<PRE>
    Symbol x,y;
    CFunction f;
    Format Nospaces;
    #$a = x^4-y^4;
    #factdollar $a;
    Local F = f(numfactors_($a))
        +f(&lt;$a[1]&gt;,...,&lt;$a[`$a[0]']&gt;);
    Print;
    .end

   F=
      f(-1,y-x,y+x,y^2+x^2)+f(4);
</PRE>
Note that in the second case we need to use the construction 
`$a[0]' because the preprocessor needs to substitute the number 
immediately in order to expand the triple dot operator. This cannot wait 
till execution time.

<P>
Some remarks.

<P>
The time needed for a factorization depends strongly on the 
number of variables used. For example factorization of <SPAN CLASS="MATH"><IMG STYLE="height: 2.33ex; vertical-align: -0.30ex; " SRC="img109.svg"
 ALT="$x^{60}-1$"></SPAN> is much 
faster than factorization of <SPAN CLASS="MATH"><IMG STYLE="height: 2.59ex; vertical-align: -0.56ex; " SRC="img110.svg"
 ALT="$x^{60}-y^{60}$"></SPAN>. One could argue that the 
second formula can be converted into the first, but there is a limit to 
what FORM should do and what the user should do.
<PRE>
    Symbol x,y;
    Format NoSpaces;
    On ShortStats;
    Local F1 = x^60-1;
    Local F2 = y^60-x^60;
    Factorize F1,F2;
    Print;
    .end
      0.00s        1&gt;         2--&gt;         2:        52 F1 
      0.07s        1&gt;        51--&gt;        51:      1524 F1 factorize
      0.07s        1&gt;         2--&gt;         2:        64 F2 
      1.17s        1&gt;        51--&gt;        51:      1944 F2 factorize

   F1=
       (-1+x)
      *(1-x+x^2)
      *(1-x+x^2-x^3+x^4)
      *(1-x+x^3-x^4+x^5-x^7+x^8)
      *(1+x)
      *(1+x+x^2)
      *(1+x+x^2+x^3+x^4)
      *(1+x-x^3-x^4-x^5+x^7+x^8)
      *(1-x^2+x^4)
      *(1-x^2+x^4-x^6+x^8)
      *(1+x^2)
      *(1+x^2-x^6-x^8-x^10+x^14+x^16);

   F2=
       (y-x)
      *(y+x)
      *(y^2-x*y+x^2)
      *(y^4-x*y^3+x^2*y^2-x^3*y+x^4)
      *(y^4+x*y^3+x^2*y^2+x^3*y+x^4)
      *(y^2+x*y+x^2)
      *(y^2+x^2)
      *(y^8-x*y^7+x^3*y^5-x^4*y^4+x^5*y^3-x^7*y+x^8)
      *(y^8+x*y^7-x^3*y^5-x^4*y^4-x^5*y^3+x^7*y+x^8)
      *(y^8-x^2*y^6+x^4*y^4-x^6*y^2+x^8)
      *(y^4-x^2*y^2+x^4)
      *(y^16+x^2*y^14-x^6*y^10-x^8*y^8-x^10*y^6+x^14*y^2+x^16);
</PRE>

<P>
When one has a factorized expression and one uses the multiply 
statement, all terms in the factorized expression are multiplied the 
specified amount. This may lead to a counterintuitive result:
<PRE>
    Symbols a,b;
    LF F = (a+b)^2;
    multiply 2;
    Print;
    .end

   F =
       ( 2*b + 2*a )
       * ( 2*b + 2*a );
</PRE>
This is a consequence of the way we store the factors. This way each factor 
will be multiplied by two. If one would like to add a factor one can do 
this by the following simple mechanism:
<PRE>
    Symbols a,b;
    LF F = (a+b)^2;
    .sort
    LF F = 2*F;
    Print;
    .end

   F =
         ( 2 )
       * ( b + a )
       * ( b + a );
</PRE>

<P>
In version 3 there were some experimental polynomial functions 
like polygcd_<A NAME="15986"></A><A NAME="15987"></A>. These have been 
removed as their functionality has been completely taken over by the new 
functions gcd_&nbsp;<A HREF="#fungcd">8.30</A>, div_&nbsp;<A HREF="#fundiv">8.13</A> and rem_&nbsp;<A HREF="#funrem">8.58</A> and 
some statements like normalize&nbsp;<A HREF="#substanormalize">7.97</A>, 
makeinteger&nbsp;<A HREF="#substamakeinteger">7.85</A> and factarg&nbsp;<A HREF="#substafactarg">7.54</A>. Unlike 
regular functions, the functions gcd_. div_ and rem_ have the 
peculiarity that if one of the arguments is just an expression or a 
$-expression, this expression is not evaluated until the function is 
evaluated. This means that the evaluated expression does not have to fit 
inside the maximum size reserved for a single term. In some cases, when the 
gcd_ function is invoked with many arguments, the expression may not have 
to be evaluated at all! The GCD of the other arguments may be one already.

<P>

<P>

<H1><A ID="SECTION001300000000000000000"></A>
<A ID="tablebase"></A>
<BR>
The TableBase
</H1>

<P>
The tablebase<A NAME="16040"></A> statement controls a 
database<A NAME="16041"></A>-like structure that allows FORM to control massive 
amounts of data in the form of tables and
table<A NAME="16042"></A><A NAME="16043"></A> elements.
The contents of a tablebase are formed by one or more table declarations 
and a number of fill<A NAME="16044"></A> statements. These fill statements however 
are not immediately compiled. For each fill statement a special fill 
statement is generated and compiled that is of the form
<PRE>
    Fill tablename(indices) = tbl_(tablename,indices,arguments);
</PRE>
The function tbl_<A NAME="16047"></A> is a special function to make a temporary 
table substitution. It indicates that the corresponding element can be 
found in a tablebase that has been opened. At a later stage one can tell 
FORM to see which table elements are actually needed and then only those 
will be loaded from the tablebase and compiled.

<P>
Tablebases have a special internal structure and the right hand sides of 
the fill statements are actually stored in a compressed<A NAME="16048"></A> 
state. These tablebases can be created with special statements and uploaded 
with any previously compiled table. Hence one can prepare a tablebase in a 
previous job, to be used at a later stage, without the time penalty of 
loading the whole table at that later stage.

<P>
Assume we have a file named no11fill.h that loooks like
<PRE>
    Symbols ...;
    Table,sparse,no11fill(11,N?);
    Fill no11fill(-3,1,1,1,1,1,1,1,0,0,0) = ....
    Fill no11fill(-2,1,1,1,1,1,1,1,0,0,0) = ....
    etc.
</PRE>
It should be noted that only sparse<A NAME="16051"></A> tables can be stored 
inside a tablebase. The right hand sides could be typically a few kilobytes 
of formulas and there could be a few thousand of these fill statements. To 
make this into a tablebase one would use the program
<PRE>
    #-
    #include no11fill.h
    #+
    TableBase "no11.tbl" create;
    TableBase "no11.tbl" addto no11fill;
    .end
</PRE>
The include<A NAME="16054"></A> instruction makes that FORM reads and compiles 
the table. Then the first tablebase statement creates a new tablebase file 
by the name no11.tbl. If such a file existed already, the old version will 
be lost. If one would like to add to an existing tablebase, one should use 
the `open'<A NAME="16055"></A> keyword. The second tablebase statement adds the 
table no11fill to the tablebase file no11.tbl. This takes care of declaring 
the table, making an index of all elements that have been filled and 
putting their right hand sides, in compressed form, into the tablebase. The 
compression is based on the zlib<A NAME="16056"></A> library, provided by Jean-loup 
Gailly<A NAME="16057"></A> and Mark Adler<A NAME="16058"></A> (version 
1.2.3, July 18, 2005) and it strikes a nice balance between speed and 
compression ratio.

<P>
The tablebase can be loaded in a different program as in
<PRE>
    TableBase "no11.tbl" open;
</PRE>
This loads the main index<A NAME="16061"></A> of the file into memory.

<P>
If one would like to compile the short version of the fill statements (the 
normal action at this point) one needs to use the load<A NAME="16062"></A> option. 
Without any names of tables it will read the index of all tables. If tables 
are specied, only the index of those tables is taken and the proper 
tbl_ fill statements are generated:
<PRE>
    TableBase "no11.tbl" open;
    TableBase "no11.tbl" load no11fill;
</PRE>

<P>
If one would like to compile<A NAME="16065"></A> the complete tables, rather 
than just the shortened versions, one can use the enter option as in:
<PRE>
    TableBase "no11.tbl" open;
    TableBase "no11.tbl" enter no11fill;
</PRE>

<P>
Let us assume we used the load option. Hence now an occurrence of a table 
element will be replaced by the stub<A NAME="16068"></A>-function 
tbl_<A NAME="16069"></A>. In order to have this replaced by the actual right hand 
side of the original fill statement we have to do some more work. At a 
given moment we have to make FORM look which elements are actually needed. 
This is done with the TestUse<A NAME="16070"></A> statement as in
<PRE>
    TestUse no11fill;
</PRE>
This does nothing visible. It just marks internally which elements will be 
needed and have not been entered yet.

<P>
The actual entering of the needed elements is done with the use<A NAME="16073"></A> 
option:<PRE>
    TableBase "no11.tbl" use;
</PRE>
If many elements are needed, this statement may need some compilation time. 
Note however that this is time at a moment that it is clear that the 
elements are needed, which is entirely different from a fixed time at the 
startup of a program when the whole table is loaded as would have to be 
done before the tablebase statement existed. Usually however only a 
part of the table is needed, and in the extreme case only one or two 
elements. In that case the profit is obvious.

<P>
At this point the proper elements are available inside the system, but 
because we have two versions of the table (one the short version with 
tbl_, the other the complete elements) we have to tell FORM to apply 
the proper definitions with the `apply'<A NAME="16076"></A> statement.
<PRE>
    Apply;
</PRE>
Now the actual rhs will be inserted.

<P>
One may wonder why this has to be done in such a `slow' way with this much 
control over the process. The point is that at the moment the table 
elements are recognized, one may not want the rhs yet, because it may be 
many lines. Yet one may want to take the elements away from the main stream 
of action. Similarly, having a table element recognized at a certain stage, 
may not mean automatically that it will be needed. The coefficient may 
still become zero during additional manipulations. Hence the user is left 
with full control over the process, even though that may lead to slightly 
more programming. It will allow for the fastest program.

<P>
For the name of a tablebase we advise the use of the extension 
.tbl<A NAME="16079"></A> to avoid confusion.

<P>
Note that the above scheme may need several applications, if table elements 
refer in their definition to other table elements. This can be done with a 
construction like:
<PRE>
    #do i = 1,1
        TestUse;
        .sort
        TableBase "basename.tbl" use;
        Apply;
        if ( count(tbl_,1) ) Redefine i "0";
        .sort
    #enddo
</PRE>
It will stay in the loop until there are no more tbl_ functions to be 
resolved.

<P>

<P>
<BR>
The complete syntax (more is planned):

<P>

<H1><A ID="SECTION001310000000000000000"></A>
<A ID="tbladdto"></A>
<BR>
addto
</H1>

<P>
Syntax:

<P>
TableBase "file.tbl" addto tablename;

<P>
TableBase "file.tbl" addto tablename(tableelement);

<P>
See also open (<A HREF="#tblopen">12.9</A>) and create (<A HREF="#tblcreate">12.4</A>).

<P>
Adds<A NAME="16086"></A> the contents of a (sparse<A NAME="16087"></A>) table 
to a tablebase. The base must be either an existing tablebase (made 
accessible with an open statement) or a new tablebase (made available with 
a create statement). In the first version what is added is the collection 
of all fill statements that have been used to define elements of the 
indicated table, in addition to a definition of the table (if that had not 
been done yet). In the second version only individual elements of the 
indicated table are added. These elements are indicated as it should be in 
the left hand side of a fill<A NAME="16088"></A> statement.

<P>
One is allowed to specify more than one table, or more than one 
element. If one likes to specify anything after an element, it should be 
realized that one needs to use a comma for a separator, because blank 
spaces after a parenthesis are seen as irrelevant.

<P>
Examples:
<PRE>
    TableBase "no11.tbl" open;
    TableBase "no11.tbl" load;
    TableBase "no11.tbl" addto no11filb;
    TableBase "no11.tbl" addto no11fill(-3,1,1,1,1,2,1,1,0,0,0),
                               no11fill(-2,1,1,2,1,1,1,1,0,0,0);
</PRE>

<P>

<H1><A ID="SECTION001320000000000000000"></A>
<A ID="tblapply"></A>
<BR>
apply
</H1>

<P>
Syntax:

<P>
Apply [number] [tablename(s)];

<P>
See also testuse (<A HREF="#tbltestuse">12.10</A>) and use (<A HREF="#tbluse">12.11</A>).

<P>
The actual application<A NAME="16095"></A> of fill<A NAME="16096"></A> 
statements that were taken from the tablebases. If no tables are specified, 
this is done for all tables, otherwise only for the tables whose names are 
mentioned. The elements must have been registered as used before with the 
application of a testuse<A NAME="16097"></A> statement, and they must have been 
compiled from the tablebase with the use<A NAME="16098"></A> option of the tablebase 
statement. The number refers to the maximum number of table elements that 
can be substituted in each term. This way one can choose to replace only 
one element at a time. If no number is present all occurrences will be 
replaced. This refers also to occurrences inside function arguments. If only 
a limited number is specified in the apply statement, the occurrences 
inside function arguments have priority.

<P>

<H1><A ID="SECTION001330000000000000000"></A>
<A ID="tblaudit"></A>
<BR>
audit
</H1>

<P>
Syntax:

<P>
TableBase "file.tbl" audit;

<P>
See also open (<A HREF="#tblopen">12.9</A>)

<P>
Prints<A NAME="16102"></A> a list of all tables and table elements that 
are defined in the specified tablebase. This tablebase needs to be opened 
first. As of the moment there are no options for the audit. Future options 
might include formatting of the output.

<P>

<H1><A ID="SECTION001340000000000000000"></A>
<A ID="tblcreate"></A>
<BR>
create
</H1>

<P>
Syntax:

<P>
TableBase "file.tbl" create;

<P>
See also open (<A HREF="#tblopen">12.9</A>)

<P>
This creates<A NAME="16106"></A> a new file<A NAME="16107"></A> with the 
indicated name. This file will be initialized as a tablebase. If there was 
already a file with the given name, its old contents will be lost. If one 
would like to add to an existing tablebase, one should use the 
`open'<A NAME="16108"></A> option.

<P>

<H1><A ID="SECTION001350000000000000000"></A>
<A ID="tblenter"></A>
<BR>
enter
</H1>

<P>
Syntax:

<P>
TableBase "file.tbl" enter;

<P>
TableBase "file.tbl" enter tablename(s);

<P>
See also open (<A HREF="#tblenter">12.5</A>) and load (<A HREF="#tblload">12.6</A>).

<P>
Scans<A NAME="16113"></A> the specified tablebase and (in the first 
variety) creates for all elements of all tables in the tablebase a 
fill<A NAME="16114"></A> statement with its full contents. This is at times faster 
than reading the fill statements from a regular input 
file<A NAME="16115"></A>, because the tablebase has its contents 
compressed<A NAME="16116"></A>. 
Hence this costs less file access time. When table names are specified, 
only the tables that are mentioned have their elements treated this way.

<P>
The tablebase must of course be open for its contents to be 
available.

<P>
If one would like FORM to only see what elements are available 
and load that information one should use the load<A NAME="16117"></A> option.

<P>

<H1><A ID="SECTION001360000000000000000"></A>
<A ID="tblload"></A>
<BR>
load
</H1>

<P>
Syntax:

<P>
TableBase "file.tbl" load;

<P>
TableBase "file.tbl" load tablename(s);

<P>
See also open (<A HREF="#tblopen">12.9</A>) and enter (<A HREF="#tblenter">12.5</A>).

<P>
Scans<A NAME="16122"></A> the index of the specified tablebase and (in 
the first variety) creates for all elements of all tables in the tablebase 
a fill<A NAME="16123"></A> statement of the type
<PRE>
    Fill tablename(indices) = tbl_(tablename,indices,arguments);
</PRE>
This is the fill statement that will be used when elements of one of these 
tables are encountered. The function tbl_ is called the (table)stub 
function. When table names are specified, only the tables that are 
mentioned have their elements treated this way.

<P>
The tablebase must of course be open for its contents to be 
available.

<P>
If one would like to actually load the complete fill statements, 
one should use the enter option.

<P>

<H1><A ID="SECTION001370000000000000000"></A>
<A ID="tbloff"></A>
<BR>
off
</H1>

<P>
Syntax:

<P>
TableBase "file.tbl" off subkey;

<P>
See also addto (<A HREF="#tbladdto">12.1</A>) and off (<A HREF="#tblon">12.8</A>).

<P>
Currently<A NAME="16130"></A> only the subkey `compress'<A NAME="16131"></A> 
is recognized. It makes sure that no compression is used when elements are 
being stored in a tablebase with the addto<A NAME="16132"></A> option. This could 
be interesting when the right hand sides of the fill statements are 
relatively short.

<P>

<H1><A ID="SECTION001380000000000000000"></A>
<A ID="tblon"></A>
<BR>
on
</H1>

<P>
Syntax:

<P>
TableBase "file.tbl" on subkey;

<P>
See also addto (<A HREF="#tbladdto">12.1</A>) and off (<A HREF="#tbloff">12.7</A>).

<P>
Currently<A NAME="16137"></A> only the subkey `compress'<A NAME="16138"></A> is 
recognized. It makes sure that compression with the gzip<A NAME="16139"></A> 
algorithms is used when elements are being stored in a tablebase with the 
addto<A NAME="16140"></A> option. This is the default.

<P>

<H1><A ID="SECTION001390000000000000000"></A>
<A ID="tblopen"></A>
<BR>
open
</H1>

<P>
Syntax:

<P>
TableBase "file.tbl" open;

<P>
See also create (<A HREF="#tblcreate">12.4</A>)

<P>
This opens<A NAME="16144"></A> an existing file with the indicated name. 
It is assumed that the file has been created<A NAME="16145"></A> with the 
`create' option in a previous FORM program. It gives the user access to the 
contents of the tablebase. In addition it allows the user to add to its 
contents.

<P>
Just like with other files, FORM will look for the file in in 
current directory and in all other directories mentioned in the environment 
variable `FORMPATH'<A NAME="16146"></A> (see for instance the 
#call<A NAME="16147"></A> (<A HREF="#precall">3.10</A>) and the #include<A NAME="16149"></A> 
(<A HREF="#preinclude">3.34</A>) instructions).

<P>

<H1><A ID="SECTION0013100000000000000000"></A>
<A ID="tbltestuse"></A>
<BR>
testuse
</H1>

<P>
Syntax:

<P>
TestUse;

<P>
TestUse tablename(s);

<P>
See also use (<A HREF="#tbluse">12.11</A>).

<P>
Tests<A NAME="16154"></A> for all elements of the specified tables (if 
no tables are mentioned, this is done for all tables) whether they are used 
in a stub<A NAME="16155"></A> function tbl_<A NAME="16156"></A>. If so, this indicates 
that these elements must be compiled from a tablebase, provided this has 
not been done already. The compilation will have to be done at a time, 
specified by the user. This can be done with the use<A NAME="16157"></A> option. All 
this statement does is set some flags in the internals of FORM for the 
table elements that are encountered in the currently active expressions.

<P>

<H1><A ID="SECTION0013110000000000000000"></A>
<A ID="tbluse"></A>
<BR>
use
</H1>

<P>
Syntax:

<P>
TableBase "file.tbl" use;

<P>
TableBase "file.tbl" use tablename(s);

<P>
See also testuse (<A HREF="#tbltestuse">12.10</A>) and apply (<A HREF="#tblapply">12.2</A>).

<P>
Causes<A NAME="16162"></A> those elements of the specified tables to be 
compiled, that a previous testuse<A NAME="16163"></A> statement has encountered 
and that have not yet been compiled before. If no tables are mentioned this 
is done for all tables. The right hand sides of the definition of the table 
elements will not yet be substituted. That is done with an 
apply<A NAME="16164"></A> statement.

<P>

<P>

<H1><A ID="SECTION001400000000000000000"></A>
<A ID="dictionaries"></A>
<BR>
Dictionaries
</H1>

<P>
At times one would like to manipulate the output to facilitate further 
processing. A standard example is that the output formula should be 
included in a <SPAN CLASS="logo,LaTeX">L<SUP><SMALL>A</SMALL></SUP>T<SMALL>E</SMALL>X</SPAN> file. Also the use of terms in the output as 
patterns with wildcards in the LHS of an id-statements needs textual 
translation. Another example is the representation of 
fractions in a numerical program that works with floating point numbers. 
Complete solutions for such problems are not included in FORM, but with 
the partial solution of `dictionaries'<A NAME="16344"></A> one can do quite 
a lot already.

<P>
In FORM a dictionary is a collection of `words'<A NAME="16346"></A> together with 
their translation<A NAME="16347"></A>. The word can be a number, a variable, 
a function with its arguments or a special output token like a 
multiplication sign or a power indicator. The translation can be any 
string. Generic patterns have not been implemented. That would be more like 
grammar and involves special complications. As shown later, currently there 
is one exception to this rule.

<P>
A dictionary is defined with the preprocessor<A NAME="16348"></A> 
instruction
<PRE>
    #opendictionary name
</PRE>
in which `name' is the name of the dictionary. There can be more 
dictionaries, provided they have different names. It is allowed to open 
already existing dictionaries. Only one dictionary can be open at a given 
time. Dictionaries are closed with the instruction<A NAME="16351"></A>
<PRE>
    #closedictionary
</PRE>
and because there can be only one open dictionary, it is clear which 
dictionary should be closed.

<P>
A dictionary is opened to add words to it. This is done with the #add 
instruction<A NAME="16354"></A> as in
<PRE>
    #add x1: "x_1"
    #add *: "\ "
    #add mu: "\mu"
</PRE>
which would tell the system that when the dictionary is in use, the 
variable <code>x1</code> should be printed as the string <code>x_1</code> and a 
multiplication sign should become a backslash character followed by a 
blank space. The (index) mu would be printed as the string <code>\mu</code>.

<P>
A dictionary can be used<A NAME="16357"></A> with the
<PRE>
    #usedictionary name &lt;(options)&gt;
</PRE>
instruction. At the moment a dictionary is being used there cannot be any 
open dictionaries. Hence we can stop using a dictionary with the
<PRE>
    #closedictionary
</PRE>
instruction<A NAME="16362"></A> without running into inconsistencies. 
The options control partial use of a dictionary, as for instance only for 
individual variables, or only for numbers. They can also control whether 
translations should be made inside function arguments or inside dollar 
variables (when used as preprocessor variables).

<P>
What words are allowed?
<DL>
<DT><STRONG>variable</STRONG></DT>
<DD>This can be the name of a symbol, a vector, an index or a 
function (this includes commuting functions, non-commuting functions, 
tensors and tables).
</DD>
<DT><STRONG>number</STRONG></DT>
<DD>This must be a positive integer number.
</DD>
<DT><STRONG>fraction</STRONG></DT>
<DD>This must be a positive rational number.
</DD>
<DT><STRONG>special character</STRONG></DT>
<DD>Currently this can be the multiplication sign 
(<code>*</code>), or the power sign (<code>^</code> or <code>**</code>).
</DD>
<DT><STRONG>a range</STRONG></DT>
<DD>Indicated between parentheses, this is a range<A NAME="16364"></A> 
of extra symbols. There can be more than one range.
</DD>
<DT><STRONG>a function with arguments</STRONG></DT>
<DD>This would be a complete function subterm. 
</DD>
</DL>

<P>
The options in the #usedictionary should be enclosed between parentheses 
and separated by comma's. They can be:
<DL>
<DT><STRONG>allnumbers</STRONG></DT>
<DD>All numbers will be looked up in the dictionary.
</DD>
<DT><STRONG>integersonly</STRONG></DT>
<DD>Only integer numbers will be looked up.
</DD>
<DT><STRONG>nonumbers</STRONG></DT>
<DD>Numbers will not be looked up.
</DD>
<DT><STRONG>numbersonly</STRONG></DT>
<DD>Only numbers will be looked up.
</DD>
<DT><STRONG>novariables</STRONG></DT>
<DD>Loose variables will not be looked up.
</DD>
<DT><STRONG>variablesonly</STRONG></DT>
<DD>Only loose variables will be looked up.
</DD>
<DT><STRONG>nospecials</STRONG></DT>
<DD>Specials (multiplication signs and power signs) will 
not be looked up.
</DD>
<DT><STRONG>specialsonly</STRONG></DT>
<DD>Only specials (multiplication signs and power signs) will 
be looked up.
</DD>
<DT><STRONG>nofunwithargs</STRONG></DT>
<DD>Functions with arguments will not be looked up.
</DD>
<DT><STRONG>funwithargsonly</STRONG></DT>
<DD>Only functions with arguments will be looked up.
</DD>
<DT><STRONG>warnings</STRONG></DT>
<DD>Warnings<A NAME="16367"></A> concern the look up of 
numbers. If a fortran or C format is being used and the dictionary cannot 
be used in such a way that floating point notation and/or decimal points 
can be avoided, a warning will be given.
</DD>
<DT><STRONG>nowarnings</STRONG></DT>
<DD>No floating point warnings are given.
</DD>
<DT><STRONG>infunctions</STRONG></DT>
<DD>Substitutions are also made inside function arguments.
</DD>
<DT><STRONG>notinfunctions</STRONG></DT>
<DD>No substitutions are made inside function arguments.
</DD>
<DT><STRONG>$</STRONG></DT>
<DD>Substitutions are made also when dollar variables are expanded. 
The default is that this is not done.
</DD>
</DL>
The defaults are that all potential objects are looked up (also inside 
function arguments) and no warnings are given.

<P>
The use is best illustrated with a few examples.
<PRE>
    Symbols x1,y2,z3,N;
    Indices mu,nu,ro,si;
    Tensor tens;
    CFunction S,R,f;
    ExtraSymbols array w;
    #OpenDictionary test
      #add x1: "x_1"
      #add y2: "y^{(2)}"
      #add z3: "{\cal Z}"
      #add *: " "
      #add S(R(1),N): "S_1(N)"
      #add S(R(2),N): "S_2(N)"
      #add S(R(1,1),N): "S_{1,1}(N)"
      #add f: "\ln"
      #add mu: "\mu"
      #add nu: "\nu"
      #add ro: "\rho"
      #add si: "\sigma"
      #add tens: "T"
    #CloseDictionary
    Local F = x1*y2*z3
         + S(R(1),N) + S(R(1,1),N) + S(R(2),N)
         + tens(mu,nu,ro,si) + f(x1+1);
    #usedictionary test
    Print +s;
    .end
</PRE>
This program gives for its output
<PRE>
       F =
           + x_1 y^2 {\cal Z}
           + T(\mu,\nu,\rho,\sigma)
           + S_1(N)
           + S_{1,1}(N)
           + S_2(N)
           + \ln(1 + x_1)
          ;
</PRE>
Of course, there is nothing here that could not have been done with a good 
text editor, but having this inside the FORM program makes that if there 
are changes in the FORM program, it will be less work to implement them in 
the eventual <SPAN CLASS="logo,LaTeX">L<SUP><SMALL>A</SMALL></SUP>T<SMALL>E</SMALL>X</SPAN> files.

<P>
Things become different when numerical<A NAME="16376"></A> output is 
involved. Take for instance the fraction <SPAN CLASS="MATH"><IMG STYLE="height: 2.53ex; vertical-align: -0.69ex; " SRC="img111.svg"
 ALT="$1/3$"></SPAN> inside a 
FORTRAN<A NAME="16377"></A> program. 
Using the option
<PRE>
    Format Fortran;
</PRE>
one would obtain
<PRE>
    1./3.
</PRE>
and with<A NAME="16382"></A>
<PRE>
    Format DoubleFortran;
</PRE>
one would obtain
<PRE>
    1.D0/3.D0
</PRE>
while using<A NAME="16387"></A>
<PRE>
    Format QuadFortran;
</PRE>
one would obtain
<PRE>
    1.Q0/3.Q0
</PRE>
which means that one might have three varieties of the same program, 
depending on the precision in which one would like run it. It would be far 
better to have a single version and only determine in the make file what 
the precision should be. The FORTRAN code for such a program could look 
like
<PRE>
      REAL one,three,third
      PARAMETER (one=1,three=3,third=one/three)
</PRE>
after which one should either use the name 'third' or a construction like 
'one/three'. Let us take a simple program like
<PRE>
    Symbol x,n;
    Format DoubleFortran;
    Local F = (1+x)^7/7;
    id  x^n? = x*x^n/(n+1);
    Print;
    .end
      F =
     &amp; 1.D0/7.D0*x + 1.D0/2.D0*x**2 + x**3 + 5.D0/4.D0*x**4 + x**5 + 1.D
     &amp; 0/2.D0*x**6 + 1.D0/7.D0*x**7 + 1.D0/56.D0*x**8
</PRE>
If we define a dictionary we can make this into
<PRE>
    Symbol x,n;
    Format DoubleFortran;
    #OpenDictionary numbers
      #add 2: "TWO"
      #add 5: "FIVE"
      #add 7: "SEVEN"
    #CloseDictionary
    Local F = (1+x)^7/7;
    id  x^n? = x*x^n/(n+1);
    #UseDictionary numbers
    Print;
    .end
      F =
     &amp; 1/SEVEN*x + 1/TWO*x**2 + x**3 + FIVE/4*x**4 + x**5 + 1/TWO*x**6
     &amp;  + 1/SEVEN*x**7 + 1.D0/56.D0*x**8
</PRE>
one can see that some of the numbers have been replaced by text strings. In 
particular these are the numbers 2, 5 and 7. The output is now presented in 
such a way that the compiler can do the rest, provided we do this with all 
numbers that occur, and we feed the proper information to the compiler.

<P>
One can also replace complete fractions as in
<PRE>
    Symbol x,n;
    Format DoubleFortran;
    #OpenDictionary numbers
      #add 2: "TWO"
      #add 5: "FIVE"
      #add 7: "SEVEN"
      #add 1/2: "HALF"
    #CloseDictionary
    Local F = (1+x)^7/7;
    id  x^n? = x*x^n/(n+1);
    #UseDictionary numbers
    Print;
    .end
      F =
     &amp; 1/SEVEN*x + HALF*x**2 + x**3 + FIVE/4*x**4 + x**5 + HALF*x**6 + 
     &amp; 1/SEVEN*x**7 + 1.D0/56.D0*x**8
</PRE>
because the fractions take precedence.

<P>
The next question is how one makes sure to have all numbers that need 
replacement? For that one can use the warnings option:
<PRE>
    Symbol x,n;
    Format DoubleFortran;
    #OpenDictionary numbers
      #add 2: "TWO"
      #add 5: "FIVE"
      #add 7: "SEVEN"
      #add 1/2: "HALF"
    #CloseDictionary
    Local F = (1+x)^7/7;
    id  x^n? = x*x^n/(n+1);
    #UseDictionary numbers (warnings)
    Print;
    .end

Time =       0.00 sec    Generated terms =          8
               F         Terms in output =          8
                         Bytes used      =        204

      F =
     &amp; 1/SEVEN*x + HALF*x**2 + x**3 + FIVE/4*x**4 + x**5 + HALF*x**6 + 
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;Could not translate coefficient with dictionary numbers&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
&lt;&lt;&lt;
     &amp; 1/SEVEN*x**7 + 1.D0/56.D0*x**8
</PRE>
In this case the line after the warning contains a fraction that was not 
substituted. This allows one to add either <SPAN CLASS="MATH"><IMG STYLE="height: 1.70ex; vertical-align: -0.11ex; " SRC="img112.svg"
 ALT="$56$"></SPAN> or <SPAN CLASS="MATH"><IMG STYLE="height: 2.53ex; vertical-align: -0.69ex; " SRC="img113.svg"
 ALT="$1/56$"></SPAN> to the 
dictionary. This gives the program
<PRE>
    Symbol x,n;
    Format DoubleFortran;
    #OpenDictionary numbers
      #add 2: "cd2"
      #add 5: "cd5"
      #add 7: "cd7"
      #add 56: "cd56"
      #add 1/2: "c1d2"
      #add 5/4: "c5d4"
    #CloseDictionary
    Local F = (1+x)^7/7;
    id  x^n? = x*x^n/(n+1);
    #UseDictionary numbers (warnings)
    Print;
    .end
      F =
     &amp; 1/cd7*x + c1d2*x**2 + x**3 + c5d4*x**4 + x**5 + c1d2*x**6 + 1/
     &amp; cd7*x**7 + 1/cd56*x**8
</PRE>
Here we have selected a different notation that allows extension easily. 
A good way to do this now is to put the dictionary in a file numbers.hh and 
the corresponding FORTRAN definitions in a file numbers.h and then include 
these files in the proper places. The numbers.hh file would be
<PRE>
#OpenDictionary numbers
  #add 2: "cd2"
  #add 5: "cd5"
  #add 7: "cd7"
  #add 56: "cd56"
  #add 1/2: "c1d2"
  #add 5/4: "c5d4"
#CloseDictionary
</PRE>
and the numbers.h file would be
<PRE>
      REAL cd2,cd5,cd7,cd56,c1d2,c5d4
      PARAMETER (cd2=2,cd5=5,cd7=7,cd56=56,c1d2=1/cd2,c5d4=cd5/4)
</PRE>
and when the dictionary file is updated one may update the FORTRAN file 
simultaneously.

<P>
Setting the precision of the declaration REAL<A NAME="16408"></A> can be done by 
compiler options. These may depend on the compiler. One should consult the 
manpages.

<P>
Printing the extra symbols<A NAME="16409"></A> (<A HREF="#substaextrasymbols">7.53</A>) 
may be a bit trickier. A range<A NAME="16411"></A> is indicated with 
a pair of parentheses enclosing one or two (positive) numbers. If there are 
two numbers, they should be separated by a comma. There can be more than 
one range. In the substitution one can use the wildcards <code>%#</code> and 
<code>%@</code> to indicate the number of the extra symbol. The first 
wildcard indicates the number of the symbol and the second starts it 
counting with 1 from the beginning of the range.
<PRE>
    Symbol x;
    CFunction f;
    #OpenDictionary ranges
      #add (1,2): "w(%#)"
      #add (3): "ww(%#)"
      #add (4,6): "www(%@)"
    #CloseDictionary
    Local F = &lt;f(1)*x^1&gt;+...+&lt;f(6)*x^6&gt;;
    ToPolynomial;
    Print;
    .sort

   F =
      x*Z1_ + x^2*Z2_ + x^3*Z3_ + x^4*Z4_ + x^5*Z5_ + x^6*Z6_;

    #UseDictionary ranges
    Print;
    .end

   F =
      x*w(1) + x^2*w(2) + x^3*ww(3) + x^4*www(1) + x^5*www(2) + x^6*www(3);
</PRE>

<P>
The use of the dictionaries in dollar variables can best be shown with an 
example that has much in common with graph theory. Assume we have an 
expression that contains all topologies we are interested in, with a 
notation for the momenta. The function vx represents a vertex and we use it 
as a symmetric function. Here we show two topologies from massless two-loop 
propagators:
<PRE>
        +vx(p0,p1,-p4)*vx(-p1,p2,p5)*vx(q0,-p2,-p3)*vx(p4,p3,-p5)*topo(1)
        +vx(p0,p1,p2)*vx(-p1,p3,p4)*vx(q0,-p2,-p3,-p4)*topo(2)
</PRE>
where the q0 momentum is taken to be -p0. The problem is what happens when 
in a diagram of topology one, one of the lines is removed. If for instance 
the p1 line is removed, we will end up with the second topology, but the 
question is: how should we relabel the momenta to obtain the notation of 
topology 2. Taking out p1 gives us:
<PRE>
        +vx(p0,-p4,p2,p5)*vx(q0,-p2,-p3)*vx(p4,p3,-p5)*topo(1)
</PRE>
and to see what renaming we need is usually a major source of errors.
We can do this automatically if we can substitute the second topology into 
the remainder of the first using proper wildcards and storing the matches 
in dollar variables. This can be done with a dictionary:
<PRE>
    #OpenDictionary match
        #add p0: "p0?{p0,q0}$p0"
        #add q0: "q0?{p0,q0}$q0"
        #do i = 1,5
            #add p`i': "p`i'?$p`i'"
        #enddo
    #CloseDictionary
</PRE>
We put the various candidate topologies that could match, one by one, into 
the variable $child as in (after using brackets on the expression with the 
topologies):
<PRE>
    #$child = Topologies[topo(2)];
</PRE>
but generating an id-statement from it would be very laborious without the 
dictionaries:
<PRE>
    id `$Orig' = 1;
</PRE>
would result in:
<PRE>
    id vx(-p2,-p3,q0)*vx(-p4,p0,p2,p5)*vx(-p5,p3,p4) = 1;
</PRE>
but with the dictionary activated as in
<PRE>
    #inside $child
     #UseDictionary match($)
      id `$Orig' = 1;
     #CloseDictionary
    #endinside
</PRE>
the generated code is
<PRE>
    id vx(-p2?$p2,-p3?$p3,q0?{p0,q0}$q0)*vx(-p4?$p4,p0?{p0,q0}$p0,
       p2?$p2,p5?$p5)*vx(-p5?$p5,p3?$p3,p4?$p4) = 1;
</PRE>
and from the dollar variables we can generate a statement with the the 
renumbering
<PRE>
    id topo(1) = topo(2)*replace_(p0,-p0,p1,q1,p2,-p2,p3,-p1,p4,p3,p5,-p4);
</PRE>
We used <!-- MATH
 $p_1\rightarrow q_1$
 -->
<SPAN CLASS="MATH"><IMG STYLE="height: 1.66ex; vertical-align: -0.56ex; " SRC="img114.svg"
 ALT="$p_1\rightarrow q_1$"></SPAN> as initialization before the pattern matching 
and <SPAN CLASS="MATH"><IMG STYLE="height: 1.66ex; vertical-align: -0.56ex; " SRC="img115.svg"
 ALT="$p_0 = q_0$"></SPAN> we can replace by <SPAN CLASS="MATH"><IMG STYLE="height: 1.66ex; vertical-align: -0.56ex; " SRC="img116.svg"
 ALT="$p_0 = p_0$"></SPAN>. The <SPAN CLASS="MATH"><IMG STYLE="height: 1.66ex; vertical-align: -0.56ex; " SRC="img117.svg"
 ALT="$q_1$"></SPAN> should be replaced 
by means of momentum conservation, but that goes beyond the scope of this 
example.

<P>
It should be clear from the above that the dictionaries are the beginning 
of a new development. One should expect more capabilities in the future and 
suggestions are highly appreciated, provided they lead to something that 
can be implemented in a reasonable amount of time. Hence, for instance, 
there will not be a complete <SPAN CLASS="logo,LaTeX">L<SUP><SMALL>A</SMALL></SUP>T<SMALL>E</SMALL>X</SPAN> output format that can take line length 
into account.

<P>

<H1><A ID="SECTION001500000000000000000"></A>
<A ID="gammaalgebra"></A>
<BR>
Dirac algebra
</H1>

<P>
For its use in high<A NAME="16491"></A> energy physics FORM is 
equipped with a built-in class of functions. These are the 
gamma<A NAME="16492"></A> matrices of the Dirac<A NAME="16493"></A> 
algebra which are generically denoted by g_<A NAME="16494"></A>. The gamma matrices 
fulfill the relations:
<PRE>
     {g_(j1,mu),g_(j1,nu)} = 2 * d_(mu,nu)
     [g_(j1,mu),g_(j2,nu)] = 0    j1 not equal to j2.
</PRE>
The first argument is a so-called spin<A NAME="16497"></A> line index. When 
gamma matrices have the same spin line, they belong to the same Dirac 
algebra and commute with the matrices of other Dirac algebra's. The indices 
mu and nu are over space-time and are therefore usually running from 1 to 4 
(or from 0 to 3 in Bjorken &amp; Drell metric<A NAME="16498"></A>). 
The totally antisymmetric product e_(m1,m2,...,mn)g_(j,m1)...g_(j,
mn)/n! is defined to be gamma5 or g5_(j). The notation 5<A NAME="16499"></A> finds 
its roots in 4 dimensional space-time. The unit matrix is denoted by 
gi_(j). In four dimensions a basis of the Dirac algebra can be given by: 
<PRE>
     gi_(j)
     g_(j,mu)
     [g_(j,mu),g_(j,nu)]/2
     g5_(j)*g_(j,mu)
     g5_(j)
</PRE>
In a different number of dimensions this basis is correspondingly 
different. We introduce the following notation for convenience: 
<PRE>
     g6_(j) = gi(j) + g5_(j)     (from Schoonschip)
     g7_(j) = gi(j) - g5_(j)
     g_(j,mu,nu) = g_(j,mu)*g_(j,nu)  (from Reduce)
     g_(j,mu,nu,.....,ro,si) =
                      g_(j,mu,nu,.....,ro)*g_(j,si)
     g_(j,5_) = g5_(j)
     g_(j,6_) = g6_(j)
     g_(j,7_) = g7_(j)
</PRE>
The common operation on gamma matrices is to obtain the trace<A NAME="16504"></A> 
of a string of gamma matrices. This is done with the statement:

<P>
<TABLE   STYLE="width:181;">
<TR><TD>trace4<A NAME="16577"></A>, j
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>Take the trace in 4 dimensions of the combination of all 
gamma matrices with spin line j in the current term. Any non-commuting 
objects that may be between some of these matrices are ignored. It is the 
users responsibility to issue this statement only after all functions of 
the relevant matrices are resolved. The four refers to special 
tricks<A NAME="16584"></A> that 
can be applied in four dimensions. This allows for relatively compact 
expressions. For the complete syntax, consult <A HREF="#substatrace">7.152</A>.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>tracen<A NAME="16592"></A>, j
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:544;">
<TR><TD>Take the trace in an unspecified number of dimensions. 
This number of dimensions is considered to be even. The traces are 
evaluated by only using the anticommutation properties of the matrices. As 
the number of dimensions is not specified the occurrence of a g5_(j) is a 
fatal error. In general the expressions that are generated this way are 
longer than the four dimensional expressions. For the complete syntax, 
consult <A HREF="#substatracen">7.153</A>.</TD></TR>
</TABLE>
    <BR>

<P>
It is possible to alter the value of the trace of the
unit<A NAME="16514"></A> matrix gi_(j).<A NAME="16515"></A> Its
default value is 4, but by using the 
statement (see <A HREF="#substaunittrace">7.158</A>)
<PRE>
    unittrace value;
</PRE>
it can be altered. Value may be any positive short number (<SPAN CLASS="MATH"><IMG STYLE="height: 2.23ex; vertical-align: -0.20ex; " SRC="img54.svg"
 ALT="$&lt; 2^{15}$"></SPAN> on 
32<A NAME="16520"></A> bit machines and <SPAN CLASS="MATH"><IMG STYLE="height: 2.23ex; vertical-align: -0.20ex; " SRC="img55.svg"
 ALT="$&lt; 2^{31}$"></SPAN> on 64<A NAME="16522"></A> bit 
machines) or a single symbol with the exception of the symbol 
i_.<A NAME="16523"></A>

<P>
There are several options for the 4-dimensional traces. These options find 
their origin in the Chisholm<A NAME="16524"></A> relation that is valid in 4 
dimensions but not in a general number of dimensions. This relation can be 
found in the literature. It is given by:

<DIV class="equation">

<!-- MATH
 \begin{equation}
\gamma_\mu Tr[\gamma_\mu S] = 2(S + S^R)
\end{equation}
 -->
 &nbsp;  <IMG STYLE="height: 3.00ex; vertical-align: -0.78ex; " SRC="img118.svg"
 ALT="$\displaystyle \gamma_\mu Tr[\gamma_\mu S] = 2(S + S^R)
$"> 

(<SPAN CLASS="arabic">14</SPAN>.<SPAN CLASS="arabic">1</SPAN>)
</DIV>
in which S is a string of gamma matrices with an odd number of 
matrices (<SPAN CLASS="MATH"><IMG STYLE="height: 1.66ex; vertical-align: -0.56ex; " SRC="img48.svg"
 ALT="$\gamma_5$"></SPAN> counts for an even number of matrices). <SPAN CLASS="MATH"><IMG STYLE="height: 2.21ex; vertical-align: -0.11ex; " SRC="img45.svg"
 ALT="$S^R$"></SPAN> is the 
reversed string. This relation can be used to combine traces with common 
indices. The use of this relation is the default for trace4<A NAME="16527"></A>. 
If it needs to be switched off, one should add the extra option
`nocontract':
<PRE>
    trace4,nocontract,j;
</PRE>
The option `contract'<A NAME="16530"></A> is the default but it can be used to 
enhance the readability of the program. The second option that refers to 
this relation is the option `symmetrize'<A NAME="16531"></A>. Often it 
happens that there are two or more common indices in two spin lines. 
Without the symmetrize option (or with the 
`nosymmetrize'<A NAME="16532"></A> option) the first of these indices is 
taken and the relation is applied to it. With the `symmetrize' option 
the average over all possibilities is taken. This means of course that if 
there are two common indices the amount of work is doubled. There is 
however a potentially large advantage. In some traces that involve the use of 
<SPAN CLASS="MATH"><IMG STYLE="height: 1.66ex; vertical-align: -0.56ex; " SRC="img48.svg"
 ALT="$\gamma_5$"></SPAN> the use of automatic algorithms results often in an avalanche of 
terms with a single Levi-Civita tensor, while symmetry arguments can show 
that these terms should add up to zero. By working out the traces in a more 
symmetric fashion FORM is often capable of eliminating all or nearly all of 
these Levi-Civita tensors. Normally such an elimination is rather 
complicated. It involves relations that have so far defied proper 
implementation, even though people have been looking for such algorithms 
already for a long time. Hence the use of the symmetry from the beginning 
seems at the moment the best bet.

<P>
It is possible to only apply the Chisholm<A NAME="16533"></A> identity without 
taking the trace. This is done with the chisholm statement (see 
<A HREF="#substachisholm">7.17</A>). 

<P>
The n dimensional traces can use a special feature, when the declaration 
of the indices involved will allow it. When an index has been declared 
as n-dimensional and the dimension is followed by a second symbol as in
<PRE>
    symbols n,nn;
    index mu=n:nn;
</PRE>
and if the index <code>mu</code> is a contracted index in a single 
n-dimensional trace, then the formula for this trace can be shortened by 
using <code>nn</code> (one term) instead of the quantity <SPAN CLASS="MATH"><IMG STYLE="height: 2.53ex; vertical-align: -0.69ex; " SRC="img4.svg"
 ALT="$(n-4)$"></SPAN> (two terms). 
This can make the taking of the n-dimensional traces significantly 
faster.

<P>
<BR>
<BR>

<P>
Algorithms<A NAME="16538"></A>:

<P>
FORM has been equipped with several built in rules to keep the 
number of generated terms to a minimum during the evaluation of a 
trace. These rules are:

<P>
<DL>
<DT><STRONG>rule 0</STRONG></DT>
<DD>Strings with an odd number of matrices (gamma5 counts for an even number 
    of matrices) have a trace that is zero, when using trace4 or tracen.
</DD>
<DT><STRONG>rule 1</STRONG></DT>
<DD>A string of gamma matrices is first scanned for adjacent 
matrices that have the same contractable index, or that are contracted with 
the same vector. If such a pair is found, the relations
<PRE>
      g_(1,mu,mu) = gi_(1)*d_(mu,mu)
      g_(1,p1,p1) = gi_(1)*p1.p1
</PRE>
are applied.
</DD>
<DT><STRONG>rule 2</STRONG></DT>
<DD>Next there is a scan for a pair of the same contractable 
indices that has an odd number of other matrices in between. This is done 
only for 4 dimensions (trace4) and the dimension of the indices must be 4. 
If found, the Chisholm<A NAME="16542"></A> identity is applied:
<PRE>
      g_(1,mu,m1,m2,...mn,mu) = -2*g_(1,mn,...,m2,m1)
</PRE>
</DD>
<DT><STRONG>rule 3</STRONG></DT>
<DD>Then (again only for trace4) there is a search for a pair 
of matrices with the same 4 dimensional index and an even number of 
matrices in between. If found, one of the following variations of the 
Chisholm<A NAME="16545"></A> identity is applied:
<PRE>
      g_(1,mu,m1,m2,mu) = 4*gi_(1)*d_(m1,m2)
      g_(1,mu,m1,m2,...,mj,mn,mu) =
                      2*g_(1,mn,m1,m2,...,mj)
                     +2*g_(1,mj,...,m2,m1,mn)
</PRE>
</DD>
<DT><STRONG>rule 4</STRONG></DT>
<DD>Then there is a scan for pairs of matrices that have the 
same index or that are contracted with the same vector. If found, the 
identity:
<PRE>
      g_(1,mu,m1,m2,...,mj,mn,mu) =
                2*d_(mu,mn)*g_(1,mu,m1,m2,...,mj)
               -2*d_(mu,mj)*g_(1,mu,m1,m2,...,mn)
                ....
             -/+2*d_(mu,m2)*g_(1,mu,m1,...,mj,mn)
             +/-2*d_(mu,m1)*g_(1,mu,m2,...,mj,mn)
             -/+  d_(mu,mu)*g_(1,m1,m2,...,mj,mn)
</PRE>
is used to 'anticommute'<A NAME="16550"></A> these identical 
objects till they become adjacent and can be eliminated with the 
application of rule 1. In the case of an n-dimensional trace and when 
<code>mu</code> is an index (it might also be a vector in the above formula) for 
which the definition of the dimension involved two symbols, there is a 
shorter formula. In that case the last three terms can be combined into two 
terms:
<PRE>
     -/+(n-4)*g_(1,m1,m2,...,mj,mn)
     -/+4*d_(m1,m2)*g_(1,m3,m4,...,mj,mn)
</PRE>
It should be clear now that this formula is only superior, when 
there is a single symbol to represent <SPAN CLASS="MATH"><IMG STYLE="height: 2.53ex; vertical-align: -0.69ex; " SRC="img4.svg"
 ALT="$(n-4)$"></SPAN>. After this all gamma 
matrices that are left have a different index or are contracted with 
different vectors. These are treated using:
</DD>
<DT><STRONG>rule5</STRONG></DT>
<DD>Traces in 4 dimensions for which all gamma matrices have 
a different index, or are contracted with a different four-vector are 
evaluated using the reduction formula
<PRE>
      g_(1,mu,nu,ro) =
                 g_(1,5_,si)*e_(mu,nu,ro,si)
                +d_(mu,nu)*g_(1,ro)
                -d_(mu,ro)*g_(1,nu)
                +d_(nu,ro)*g_(1,mu)
</PRE>
For tracen the generating algorithm is based on the generation of all 
possible pairs of indices/vectors that occur in the gamma matrices in 
combination with their proper sign. When the dimension is not specified, 
there is no shorter expression.
</DD>
</DL>

<P>
Remarks:

<P>
When an index is declared to have dimension n and the command trace4 is 
used, the special 4 dimensional rules 2 and 3 are not applied to this 
index. The application of rule 1 or 4 will then give the correct 
results. The result will nevertheless be wrong due to rule 5, when there 
are at least 10 gamma matrices left after the application of the first 4 
rules, as the two algorithms in rule 5 give a difference only, when 
there are at least 10 gamma matrices. For counting gamma matrices the 
<SPAN CLASS="MATH"><IMG STYLE="height: 1.66ex; vertical-align: -0.56ex; " SRC="img48.svg"
 ALT="$\gamma_5$"></SPAN> counts for 4 matrices with respect to this rule. The result 
is unpredictable, when both indices in four dimensions and indices in n 
dimensions occur in the same string of gamma matrices. Therefore one 
should be very careful, when using the four dimensional trace under the 
condition that the results need to be correct in n dimensions. This is 
sometimes needed, when a <SPAN CLASS="MATH"><IMG STYLE="height: 1.66ex; vertical-align: -0.56ex; " SRC="img48.svg"
 ALT="$\gamma_5$"></SPAN> is involved. The tracen-statement 
will not allow the presence of a <SPAN CLASS="MATH"><IMG STYLE="height: 1.66ex; vertical-align: -0.56ex; " SRC="img48.svg"
 ALT="$\gamma_5$"></SPAN>. In general it is best to 
emulate n-dimensional traces with a <SPAN CLASS="MATH"><IMG STYLE="height: 1.66ex; vertical-align: -0.56ex; " SRC="img48.svg"
 ALT="$\gamma_5$"></SPAN> separately. The eventual 
trace, with all matrices with a different index, can be generated with 
the use of the 'distrib_' function:
<PRE>
    *
    *   Symmetric trace of a gamma5 and 12 regular matrices
    *
    I   m1,...,m12;
    F   G5,g1,g2;
    L   F = G5(m1,...,m12);
    id  G5(?a) = distrib_(-1,4,g1,g2,?a);
    id  g1(?a) = e_(?a);
    id  g2(?a) = g_(1,?a);
    tracen,1;
    .end

Time =       1.07 sec    Generated terms =      51975
                F        Terms in output =      51975
                         Bytes used      =     919164
</PRE>
This rather symmetric result is in contrast to the 4-dimensional result 
which is much shorter, but it is very unsymmetric:
<PRE>
    *
    *   Regular trace of a gamma5 and 12 regular matrices
    *
    I   m1,...,m12;
    L   F = g_(1,5_,m1,...,m12);
    trace4,1;
    .end

Time =       0.02 sec    Generated terms =       1053
                F        Terms in output =       1029
                         Bytes used      =      20284
</PRE>
The precise workings of the distrib_<A NAME="16560"></A> function is given in 
<A HREF="#fundistrib">8.12</A>.

<P>
One should be careful when using projection operators of spinors. The 
sloppy way is to write
<PRE>
    (g_(1,p)+m)
</PRE>
but technically this is not correct. The correct way is
<PRE>
    (g_(1,p)+m*gi_(1))
</PRE>
to avoid the possibility that in the end a trace will be taken over a term 
that does not have any gamma matrix. If the projection operator is however 
multiplied by other gamma matrices, it makes no difference whether the unit 
matrix is present. That is why the sloppy notation will almost always give 
the correct result. Almost always....

<P>

<H1><A ID="SECTION001600000000000000000"></A>
<A ID="metric"></A>
<BR>
A few notes on the use of a metric
</H1>

<P>
When FORM was designed, it was decided to make its syntax more or 
less independent of a choice of the metric<A NAME="16656"></A>. Hence statements 
and facilities that programs like Schoonschip<A NAME="16657"></A> or 
REDUCE<A NAME="16658"></A> provide but which depend on the choice of a metric 
have been left out. Instead there are facilities to implement any choice of 
the metric, when the need really arises. When one makes a proper study of 
it, it turns out that one usually has to do very little or nothing. 
<BR>

<P>
First one should realize that FORM does not know any specific 
metric by itself. Dotproducts are just objects of manipulation. It is 
assumed that when a common index of two vectors is contracted, this works 
out properly into a scalar object. This means that if one has a metric with 
upper and lower indices<A NAME="16660"></A><A NAME="16661"></A>, one 
index is supposed to be an upper index and the other is supposed to be a 
lower index. If the user does not like this, it is his/her responsibility 
to force the system into a different action. This is reflected in the fact 
that FORM does not have an internal metric tensor<A NAME="16662"></A> 
<SPAN CLASS="MATH"><IMG STYLE="height: 1.88ex; vertical-align: -0.78ex; " SRC="img119.svg"
 ALT="$\eta_{\mu\nu}$"></SPAN>. It has only a Kronecker<A NAME="16664"></A> 
delta<A NAME="16665"></A> <!-- MATH
 $\delta_{\mu\nu} =$
 -->
<SPAN CLASS="MATH"><IMG STYLE="height: 2.49ex; vertical-align: -0.78ex; " SRC="img120.svg"
 ALT="$\delta_{\mu\nu} =$"></SPAN> <code>d_(mu,nu)</code> with 
<code>p(mu)*d_(mu,nu)*q(nu)</code> <SPAN CLASS="MATH"><IMG STYLE="height: 1.06ex; vertical-align: -0.11ex; " SRC="img86.svg"
 ALT="$\rightarrow$"></SPAN> <code>p.q</code> when mu and nu are 
summable indices<A NAME="16667"></A>. <BR>

<P>
The dependency of a metric usually enters with statements like 
<SPAN CLASS="MATH"><IMG STYLE="height: 2.59ex; vertical-align: -0.56ex; " SRC="img121.svg"
 ALT="$p^2 = \pm m^2$"></SPAN>, which the user should provide anyway, because FORM does 
not have such knowledge. Connected to this is the choice of a 
propagator<A NAME="16669"></A> as either <!-- MATH
 $\gamma_\mu p_\mu + m$
 -->
<SPAN CLASS="MATH"><IMG STYLE="height: 2.24ex; vertical-align: -0.78ex; " SRC="img122.svg"
 ALT="$\gamma_\mu p_\mu + m$"></SPAN> or 
<!-- MATH
 $\gamma_\mu p_\mu + i\ m$
 -->
<SPAN CLASS="MATH"><IMG STYLE="height: 2.41ex; vertical-align: -0.78ex; " SRC="img123.svg"
 ALT="$\gamma_\mu p_\mu + i\ m$"></SPAN>. This is also something the user should provide. 
The only objects that FORM recognizes and that could be considered as 
metric-dependent are the gamma matrices<A NAME="16670"></A> and the 
Levi-Civita<A NAME="16671"></A> tensor<A NAME="16672"></A> 
<code>e_</code>. Because the trace of a <SPAN CLASS="MATH"><IMG STYLE="height: 1.66ex; vertical-align: -0.56ex; " SRC="img48.svg"
 ALT="$\gamma_5$"></SPAN> involves a Levi-Civita tensor, 
the two are intimately connected. The anticommutator of two gamma matrices 
is defined with the Kronecker delta. Amazingly enough that works out well, 
provided that, if such Kronecker delta's survive in the output, they are 
interpreted as a metric tensor. This should be done with great care, 
because at such a point one does something that depends of the metric; one 
may have to select whether the indices are upper or lower indices. One 
should check carefully that the way the output is interpreted leads indeed 
to the results that are expected. This is anyway coupled to how one should 
interpret the input, because in such a case one would also have an input 
with `open' indices and give them a proper interpretation. The rule is that 
generally one does not have to do anything. The upper indices in the input 
will be upper indices in the output and the same for lower indices. 
<BR>

<P>
The contraction<A NAME="16674"></A> of two Levi-Civita tensors will give products of 
Kronecker delta's. This means that formally there could be an error of the 
sign of the determinant of the metric tensor, if one would like the 
Kronecker delta to play the role of a metric tensor. Hence it is best to 
try to avoid such a situation. <BR>

<P>
In FORM the <SPAN CLASS="MATH"><IMG STYLE="height: 1.66ex; vertical-align: -0.56ex; " SRC="img48.svg"
 ALT="$\gamma_5$"></SPAN> is an object that anticommutes with 
the <SPAN CLASS="MATH"><IMG STYLE="height: 1.88ex; vertical-align: -0.78ex; " SRC="img124.svg"
 ALT="$\gamma_\mu$"></SPAN> and has <!-- MATH
 $\gamma_5\gamma_5 = 1$
 -->
<SPAN CLASS="MATH"><IMG STYLE="height: 2.15ex; vertical-align: -0.56ex; " SRC="img125.svg"
 ALT="$\gamma_5\gamma_5 = 1$"></SPAN>. Its properties 
in the trace are 
<BR>
<DIV ALIGN="CENTER">

<!-- MATH
 \begin{eqnarray}
Tr[\gamma_5\gamma_{m_1}\gamma_{m_2}\gamma_{m_3}\gamma_{m_4}] & = &
		4 \epsilon_{\mu_1\mu_2\mu_3\mu_4} \nonumber
\end{eqnarray}
 -->
<TABLE CELLPADDING="0" ALIGN="CENTER" WIDTH="100%">
<TR VALIGN="MIDDLE"><TD NOWRAP ALIGN="RIGHT"><IMG STYLE="height: 2.53ex; vertical-align: -0.69ex; " SRC="img126.svg"
 ALT="$\displaystyle Tr[\gamma_5\gamma_{m_1}\gamma_{m_2}\gamma_{m_3}\gamma_{m_4}]$"></TD>
<TD ALIGN="CENTER" NOWRAP><IMG STYLE="height: 1.06ex; vertical-align: -0.11ex; " SRC="img42.svg"
 ALT="$\textstyle =$"></TD>
<TD ALIGN="LEFT" NOWRAP><IMG STYLE="height: 2.38ex; vertical-align: -0.78ex; " SRC="img127.svg"
 ALT="$\displaystyle 4 \epsilon_{\mu_1\mu_2\mu_3\mu_4}$"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
&nbsp;</TD></TR>
</TABLE></DIV>
<BR CLEAR="ALL"><P></P>
This has a number of interesting consequences. The V-A and V+A currents are 
represented by <!-- MATH
 $\gamma_7\gamma_\mu = (1-\gamma_5)\gamma_\mu$
 -->
<SPAN CLASS="MATH"><IMG STYLE="height: 2.62ex; vertical-align: -0.78ex; " SRC="img128.svg"
 ALT="$\gamma_7\gamma_\mu = (1-\gamma_5)\gamma_\mu$"></SPAN> and 
<!-- MATH
 $\gamma_6\gamma_\mu = (1+\gamma_5)\gamma_\mu$
 -->
<SPAN CLASS="MATH"><IMG STYLE="height: 2.62ex; vertical-align: -0.78ex; " SRC="img129.svg"
 ALT="$\gamma_6\gamma_\mu = (1+\gamma_5)\gamma_\mu$"></SPAN> respectively. Under 
conjugation we have to replace <SPAN CLASS="MATH"><IMG STYLE="height: 1.66ex; vertical-align: -0.56ex; " SRC="img48.svg"
 ALT="$\gamma_5$"></SPAN> by <SPAN CLASS="MATH"><IMG STYLE="height: 2.01ex; vertical-align: -0.56ex; " SRC="img130.svg"
 ALT="$-\gamma_5$"></SPAN> as is not 
uncommon. <BR>

<P>
There was a time that a conjugation<A NAME="16684"></A> operation 
was planned in FORM. As time progressed, it was realized that this would 
introduce problems with some of the internal objects. Hence some objects 
have the property that they are considered imaginary<A NAME="16685"></A>. In 
practise FORM does not do anything with this. Neither does it do anything 
with the declarations real<A NAME="16686"></A>, complex<A NAME="16687"></A> and 
imaginary<A NAME="16688"></A>. If ever a way is found to implement a conjugation 
operator that will make everybody happy, it may still be built in. 
<BR>

<P>
The above should give the user enough information to convert any 
specific metric to what is needed to make FORM do what is expected from it. 
Afterwards one can convert back, provided no metric<A NAME="16690"></A> specific 
operations are done. Such metric specific things are for instance needed in 
some types of approximations in which one substitutes objects by 
(vector)components halfway the calculation. In that case one cannot rely on 
that the conversions at the beginning and the end will be compensating each 
other. For this case FORM allows the user to define a private metric. All 
the tools exist to make this a success with the exception of a loss in 
speed of course. Let us have a look at the contraction of two Levi-Civita 
tensors in an arbitrary metric:
<PRE>
    Indices m1,m2,m3,n1,n2,n3,i1,i2,i3;
    Cfunction eta(symmetric),e(antisymmetric);
    Off Statistics;
    *
    *   We have our own Levi-Civita tensor e
    *
    Local F = e(m1,m2,m3)*e(m1,m2,m3);
    *
    *   We write the contraction as
    *
    id  e(m1?,m2?,m3?)*e(n1?,n2?,n3?) =
            e_(m1,m2,m3)*e_(i1,i2,i3)*
                eta(n1,i1)*eta(n2,i2)*eta(n3,i3);
    *
    *   Now we can use the internal workings of the contract:
    *
    Contract;
    Print +s;
    .sort

   F =
       + eta(i1,i1)*eta(i2,i2)*eta(i3,i3)
       - eta(i1,i1)*eta(i2,i3)^2
       - eta(i1,i2)^2*eta(i3,i3)
       + 2*eta(i1,i2)*eta(i1,i3)*eta(i2,i3)
       - eta(i1,i3)^2*eta(i2,i2)
      ;

    *
    *   For specifying a metric we need individual components:
    *
    Sum i1,1,2,3;
    Sum i2,1,2,3;
    Sum i3,1,2,3;
    Print +s;
    .sort

   F =
       + 6*eta(1,1)*eta(2,2)*eta(3,3)
       - 6*eta(1,1)*eta(2,3)^2
       - 6*eta(1,2)^2*eta(3,3)
       + 12*eta(1,2)*eta(1,3)*eta(2,3)
       - 6*eta(1,3)^2*eta(2,2)
      ;

    *
    *   And now we can provide the metric tensor
    *
    id  eta(1,1) = 1;
    id  eta(2,2) = 1;
    id  eta(3,3) = -1;
    id  eta(1,2) = 0;
    id  eta(1,3) = 0;
    id  eta(2,3) = 0;
    Print +s;
    .end

   F =
       - 6
      ;
</PRE>
This is the ultimate in flexibility<A NAME="16693"></A> of course. It can 
also be worked out in a different way. In this case we try to change the 
behaviour of the Kronecker<A NAME="16694"></A> delta<A NAME="16695"></A> a 
bit. This is dangerous<A NAME="16696"></A> and needs, in addition to a good 
understanding of what is happening, good testing to make sure that what the 
user wants is indeed what does happen. Here we use the 
FixIndex<A NAME="16697"></A> (<A HREF="#substafixindex">7.59</A>) statement. This one assigns 
specific values to selected diagonal elements of the Kronecker delta. Of 
course it is the responsibility of the user to make sure that the 
calculation will indeed run into those elements. This is by no means 
automatic, because when FORM uses formal indices it never writes them out 
in components. Moreover, it would not be defined what would be the 
components connected to an index. The index could run over <SPAN CLASS="MATH"><IMG STYLE="height: 2.15ex; vertical-align: -0.56ex; " SRC="img131.svg"
 ALT="$0,1,2,3$"></SPAN> or 
over <SPAN CLASS="MATH"><IMG STYLE="height: 2.15ex; vertical-align: -0.56ex; " SRC="img132.svg"
 ALT="$1,2,3,4$"></SPAN>, or maybe even over <SPAN CLASS="MATH"><IMG STYLE="height: 2.15ex; vertical-align: -0.56ex; " SRC="img133.svg"
 ALT="$5,7,9,11$"></SPAN>. And what does an 
n-dimensional index run over? In the above example it is the sum 
(<A HREF="#substasum">7.138</A>) statement that determines this. Hence this is fully under 
the control of the user. Therefore a proper way to deal with the above 
example would be
<PRE>
    Indices i1,i2,i3;
    FixIndex 1:1,2:1,3:-1;
    Off Statistics;
    *
    Local F = e_(i1,i2,i3)*e_(i1,i2,i3);
    Sum i1,1,2,3;
    Sum i2,1,2,3;
    Sum i3,1,2,3;
    Print +s;
    .sort

   F =
       + 6*e_(1,2,3)*e_(1,2,3)
      ;

    Contract;
    Print +s;
    .end

   F =
       - 6
      ;
</PRE>
In the case that one would like to exchange the order of the summation and 
the contraction, while using the FixIndex mechanism, one needs to be more 
careful. In that case we have to prevent the indices from being summed over 
while they are indices of a Kronecker delta, because as long as the indices 
are symbolic, FORM will replace <code>d_(i1,i1)</code> by the dimension of 
<code>i1</code>, and that is not what we want. Hence we have to declare the 
indices to be non-summable by giving them dimension zero:
<PRE>
    Indices i1=0,i2=0,i3=0;
    FixIndex 1:1,2:1,3:-1;
    Off Statistics;
    *
    Local F = e_(i1,i2,i3)*e_(i1,i2,i3);
    Contract;
    Print +s;
    .sort

   F =
       + d_(i1,i1)*d_(i2,i2)*d_(i3,i3)
       - d_(i1,i1)*d_(i2,i3)*d_(i2,i3)
       - d_(i1,i2)*d_(i1,i2)*d_(i3,i3)
       + 2*d_(i1,i2)*d_(i1,i3)*d_(i2,i3)
       - d_(i1,i3)*d_(i1,i3)*d_(i2,i2)
      ;

    Sum i1,1,2,3;
    Sum i2,1,2,3;
    Sum i3,1,2,3;
    Print +s;
    .end

   F =
       - 6
      ;
</PRE>
As we can see, the automatic summation over the indices is not performed 
now and this gives us a chance to do the summation manually. After that the 
fixindex statement can have its effect. <BR>

<P>
It should be clear from the above examples that it is usually 
much easier to manipulate the input in such a way that the terms with two 
Levi-Civita tensors have the negative sign from the beginning. This would 
give programs that are less complicated and much faster. <BR>

<P>
Hence we are faced with the situation that in normal cases one 
does not do anything. If one wants to go beyond this and wants to interfere 
with the inner workings themselves by for instance inserting a factor <SPAN CLASS="MATH"><IMG STYLE="height: 1.74ex; vertical-align: -0.11ex; " SRC="img134.svg"
 ALT="$i$"></SPAN> 
in front of the <SPAN CLASS="MATH"><IMG STYLE="height: 1.66ex; vertical-align: -0.56ex; " SRC="img48.svg"
 ALT="$\gamma_5$"></SPAN> and emulating the upper and lower indices of a 
favorite metric, this leads from one problem to the next. Extreme care is 
needed. This is usually done by people who have first worked with other 
programs in which things don't work as naturally as in FORM. By the time 
one has really figured out how to deal with the metric and how to make use 
of the internal algorithms of FORM, one usually does not have to do very 
much again. <BR>

<P>
As in the Zen<A NAME="16707"></A> saying: <BR>

<P>
To the beginning student mountains<A NAME="16709"></A> are mountains 
and water<A NAME="16710"></A> is water. To the advanced student<A NAME="16711"></A> 
mountains stop being mountains and water stops being water. To the 
master<A NAME="16712"></A> mountains are mountains again and water is water 
again. <BR>

<P>
Of course the modern master also checks that what he expects the 
system to do, is indeed what the system does.

<P>

<H1><A ID="SECTION001700000000000000000"></A>
<A ID="sorting"></A>
<BR>
Sorting and statistics
</H1>

<P>
The sorting system is a vital part of FORM and one of the main reasons why 
the speed of FORM compares so favorably with other systems. 
A good understanding of what happens during the sorting<A NAME="16794"></A> of 
expressions is essential if one wants to write efficient<A NAME="16795"></A> 
programs. In essence the sorting is done by a tree<A NAME="16796"></A> sort. 
However due to the nature of mathematical expressions there is a 
complication. When two terms are identical with the possible exception of 
their coefficient, we will add their coefficients, put this new coefficient 
in the place of the coefficient of the first term, and drop the second 
term. If the new coefficient happens to be zero, both terms are dropped. 
Hence the number of terms during the sort is not fixed. For a tree sort 
this is not a major complication<A NAME="16797"></A>. What is more annoying 
though is that the new coefficient may take more space inside the storage 
than either of the old coefficients. Let us have a look now at what happens 
in a FORM program. Much can be seen from the statistics.
<PRE>
    S	x1,...,x4;
    L	F = (x1+...+x4)^4;
    .end

Time =       0.01 sec    Generated terms =         35
                F        Terms in output =         35
                         Bytes used      =        628
</PRE>
In this case the program generated 35 terms. Whenever a term is generated 
and FORM is done with it (no more statements will act on it), FORM 
will write it into a buffer which is called the small buffer. Additionally 
it stores a pointer to the location of this term inside the small buffer. 
Next it will continue generating terms. This process will be stopped by 
either of three conditions:

<OL>
<LI>FORM is finished generating terms.
</LI>
<LI>The last generated term does not fit inside the space remaining in 
the small buffer.
</LI>
<LI>There is no space for a pointer to the last generated term inside the 
array of pointers.
</LI>
</OL>
In either of these three cases FORM will sort the contents of the 
small<A NAME="16802"></A> buffer<A NAME="16803"></A>. This sorting is done 
`by pointers' and hence it is important that the whole small buffer fits 
inside the physical memory of the computer. If this would not be the case, 
some very inefficient swapping of memory might be the result. During this 
sorting FORM may run into the problem that the coefficient of two combined 
terms does not fit in the place of one of the two old coefficients. This 
means that the combined term will need more space, but because the old 
terms might be enclosed by other terms, this space may not be available 
locally. To this end FORM has some spare space in the small buffer which is 
called the small<A NAME="16804"></A> extension<A NAME="16805"></A>. 
Actually the term SmallExtension<A NAME="16806"></A> is used for the 
combination of the small buffer and its extra space. The extra space is at 
least <SPAN CLASS="MATH"><IMG STYLE="height: 2.53ex; vertical-align: -0.69ex; " SRC="img135.svg"
 ALT="$1/6$"></SPAN> times the size of the small buffer, but typically it will be 
about <SPAN CLASS="MATH"><IMG STYLE="height: 2.53ex; vertical-align: -0.69ex; " SRC="img111.svg"
 ALT="$1/3$"></SPAN> the size of the small buffer. In some exceptional cases (with 
heavy use of a polynomial coefficient via the PolyFun<A NAME="16807"></A> 
command) bigger sizes might be useful.

<P>
In the case that the new combined term needs more space than each of the 
old terms, the new term is placed in the extension space. If, during the 
sort, the extension space becomes exhausted, FORM will make a 
garbage<A NAME="16808"></A> 
collection of the entire extended small buffer. This will always result in 
the extension space becoming empty again, because the notation of the terms 
in FORM is such the new combined term will at most occupy an amount 
of space equal to the sum of the spaces of the original two terms. In older 
versions of FORM this garbage collection was executed by means of a 
temporary disk file. In the new version it is done inside the memory by 
temporarily allocating a new buffer. Anyway such garbage collections are 
relatively rare.

<P>
In the above example, the sorting occurred because the generation of terms 
was finished. Hence the sorted output is written away in such a way that it 
can be used as input for a potential next module (or to be printed). 
Hence let us change the size of the small buffer:
<PRE>
    #: SmallSize 300
    S	x1,...,x4;
    L	F = (x1+...+x4)^4;
    .end

Time =       0.00 sec    Generated terms =         13
                F      1 Terms left      =         13
                         Bytes used      =        236

Time =       0.00 sec    Generated terms =         26
                F      1 Terms left      =         26
                         Bytes used      =        476

Time =       0.00 sec    Generated terms =         35
                F      1 Terms left      =         35
                         Bytes used      =        632

Time =       0.00 sec    Generated terms =         35
                F        Terms in output =         35
                         Bytes used      =        628
</PRE>
Now the size of the small buffer will be only 300 bytes. As a result the 
13-th term does not fit. We can see this in the statistics: the 13-th term 
has been generated and FORM sorts the small buffer. The output of the 12 
sorted terms is written to another buffer, called the
large<A NAME="16811"></A> buffer<A NAME="16812"></A>. Inside the large 
buffer the terms are lightly compressed. This compression is related to the 
fact that in each `patch'<A NAME="16813"></A> the terms are already sorted and 
hence we may not have to repeat the identical beginnings of each term. 
Hence the amount of space used after this sort is less than the 300 bytes 
of the small buffer, even though the 13-th term gave an overflow for these 
300 bytes. The small buffer fills up again at the 26-th term and again it 
is sorted and the results written to the large buffer. Finally, after 35 
terms, the generation is finished. Hence the remains in the small buffer 
are also sorted and written as a third `patch' into the large buffer. Then 
the large buffer is sorted. For this a different sort technique is used. It 
is assumed that the large buffer is not always residing inside the physical 
memory. Hence parts of it may be swapped out temporarily. With the size of 
current days memories this may not happen very often, unless one sets the 
size of the buffer to something comparable to the memory size of the 
computer and several programs are running at the same time. Anyway, 
swapping will not affect the large buffer very much. FORM will merge the 
`patches' by going sequentially through them with a method called 
`tree<A NAME="16814"></A> of losers' in the book by Knuth<A NAME="16815"></A> 
(the art of computer programming, vol. 3). Because it goes sequentially 
through the patches, uses all the information it reads and never needs it 
again, this method is indeed rather well resistant to swapping.

<P>
The next complication is of course when the large buffer is full. This can 
be either because its byte space is full, or because the maximum number of 
patches is exceeded. Because the sorting method uses quite a few variables 
for each patch, there is a space allocated for them and hence there is a 
maximum number of patches. If we set this to 2 (just for demonstration 
purposes) we obtain:
<PRE>
    #: SmallSize 200
    #: LargePatches 2
    S	x1,...,x4;
    L	F = (x1+...+x4)^4;
    .end

Time =       0.00 sec    Generated terms =          9
                F      1 Terms left      =          9
                         Bytes used      =        164

Time =       0.00 sec    Generated terms =         17
                F      1 Terms left      =         17
                         Bytes used      =        312

Time =       0.00 sec    Generated terms =         26
                F      1 Terms left      =         26
                         Bytes used      =        478

Time =       0.00 sec
                F        Terms active    =         26
                         Bytes used      =        474

Time =       0.00 sec    Generated terms =         35
                F      1 Terms left      =         35
                         Bytes used      =        630

Time =       0.00 sec
                F        Terms active    =         35
                         Bytes used      =        786

Time =       0.00 sec    Generated terms =         35
                F        Terms in output =         35
                         Bytes used      =        628
</PRE>
We see that after the third small buffer has been sorted, the third patch 
cannot be written to the large buffer. Hence the large buffer is sorted 
(indicated by the special statistics involving the phrase `Terms active'). 
The result of this is written as a sorted patch to the
sort<A NAME="16818"></A> file. This file is one of the 
temporary<A NAME="16819"></A> files that FORM can create. It has the 
extension .sor<A NAME="16820"></A>. Now the third patch can be written 
into the &ndash;by now empty&ndash; large buffer. At the end of term generation, the 
last small buffer is sorted, its results written into the large buffer, 
then that is sorted and its results written as the final patch into the 
sort file. Then, finally the patches in the sort file are merged in a 
method similar to the way the large buffer is sorted. This final sort is a 
disk<A NAME="16821"></A> to disk sort. Hence it can use the disk 
rather intensely and the use of the CPU may drop temporarily, although it 
is nothing so dramatic as when the computer is involved in heavy 
inefficient swapping as can be the case with many other algebra programs. 
Also, this is usually only a small fraction of the running time of the 
program. The exception may be when FORM is running several processes and 
they are all using disk sorts simultaneously. In that case some file 
systems may not be very good at handling the ensuing
traffic<A NAME="16822"></A> jams.

<P>
Also the disk to disk sort will have a maximum number of patches that can 
be sorted simultaneously. If this number is exceeded there will be one or 
more extra stages<A NAME="16823"></A> in the sorting, all of which 
will be disk to disk sorts. It is advisable to tune the setup parameters in 
such a way that one can prevent this, because it involves usually needless 
use of resources. One can try to increase the parameter 
FilePatches<A NAME="16824"></A>, but the problem is that FORM uses a 
caching<A NAME="16825"></A> system to buffer the inputs from the sort file. The 
cache buffers have to have a size that is at least twice the maximum size 
of a term. For each patch it needs a buffer and all buffers together should 
fit inside the combination of the large buffer and the small extended 
buffer. This puts an upper limit on the number of file patches. 
Additionally this buffer (SortIOsize<A NAME="16826"></A>) should not be very 
small, because otherwise the disk IO operations are very inefficient. Hence 
it helps often to increase the size of the small buffer and the large 
buffer first. That gives fewer patches. Additionally it in turn can allow 
for more file patches that are not too small.

<P>
One thing that one can see now is that if terms are to cancel or to add, it 
is advantageous if this happens already in an early stage of the sorting. 
This means that it is most efficient if these terms will end up in the 
small buffer at the same time. This should explain the example given in the 
section on brackets<A NAME="16827"></A>. This way fewer terms are written to 
the large buffer and/or the sort file, which means that less disk space 
will be used.

<P>
The sizes of buffers involved can all be tuned to a given hardware. How 
this is done is explained in the chapter on the setup<A NAME="16828"></A> <A HREF="#setup">17</A>.

<P>
When FORM is dealing with the arguments<A NAME="16830"></A> of 
functions and if an argument is a multiterm subexpression, also such 
subexpressions need to be sorted. In older versions of FORM this was done 
inside the at that moment remaining space of the small buffer and its 
extension. The reason was that such subexpressions would be rather short 
(they would have to fit inside a function argument and were hence limited 
by the maximum size of a term) and buffer space was hard to come by in 
computers with small memories. In the new version of FORM other 
subexpression sorts were added: the sorting in the term environment (see 
<A HREF="#substaterm">7.145</A>) and the sorting of $-expressions. Both sorts do not have 
the restriction of the maximum size of a term. They can result in 
expressions that are arbitrarily long (although that might not give 
efficient programs). Hence the sorting of subexpressions have now their own 
buffers. And more than one such set may be needed if for instance the term 
environment is used in a nested fashion. Of course the settings for the 
buffers of this `subsort' are not quite as large as for the main buffers. 
And the user can of course also influence their settings as explained in 
the chapter on the setup <A HREF="#setup">17</A>. This chapter gives also all default 
values.

<P>
There is one restriction on the sorting of function arguments and 
$-expressions: They are not allowed to go into the stage4 sorting. Any 
such attempt will result in an error message and the suggestion to raise 
the size of the buffers for this type of sorting.

<P>
When FORM is running in parallel mode (either TFORM or P<SMALL>AR</SMALL>FORM) each worker 
will need its own buffers. In P<SMALL>AR</SMALL>FORM in which the processors each control 
their own memory, the size of each of these buffers are the same as for the 
master process. In TFORM with its shared memory the sizes that the user 
selects for the sort buffers and the scratch file caches refer to the 
buffers of the master thread. The workers each get basically buffers with 
1/N times the size of the buffer of the master. They may be made a bit 
bigger when potential conflicts with MaxTermSize occur.

<P>

<H1><A ID="SECTION001800000000000000000"></A>
<A ID="setup"></A>
<BR>
The setup
</H1>

<P>
When FORM is started, it has a number of settings<A NAME="16886"></A> built in 
that were determined during its installation<A NAME="16887"></A>. If the 
user would like to alter these settings, it is possible to either specify 
their desired values in a setup file<A NAME="16888"></A> or to do so at the 
beginning of the program file<A NAME="16889"></A>. There are two ways in 
which FORM can find a setup file. The first way is by having a file named 
`form.set'<A NAME="16890"></A> in the current directory. If such a file is 
present, FORM will open it and interpret its contents as setup parameters. 
If this file is not present, one may specify a setup file with the -s 
option in the command tail. This option must precede the name of the input 
file. After the -s follow one or more blanks or tabs and then the full name 
of the setup file. FORM will try to read startup parameters from this file. 
If a file `form.set' is present, FORM will ignore the -s option and its 
corresponding file name. This order of interpretation allows the user to 
define an alias with a standard setup file which can be overruled by a 
local setup file. If, in the beginning of the program file, before any 
other statements with the exception of the #- instruction and commentary 
statements, there are lines that start with #: the remaining contents of 
these lines are interpreted exactly like the lines in the setup file. The 
specifications in the program file take precedence<A NAME="16891"></A> over 
all other specifications. If neither of the above methods is used, FORM 
will use a built in set of parameters. Their values may depend on the 
installation and are given below. 

<P>
The following is a list of parameters that can be set. The syntax is rather 
simple: The full word must be specified (case insensitive), followed by one 
or more blanks or tabs and the desired number, string or character. 
Anything after this is considered to be commentary. In the setup file lines 
that do not start with an alphabetic character are seen as commentary. The 
sizes of the buffers are given in bytes, unless mentioned otherwise. A word 
is 2 bytes for 32<A NAME="16892"></A> bit machines and 4 bytes for 64<A NAME="16893"></A> bit machines.

<P>
In FORM version 3.3 and later, it is also allowed to define 
preprocessor variables<A NAME="16894"></A> (see also 
<A HREF="#preprovariables">3.1</A>) in the setup file. In addition one can use 
preprocessor variables in the setup, provided it is not in the name of the 
parameter/keyword.

<P>
<TABLE   STYLE="width:181;">
<TR><TD>bracketindexsize<A NAME="17276"></A><A NAME="17277"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:571;">
<TR><TD>Maximum size in bytes of any individual index of a 
bracketted expression. Each expression will have its own index. The index 
starts with a relatively small size and will grow if needed. But it will 
never grow beyond the specified size. If more space is needed, FORM will 
start skipping brackets and find those back later by linear search. See 
also chapter&nbsp;<A HREF="#brackets">9</A> and section&nbsp;<A HREF="#substabracket">7.11</A>.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>CommentChar<A NAME="17293"></A><A NAME="17294"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:571;">
<TR><TD>This should be followed by one or more blanks and a 
single non-blank character. This character will be used to indicate 
commentary, instead of the regular <SPAN CLASS="MATH"><IMG STYLE="height: 1.29ex; vertical-align: -0.11ex; " SRC="img3.svg"
 ALT="$*$"></SPAN> in column 1.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>CompressSize<A NAME="17307"></A><A NAME="17308"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:571;">
<TR><TD>When compressing output terms, FORM needs a compression 
buffer. This buffer deals recursively with compression and decompression of 
terms that are either written or read. Its size will be at least 
MaxTermSize but when there is heavy use of expressions in the right hand 
side of definitions or substitution it would have to be considerably 
longer. It is hoped that in the future this parameter can be eliminated. 
CompressSize should be given in bytes.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>ConstIndex<A NAME="17322"></A><A NAME="17323"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:571;">
<TR><TD>This is the number of indices that are considered to be 
constant indices like in fixed vector components (the so-called fixed 
indices). The size of this parameter is not coupled to any array space, but 
it should not go much beyond 1000 on a 32<A NAME="17330"></A> bit machine. On a 
64<A NAME="17331"></A> bit machine it can go considerably further.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>ContinuationLines<A NAME="17338"></A><A NAME="17339"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:571;">
<TR><TD>The maximum number of continuation lines, after which
expressions will be broken apart when printed. The value of 0 means that no
limit is imposed. The precise format of continuation lines depend on the
current format (see <A HREF="#substaformat">7.60</A>) settings; #write instruction also
allows for additional control (see <A HREF="#prewrite">3.64</A>).</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>Define<A NAME="17354"></A><A NAME="17355"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:571;">
<TR><TD>The syntax is as in the #define instruction in the 
preprocessor (see <A HREF="#preprovariables">3.1</A>), with the remark that in the setup 
file there should be no leading # character as that would make the line 
into commentary. Example: 
<BR><SPAN style="font-family:monospace">    define MODULUS "31991"</SPAN> 
<BR>
which could be used 
at a later point in the program to activate a modulus statement (see 
<A HREF="#substamodulus">7.90</A>).</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>DotChar<A NAME="17371"></A><A NAME="17372"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:571;">
<TR><TD>There should be a single character following this name 
(and the blank(s) after it). This character will be used instead of the _, 
when dotproducts<A NAME="17379"></A> are printed in Fortran<A NAME="17380"></A> 
output. This option is needed because some Fortran compilers do not 
recognize the underscore as a valid character. In the olden days one could 
use here the dollar character but nowadays many Fortran compilers do not 
recognize this character as belonging to a variable name.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>FunctionLevels<A NAME="17387"></A><A NAME="17388"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:571;">
<TR><TD>The maximum number of levels that may occur, when 
functions have functions in their arguments.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>HideSize<A NAME="17401"></A><A NAME="17402"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:571;">
<TR><TD>The size of the hide buffer. The size of this buffer is 
normally set equal to scratchsize (see below). If one uses the setting of 
HideSize after the setting of ScratchSize, one can give the hide buffer its 
own size. There are cases that this can make the program faster.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>IncDir<A NAME="17415"></A><A NAME="17416"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:571;">
<TR><TD>Directory (or path of directories) in which FORM will 
look for files if they are not to be found in the current directory. This 
involves files for the #include<A NAME="17423"></A> and #call<A NAME="17424"></A> 
instructions. This variable takes precedence over the 
Path<A NAME="17425"></A><A NAME="17426"></A> variable.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>InsideFirst<A NAME="17434"></A><A NAME="17435"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:571;">
<TR><TD>Not having any effect at the moment.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>JumpRatio<A NAME="17448"></A><A NAME="17449"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:571;">
<TR><TD>See the endswitch (<A HREF="#substaendswitch">7.49</A>) statement.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>MaxNumberSize<A NAME="17463"></A><A NAME="17464"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:571;">
<TR><TD>Allows the setting of the maximum size of the numbers 
in FORM. The number should be given in words. For 32<A NAME="17471"></A> bit 
systems a word is two bytes and for 64<A NAME="17472"></A> bit systems a word is 
4 bytes. The number size is always limited by the maximum size of the terms 
(see MaxTermSize). Actually it has to be less than half of MaxTermSize 
because a coefficient contains both a numerator and a denominator. It is 
not always a good idea to have the number size at its maximum value, 
especially when MaxTermSize is large. In that case it could be very long 
before a runaway algorithm runs into limitations of size (arithmetic for 
very long fractions is not very fast due to the continuous need for 
computing GCD's)</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>MaxTermSize<A NAME="17480"></A><A NAME="17481"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:571;">
<TR><TD>This<A ID="setupmaxtermsize"></A> 
is the maximum size that an individual term may occupy in words. This 
size does not affect any allocations. One should realize however that the 
larger this size is the heavier the demand can be on the workspace, because 
the workspace acts as a heap during the execution and sometimes allocations 
have to be made in advance, before FORM knows what the actual size of the 
term will be. Consequently the evaluation tree cannot be very deep, when 
WorkSpace / MaxTermSize is not very big. MaxTermSize controls mainly how 
soon FORM starts complaining about terms that are too complicated. Its 
absolute maximum is 32568 on 32<A NAME="17489"></A> bit systems and about <SPAN CLASS="MATH"><IMG STYLE="height: 2.14ex; vertical-align: -0.11ex; " SRC="img136.svg"
 ALT="$10^9$"></SPAN> 
on 64<A NAME="17490"></A> bit systems (of course the workspace would have to be 
considerably larger than that....).</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>MaxWildCards<A NAME="17499"></A><A NAME="17500"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:571;">
<TR><TD>The maximum number of wildcards that 
can be active in a single matching of a pattern. Under normal circumstance 
the default value of 100 should be more than enough.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>NoSpacesInNumbers<A NAME="17513"></A><A NAME="17514"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:571;">
<TR><TD>Long<A ID="nospacesinnumbers"></A> numbers are usually spread over several lines 
by placing a backspace character at the end of each line and then 
continuing at the next line. For cosmetic purposes FORM puts usually a few 
blank spaces at the beginning of the new line. FORM itself can read this but 
some programs cannot. Hence one can put FORM in a mode in which these 
blanks are omitted. The values of the variable are ON or OFF. There is also 
a command to change this behaviour at runtime. See the on and off commands 
in sections <A HREF="#staonnospacesinnumbers">7.107</A> and <A HREF="#staoffnospacesinnumbers">7.106</A>.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>NumStoreCaches<A NAME="17533"></A><A NAME="17534"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:571;">
<TR><TD>This number determines how many store caches (see 
the description of the SizeStoreCache setup parameter below) there will 
be. In the case of parallel processing this will be the number of caches 
per processor.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>NwriteStatistics<A NAME="17547"></A><A NAME="17548"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:571;">
<TR><TD>When this word is mentioned, the default setting for the 
statistics is that no run time statistics will be shown. Ordinarily they 
will be shown.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>NwriteThreadStatistics<A NAME="17561"></A>
<A NAME="17562"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:571;">
<TR><TD>
<BR>
<BR>
This variable has the values ON or OFF. It controls for 
TFORM whether the statistics of the individual threads will be printed. The
default value is ON.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>OldOrder<A NAME="17578"></A><A NAME="17579"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:571;">
<TR><TD>A special flag (values ON/OFF) by which one can still 
select the old option of not checking for the order of statements inside a 
module. This should be used only in the case that it is nearly impossible 
to change a program to the new mode in which the order of the statements 
(declarations etc) is relevant. In the future this old mode may not exist.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>Parentheses<A NAME="17592"></A><A NAME="17593"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:571;">
<TR><TD>The maximum number of nestings of parentheses or 
functions inside functions. The variable may be eliminated in a later 
version.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>Path<A NAME="17606"></A><A NAME="17607"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:571;">
<TR><TD>Directory (or path of directories) in which FORM will 
look for files if they are not to be found in the current directory. This 
involves files for the #include<A NAME="17614"></A> and #call<A NAME="17615"></A> 
instructions. FORM will test this path after a potential path specified as 
IncDir<A NAME="17616"></A><A NAME="17617"></A>.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>ProcedureExtension<A NAME="17626"></A><A NAME="17627"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:571;">
<TR><TD>The extension that will be used by FORM for finding the 
procedures that are in separate files. Restrictions on the strings used are 
as explained in the preprocessor 
#procedureextension<A NAME="17634"></A> instruction in section 
<A HREF="#preprocedureextension">3.44</A>.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>ProcessBucketSize<A NAME="17643"></A><A NAME="17644"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:571;">
<TR><TD><A ID="setupprocessbucketsize"></A> For the parallel version 
P<SMALL>AR</SMALL>FORM. It is ignored in other versions. Tells P<SMALL>AR</SMALL>FORM how many terms 
there should be in the buckets that are being distributed over the 
secondary processors. See also <A HREF="#substaprocessbucketsize">7.116</A>.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>ResetTimeOnClear<A NAME="17661"></A><A NAME="17662"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:571;">
<TR><TD>The value is ON or OFF. The default value is ON. This 
means that by default the clock is reset after each .clear<A NAME="17669"></A> 
(see chapter <A HREF="#modules">4</A> on modules) instruction at the end of a module.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>ScratchSize<A NAME="17677"></A><A NAME="17678"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:571;">
<TR><TD>The size of the input and the output buffers for the 
regular algebra processing. Terms are read in in chunks this size and are 
written to the output file using buffers of this size. There are either two 
or three of these buffers, depending on whether the hide<A NAME="17685"></A> 
facility is being used (see <A HREF="#substahide">7.67</A>). These buffers must have a 
size that is at least as large as the MaxTermSize<A NAME="17687"></A>. These 
buffers act as caches for the files with the extension .sc1<A NAME="17688"></A>, 
.sc2<A NAME="17689"></A> and .sc3<A NAME="17690"></A>. See also the HideSize parameter 
above for the independent setting of the size of the hide buffer.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>SizeStoreCache<A NAME="17697"></A><A NAME="17698"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:571;">
<TR><TD>The size of the caches<A NAME="17705"></A> that are used for 
reading terms when stored expressions are used in the r.h.s. of a 
statement. Typically there are several such caches and they make the 
reading much faster. In the case of parallel processing these caches become 
very important because without them the different processes may all want to 
read from the .str<A NAME="17706"></A> file<A NAME="17707"></A> at the same time and 
execution speed will suffer badly. The number of store caches is determined 
by the NumStoreCaches<A NAME="17708"></A> setup parameter which is 
described above. The size of these caches doesn't have to be very large as 
compared to some of the other buffers. It is recommended though to have 
them at least as large as MaxTermSize<A NAME="17709"></A> (see above).</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>SortType<A NAME="17716"></A><A NAME="17717"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:571;">
<TR><TD>Possible values are "lowfirst"<A NAME="17724"></A>, 
"highfirst"<A NAME="17725"></A> and "powerfirst"<A NAME="17726"></A>. "lowfirst" 
is the default. Determines the order in which the terms are placed during 
sorting. In the case of lowfirst, lower powers of symbols and dotproducts 
come before higher powers. In the case of highfirst it is the opposite. In 
the case of powerfirst the combined powers of all symbols together are 
considered and the highest combined powers come first. See also the 
on<A NAME="17727"></A> statement in <A HREF="#substaon">7.107</A>.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>TempDir<A NAME="17735"></A><A NAME="17736"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:571;">
<TR><TD>This variable should contain the name of a directory 
that is the directory in which FORM should make its temporary files. If the 
-t option is used when FORM is started, the TempDir variable in the 
setup file is ignored. FORM can create a number of different temporary 
files.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>TempSortDir<A NAME="17752"></A><A NAME="17753"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:571;">
<TR><TD>This variable should contain the name of a directory 
that is the directory in which FORM should make its temporary sort files. 
If the -ts option is used when FORM is started, the TempSortDir variable in 
the setup file is ignored. If TempSortDir is not specified, then the value of 
TempDir is used also for sort files.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>ThreadBucketSize<A NAME="17770"></A><A NAME="17771"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:571;">
<TR><TD>Only relevant for TFORM. The size of the number of 
terms sent to the workers simultaneously. 
For details see the chapter on the parallel version (<A HREF="#parallel">18</A>).</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>ThreadLoadBalancing<A NAME="17786"></A><A NAME="17787"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:571;">
<TR><TD>Only relevant for TFORM. Possible values are ON 
or OFF. For details see the chapter on the parallel version (<A HREF="#parallel">18</A>).</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>Threads<A NAME="17802"></A><A NAME="17803"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:571;">
<TR><TD>Only relevant for TFORM (see chapter on the parallel 
version). Specifies the default number of worker threads to be used. The 
values 0 and 1 will indicate that running will only be done by the master 
thread (<A HREF="#parallel">18</A>).</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>ThreadScratchOutSize<A NAME="17818"></A><A NAME="17819"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:571;">
<TR><TD>The size of the output scratch buffers for each of the 
worker threads. These buffers will be used when the InParallel 
statement&nbsp;<A HREF="#substainparallel">7.76</A> is active. They are used to catch the 
output of the expressions as processed by the individual workers before 
they are copied to the output scratch buffer/file of the master. The output 
scratch buffer/file of each worker will never contain more than one 
expression at a time.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>ThreadScratchSize<A NAME="17833"></A><A NAME="17834"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:571;">
<TR><TD>The size of the input scratch buffers for each of the 
worker threads. These buffers are only used when the main scratch buffers 
of the master process aren't sufficient and scratch files have been made. 
When the buffers of the master are big enough, the workers only use 
pointers to the buffer of the master. Once there are scratch files the 
buffer is used for caching the input from those files. In that case each 
worker has its own cache. For reading purposes it can actually be counter 
productive if these buffers are very large. This parameter sets the value 
for the input and the hide<A NAME="17841"></A> scratch files. The output scratch 
size for the workers is set with the ThreadScratchOutSize parameter.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>TotalSize<A NAME="17848"></A><A NAME="17849"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:571;">
<TR><TD>Puts FORM in a mode in which it tries to determine 
the maximum space occupied by all expressions at any given moment during 
the execution of the program. This space is the sum of the 
input/output/hide scratch files, the sort file(s) and the .str file. This 
maximum is printed at the end of the program. The same can be obtained with 
the "On TotalSize" statement (see <A HREF="#ontotalsize">7.107</A>) or the -T option 
in the command tail when FORM is started (see <A HREF="#running">1</A>).</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>WorkSpace<A NAME="17866"></A><A NAME="17867"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:571;">
<TR><TD>The size of the heap that is used by the algebra 
processor when it is evaluating the substitution tree. It will contain 
terms, half finished terms and other information. The size of the workspace 
may be a limitation on the depth of a substitution tree.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:181;">
<TR><TD>WTimeStats<A NAME="17880"></A><A NAME="17881"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:571;">
<TR><TD>Turns on the wall-clock time mode in the statistics. 
See the `<SPAN  CLASS="texttt">On wtimestats</SPAN>' statement&nbsp;<A HREF="#substaon">7.107</A>.</TD></TR>
</TABLE>
    <BR>

<P>
Variables that take a path<A NAME="17123"></A> for their value expect a sequence of 
directories, separated by colon characters as in the UNIX<A NAME="17124"></A> way 
to define such objects.

<P>
The above parameters are conceptually relatively easy. The parameters that 
are still left are more complicated and are often restricted in their 
size by some relationships. Hence it is necessary to understand the 
sorting inside FORM a little bit before using them. On the other hand 
these parameters can influence the performance noticeably. See also chapter 
<A HREF="#sorting">16</A> for more details.

<P>
When terms are send to `output' by the main algebra engine, they are put 
inside a buffer. This buffer is called the `small<A NAME="17126"></A> 
buffer<A NAME="17127"></A>'. Its size is given by the variable <I CLASS="slanted">SmallSize<A NAME="17128"></A></I>. When this buffer is full, or when the number 
of terms in this buffer exceeds a given maximum, indicated by the variable 
<I CLASS="slanted">TermsInSmall<A NAME="17129"></A></I>, the contents of the buffer are 
sorted. The sorting is done by pointers, hence it is important that the 
small buffer resides inside the physical memory. During the sorting it may 
happen that coefficients are added. The sum of two rational numbers can 
take more space than any of the individual numbers, so there will be a 
space problem. This has been solved by the construction of an extension to 
the small buffer. The variable <I CLASS="slanted">SmallExtension<A NAME="17130"></A></I> 
is the size of the small buffer together with this extension. The value for 
SmallExtension will always be at least 7/6 times the value of SmallSize.

<P>
The result of the sorting of the small buffer is written to the 
`large<A NAME="17131"></A> buffer<A NAME="17132"></A>' (with the size <I CLASS="slanted">LargeSize<A NAME="17133"></A></I>) as a single object and the filling of the 
small buffer can resume. Whenever there is not enough room in the large 
buffer for the result of sorting the small buffer, or whenever there are 
already a given number of these sorted `patches' in it (controlled by the 
variable <I CLASS="slanted">LargePatches<A NAME="17134"></A></I>) the buffer will be sorted 
by merging the patches<A NAME="17135"></A> to make room for the new results. The 
output is written to the sort file as a single patch. Then the results from 
the small buffer can be written to the large buffer. This game can continue 
till no more terms are generated. In the end it will be necessary to sort 
the results in the intermediate sort file<A NAME="17136"></A>. This can be 
done with up to <I CLASS="slanted">FilePatches<A NAME="17137"></A></I> at a time. Because 
file operations are notoriously slow the combination of the small buffer, 
the small extension and the large buffer is used for caching<A NAME="17138"></A> 
purposes. Hence this space can be split in `FilePatches' caches. The 
limitation is that each cache should be capable to contain at least two 
terms of maximal size. This means that the sum of SmallExtension and 
LargeSize must be at least FilePatches times 2*MaxTermSize*(bytes in short 
integer). It is possible to set the size of these caches directly with the 
variable <I CLASS="slanted">SortIOsize<A NAME="17139"></A></I>. If the variable is too large, 
the variable FilePatches may be adjusted by FORM. If there are more than 
FilePatches patches in the sort file, a second sort file is needed for the 
output of each `superpatch'<A NAME="17140"></A>. When the first sort file has 
been treated, the second sort file can be treated in exactly the same way 
as its predecessor. This process will finish eventually. When there are at 
most FilePatches patches in a sort file, the output of their merging can be 
written directly to the regular output. For completeness we give a list of 
all these variables:

<P>
<TABLE   STYLE="width:136;">
<TR><TD>FilePatches<A NAME="17898"></A><A NAME="17899"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>The maximum number of patches that can be merged 
simultaneously, when the intermediate sort file is involved.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:136;">
<TR><TD>LargePatches<A NAME="17912"></A><A NAME="17913"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>The maximum number of patches that is allowed in the 
large buffer. The large buffer may reside in virtual memory, due to the 
nature of the sort that is applied to it.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:136;">
<TR><TD>TermsInSmall<A NAME="17926"></A><A NAME="17927"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>The maximum number of terms that is allowed in the small 
buffer before it is sorted. The sorted result is either copied to the large 
buffer or written to the intermediate sort file (when LargeSize is too 
small).</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:136;">
<TR><TD>SmallSize<A NAME="17940"></A><A NAME="17941"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>The size of the small buffer in bytes.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:136;">
<TR><TD>SmallExtension<A NAME="17954"></A><A NAME="17955"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>The size of the small buffer plus its extension.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:136;">
<TR><TD>LargeSize<A NAME="17968"></A><A NAME="17969"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>The size of the large buffer.</TD></TR>
</TABLE>
    <BR>

<P>
<TABLE   STYLE="width:136;">
<TR><TD>SortIOsize<A NAME="17982"></A><A NAME="17983"></A>
</TD></TR>
</TABLE>
<BR>
<TABLE   STYLE="width:590;">
<TR><TD>The size of the buffer that is used to write to the 
intermediate sorting file and to read from it. It should be noted that if 
this buffer is not very large, the sorting of large files may become rather 
slow, depending on the operating system. Hence we recommend a potential 
fourth stage in the sorting over having this number too small to fit more 
filepatches in the combined small and large buffer. Setting the small and 
large buffers to a decent size may avoid all problems by a: making more 
space for the caching, b: creating fewer file patches to start with.</TD></TR>
</TABLE>
    <BR>

<P>
There is a second set of the above setup parameters for sorts of 
subexpressions<A NAME="17176"></A> as in function arguments or in the 
term environment (see <A HREF="#substaterm">7.145</A>). Because these things can happen 
with more than one level, whatever allocations have to be made (during 
runtime when needed) may have to be made several times. Hence one should be 
far more conservative here than with the global allocations. Anyway, those 
sorts should rarely involve anything very big. With the function arguments 
the condition is that the final result will fit inside a single term, but 
with the term environment no such restriction exists. The relevant 
variables here are subfilepatches, sublargepatches, sublargesize, 
subsmallextension, subsmallsize, subsortiosize and subtermsinsmall. Their 
meanings are the same as for the variables without the sub in front.

<P>
When FORM is running in parallel mode (either TFORM or P<SMALL>AR</SMALL>FORM) each worker 
will need its own buffers. In P<SMALL>AR</SMALL>FORM in which the processors each control 
their own memory, the size of each of these buffers are the same as for the 
master process. In TFORM with its shared memory the above sizes refer to 
the buffers of the master thread. The workers each get basically buffers 
with 1/N times the size of the buffer of the master. This may get made a 
bit bigger when potential conflicts with MaxTermSize occur.

<P>
The default settings are
<DIV class="CENTER">
<TABLE class="PAD  BORDER" style="">
<TR><TD CLASS="LEFT">Variable</TD>
<TD CLASS="RIGHT">32-bits</TD>
<TD CLASS="RIGHT">64-bits</TD>
<TD CLASS="RIGHT">tform 64-bits</TD>
</TR>
<TR><TD CLASS="LEFT">bracketindexsize</TD>
<TD CLASS="RIGHT">200000</TD>
<TD CLASS="RIGHT">200000</TD>
<TD CLASS="RIGHT">200000</TD>
</TR>
<TR><TD CLASS="LEFT">commentchar</TD>
<TD CLASS="RIGHT"><SPAN CLASS="MATH"><IMG STYLE="height: 1.29ex; vertical-align: -0.11ex; " SRC="img3.svg"
 ALT="$*$"></SPAN></TD>
<TD CLASS="RIGHT"><SPAN CLASS="MATH"><IMG STYLE="height: 1.29ex; vertical-align: -0.11ex; " SRC="img3.svg"
 ALT="$*$"></SPAN></TD>
<TD CLASS="RIGHT"><SPAN CLASS="MATH"><IMG STYLE="height: 1.29ex; vertical-align: -0.11ex; " SRC="img3.svg"
 ALT="$*$"></SPAN></TD>
</TR>
<TR><TD CLASS="LEFT">compresssize</TD>
<TD CLASS="RIGHT">90000</TD>
<TD CLASS="RIGHT">90000</TD>
<TD CLASS="RIGHT">90000</TD>
</TR>
<TR><TD CLASS="LEFT">constindex</TD>
<TD CLASS="RIGHT">128</TD>
<TD CLASS="RIGHT">128</TD>
<TD CLASS="RIGHT">128</TD>
</TR>
<TR><TD CLASS="LEFT">continuationlines</TD>
<TD CLASS="RIGHT">15</TD>
<TD CLASS="RIGHT">15</TD>
<TD CLASS="RIGHT">15</TD>
</TR>
<TR><TD CLASS="LEFT">dotchar</TD>
<TD CLASS="RIGHT">.</TD>
<TD CLASS="RIGHT">.</TD>
<TD CLASS="RIGHT">.</TD>
</TR>
<TR><TD CLASS="LEFT">filepatches</TD>
<TD CLASS="RIGHT">256</TD>
<TD CLASS="RIGHT">256</TD>
<TD CLASS="RIGHT">256</TD>
</TR>
<TR><TD CLASS="LEFT">functionlevels</TD>
<TD CLASS="RIGHT">30</TD>
<TD CLASS="RIGHT">30</TD>
<TD CLASS="RIGHT">30</TD>
</TR>
<TR><TD CLASS="LEFT">hidesize</TD>
<TD CLASS="RIGHT">50000000</TD>
<TD CLASS="RIGHT">50000000</TD>
<TD CLASS="RIGHT">50000000</TD>
</TR>
<TR><TD CLASS="LEFT">incdir</TD>
<TD CLASS="RIGHT">.</TD>
<TD CLASS="RIGHT">.</TD>
<TD CLASS="RIGHT">.</TD>
</TR>
<TR><TD CLASS="LEFT">insidefirst</TD>
<TD CLASS="RIGHT">ON</TD>
<TD CLASS="RIGHT">ON</TD>
<TD CLASS="RIGHT">ON</TD>
</TR>
<TR><TD CLASS="LEFT">largepatches</TD>
<TD CLASS="RIGHT">256</TD>
<TD CLASS="RIGHT">256</TD>
<TD CLASS="RIGHT">256</TD>
</TR>
<TR><TD CLASS="LEFT">largesize</TD>
<TD CLASS="RIGHT">50000000</TD>
<TD CLASS="RIGHT">800000000</TD>
<TD CLASS="RIGHT">1500000000</TD>
</TR>
<TR><TD CLASS="LEFT">maxnumbersize</TD>
<TD CLASS="RIGHT">200</TD>
<TD CLASS="RIGHT">200</TD>
<TD CLASS="RIGHT">200</TD>
</TR>
<TR><TD CLASS="LEFT">maxtermsize</TD>
<TD CLASS="RIGHT">10000</TD>
<TD CLASS="RIGHT">40000</TD>
<TD CLASS="RIGHT">40000</TD>
</TR>
<TR><TD CLASS="LEFT">maxwildcards</TD>
<TD CLASS="RIGHT">100</TD>
<TD CLASS="RIGHT">100</TD>
<TD CLASS="RIGHT">100</TD>
</TR>
<TR><TD CLASS="LEFT">nospacesinnumbers</TD>
<TD CLASS="RIGHT">OFF</TD>
<TD CLASS="RIGHT">OFF</TD>
<TD CLASS="RIGHT">OFF</TD>
</TR>
<TR><TD CLASS="LEFT">numstorecaches</TD>
<TD CLASS="RIGHT">4</TD>
<TD CLASS="RIGHT">4</TD>
<TD CLASS="RIGHT">4</TD>
</TR>
<TR><TD CLASS="LEFT">nwritefinalstatistics</TD>
<TD CLASS="RIGHT">OFF</TD>
<TD CLASS="RIGHT">OFF</TD>
<TD CLASS="RIGHT">OFF</TD>
</TR>
<TR><TD CLASS="LEFT">nwritestatistics</TD>
<TD CLASS="RIGHT">OFF</TD>
<TD CLASS="RIGHT">OFF</TD>
<TD CLASS="RIGHT">OFF</TD>
</TR>
<TR><TD CLASS="LEFT">nwritethreadstatistics</TD>
<TD CLASS="RIGHT">OFF</TD>
<TD CLASS="RIGHT">OFF</TD>
<TD CLASS="RIGHT">OFF</TD>
</TR>
<TR><TD CLASS="LEFT">oldorder</TD>
<TD CLASS="RIGHT">OFF</TD>
<TD CLASS="RIGHT">OFF</TD>
<TD CLASS="RIGHT">OFF</TD>
</TR>
<TR><TD CLASS="LEFT">parentheses</TD>
<TD CLASS="RIGHT">100</TD>
<TD CLASS="RIGHT">100</TD>
<TD CLASS="RIGHT">100</TD>
</TR>
<TR><TD CLASS="LEFT">path</TD>
<TD CLASS="RIGHT">.</TD>
<TD CLASS="RIGHT">.</TD>
<TD CLASS="RIGHT">.</TD>
</TR>
<TR><TD CLASS="LEFT">processbucketsize</TD>
<TD CLASS="RIGHT">1000</TD>
<TD CLASS="RIGHT">1000</TD>
<TD CLASS="RIGHT">1000</TD>
</TR>
<TR><TD CLASS="LEFT">scratchsize</TD>
<TD CLASS="RIGHT">50000000</TD>
<TD CLASS="RIGHT">500000000</TD>
<TD CLASS="RIGHT">500000000</TD>
</TR>
<TR><TD CLASS="LEFT">sizestorecache</TD>
<TD CLASS="RIGHT">32768</TD>
<TD CLASS="RIGHT">32768</TD>
<TD CLASS="RIGHT">32768</TD>
</TR>
<TR><TD CLASS="LEFT">smallextension</TD>
<TD CLASS="RIGHT">20000000</TD>
<TD CLASS="RIGHT">300000000</TD>
<TD CLASS="RIGHT">600000000</TD>
</TR>
<TR><TD CLASS="LEFT">smallsize</TD>
<TD CLASS="RIGHT">10000000</TD>
<TD CLASS="RIGHT">150000000</TD>
<TD CLASS="RIGHT">300000000</TD>
</TR>
<TR><TD CLASS="LEFT">sortiosize</TD>
<TD CLASS="RIGHT">100000</TD>
<TD CLASS="RIGHT">100000</TD>
<TD CLASS="RIGHT">100000</TD>
</TR>
<TR><TD CLASS="LEFT">sorttype</TD>
<TD CLASS="RIGHT">lowfirst</TD>
<TD CLASS="RIGHT">lowfirst</TD>
<TD CLASS="RIGHT">lowfirst</TD>
</TR>
<TR><TD CLASS="LEFT">subfilepatches</TD>
<TD CLASS="RIGHT">64</TD>
<TD CLASS="RIGHT">64</TD>
<TD CLASS="RIGHT">64</TD>
</TR>
<TR><TD CLASS="LEFT">sublargepatches</TD>
<TD CLASS="RIGHT">64</TD>
<TD CLASS="RIGHT">64</TD>
<TD CLASS="RIGHT">64</TD>
</TR>
<TR><TD CLASS="LEFT">sublargesize</TD>
<TD CLASS="RIGHT">4000000</TD>
<TD CLASS="RIGHT">4000000</TD>
<TD CLASS="RIGHT">4000000</TD>
</TR>
<TR><TD CLASS="LEFT">subsmallextension</TD>
<TD CLASS="RIGHT">800000</TD>
<TD CLASS="RIGHT">800000</TD>
<TD CLASS="RIGHT">800000</TD>
</TR>
<TR><TD CLASS="LEFT">subsmallsize</TD>
<TD CLASS="RIGHT">500000</TD>
<TD CLASS="RIGHT">500000</TD>
<TD CLASS="RIGHT">500000</TD>
</TR>
<TR><TD CLASS="LEFT">subsortiosize</TD>
<TD CLASS="RIGHT">32768</TD>
<TD CLASS="RIGHT">32768</TD>
<TD CLASS="RIGHT">32768</TD>
</TR>
<TR><TD CLASS="LEFT">subtermsinsmall</TD>
<TD CLASS="RIGHT">10000</TD>
<TD CLASS="RIGHT">10000</TD>
<TD CLASS="RIGHT">10000</TD>
</TR>
<TR><TD CLASS="LEFT">tempdir</TD>
<TD CLASS="RIGHT">.</TD>
<TD CLASS="RIGHT">.</TD>
<TD CLASS="RIGHT">.</TD>
</TR>
<TR><TD CLASS="LEFT">tempsortdir</TD>
<TD CLASS="RIGHT">.</TD>
<TD CLASS="RIGHT">.</TD>
<TD CLASS="RIGHT">.</TD>
</TR>
<TR><TD CLASS="LEFT">termsinsmall</TD>
<TD CLASS="RIGHT">100000</TD>
<TD CLASS="RIGHT">2000000</TD>
<TD CLASS="RIGHT">3000000</TD>
</TR>
<TR><TD CLASS="LEFT">threadbucketsize</TD>
<TD CLASS="RIGHT">500</TD>
<TD CLASS="RIGHT">500</TD>
<TD CLASS="RIGHT">500</TD>
</TR>
<TR><TD CLASS="LEFT">threadloadbalancing</TD>
<TD CLASS="RIGHT">ON</TD>
<TD CLASS="RIGHT">ON</TD>
<TD CLASS="RIGHT">ON</TD>
</TR>
<TR><TD CLASS="LEFT">threads</TD>
<TD CLASS="RIGHT">0</TD>
<TD CLASS="RIGHT">0</TD>
<TD CLASS="RIGHT">0</TD>
</TR>
<TR><TD CLASS="LEFT">threadsortfilesynch</TD>
<TD CLASS="RIGHT">OFF</TD>
<TD CLASS="RIGHT">OFF</TD>
<TD CLASS="RIGHT">OFF</TD>
</TR>
<TR><TD CLASS="LEFT">threadscratchoutsize</TD>
<TD CLASS="RIGHT">2500000</TD>
<TD CLASS="RIGHT">2500000</TD>
<TD CLASS="RIGHT">2500000</TD>
</TR>
<TR><TD CLASS="LEFT">threadscratchsize</TD>
<TD CLASS="RIGHT">100000</TD>
<TD CLASS="RIGHT">100000</TD>
<TD CLASS="RIGHT">100000</TD>
</TR>
<TR><TD CLASS="LEFT">workspace</TD>
<TD CLASS="RIGHT">10000000</TD>
<TD CLASS="RIGHT">40000000</TD>
<TD CLASS="RIGHT">40000000</TD>
</TR>
</TABLE>
</DIV>
If one compares these numbers with the corresponding numbers for older 
versions one will notice that here we assume that the standard computer 
will have much more memory available than in the `old time'. Basically we 
expect that a serious FORM user has at least 64 Mbytes available. If it is 
considerably less one should define a setup file with smaller settings.

<P>
More recently a new notation for large numbers has been allowed. One can 
use the characters K, M, G and T to indicate kilo (three zeroes), mega (6 
zeroes), giga (9 zeroes) and tera (12 zeros) as in 10M for 10000000.

<P>
To find out what the setup values are, one can use the `ON,setup;' 
statement (<A HREF="#substaon">7.107</A>).

<P>
In version 3.3 and later one may use environment<A NAME="17184"></A> 
variables for the values of the setup parameters, either in the setup file 
or at the beginning of the .frm file. The environment variable is used as a 
preprocessor variable in the sense that its name is enclosed in a 
backquote-quote pair as in <code>`VARNAME'</code>. The variable will be looked 
for and if found it will be substituted. This can however not be done in a 
recursive way, because the regular routines that take care of the 
preprocessor variables are not active yet when the setups are read.

<P>

<H1><A ID="SECTION001900000000000000000"></A>
<A ID="parallel"></A>
<BR>
The parallel version
</H1>

<P>
FORM has two versions that can make use of several processors 
simultaneously. Which version can be used profitably depends very much on 
the architecture of the computer one is using. Each version has its own 
control commands which are ignored by the other version and the sequential 
version of FORM. The parallel versions are:

<UL>
<LI>P<SMALL>AR</SMALL>FORM<A NAME="18143"></A>: This version runs on processors that have 
their own memory and preferably their own disk. Each processor gets a copy 
of the complete program and MPI<A NAME="18144"></A> is used for the 
communication<A NAME="18145"></A>. When the network connections are very 
fast one can also use P<SMALL>AR</SMALL>FORM on computer clusters. P<SMALL>AR</SMALL>FORM was 
developed at the university of Karlsruhe<A NAME="18146"></A>.
</LI>
<LI>TFORM<A NAME="18147"></A>: This version uses POSIX threads and runs on computers 
which have several processors with a shared memory. Data is kept as common 
data as much as possible and only when a worker thread gets a task a 
minimal amount of data is copied to its private buffers. Currently it seems 
to perform best on computers with two or four processors.
</LI>
</UL>
Both P<SMALL>AR</SMALL>FORM and TFORM suffer from the same bottlenecks<A NAME="18149"></A>. 
At the beginning of a module there is a single expression, managed by a 
master process which then has to distribute the terms over the workers. At 
the end of the module the sorted results of the workers have to be gathered 
in by the master<A NAME="18150"></A> and merged into a single expression again. 
Efficiency depends critically on how fast the terms can be given to the 
workers<A NAME="18151"></A>, how well the load for the workers is balanced and 
how much time the master has to spend in the final stages of the sorting. 
Another factor is the complexity of the operations inside the module. If 
the module has very few and simple statements, the gain in performance will 
be much less than when the module has much work to do for each term.

<P>
The P<SMALL>AR</SMALL>FORM and TFORM specific code is internally completely separated. 
This offers the possibility that sooner or later the two can be combined to 
allow efficient running on clusters of dual or quad processor machines. 
Whether this would give significant extra benefits needs to be 
investigated. When this project will be undertaken depends very much on the 
availability of such computers.

<P>
Because P<SMALL>AR</SMALL>FORM uses MPI<A NAME="18153"></A> and because different MPI 
environments are normally not binary compatible, the port to a new machine 
requires a recompilation of the source code and a relinking to the MPI 
library. Hence we do not have executables in the distribution site.
One needs to build P<SMALL>AR</SMALL>FORM on one's computer.
For TFORM the situation is much more favorable. Its treatment of the 
parallelization follows the standard for POSIX<A NAME="18155"></A> threads (or 
PThreads) for which the libraries are implemented on almost any 
UNIX<A NAME="18156"></A> system and many other systems.

<P>
The ideal of a parallel version of FORM is that it should execute nearly 
any regular FORM program, whether it was written for parallelization or 
not. And it should execute much faster on several processors than the 
sequential version on a single processor. The performance is given by the 
improvement factor which is the execution time of the sequential version 
divided by the execution time of the parallel version as measured in real 
time (not CPU time) on a computer that has no other major tasks. The ideal 
would of course be that a computer with N processors would give an 
improvement factor of N. It should be easy to see that this ideal cannot be 
reached, due to the bottlenecks described above. Also the compilation takes 
place on a single processor and the instructions of the preprocessor are 
typically also tasks for a single thread/processor. Yet for small numbers 
of processors one can do rather well. Many old calculations, when repeated 
with TFORM would give improvement<A NAME="18157"></A> factors above 
1.7 on a dual pentium<A NAME="18158"></A> machine and around 3 or a bit higher 
on a quad opteron<A NAME="18159"></A> machine. This was without modifying even a 
single statement in the programs. Of course these numbers depend very much 
on the type of the problem and the programming style used. As of yet there 
is very little experience with parallel versions of FORM. Hence people will 
have to discover what are good ways of getting the most out of their 
computer. It is expected that there will be much progress in the coming 
years.

<P>
First we will now discuss the running of the two versions. After that we 
will describe some common syntactic problems.

<P>

<H1><A ID="SECTION001910000000000000000"></A>
<A ID="tform"></A>
<BR>
TFORM
</H1>

<P>
Let us assume that the executable of TFORM<A NAME="18162"></A> is called tform. It 
is used exactly the same way as the sequential version of FORM (named form) 
is used with the exception of the possibility to specify the number of 
worker<A NAME="18163"></A> threads with the -w option. The command
<PRE>
    tform -w4 calcdia
</PRE>
would execute the program in the file calcdia.frm, using 4 worker threads, 
in addition to the one master thread. When the -w option is not given or 
when only one worker thread is asked for, tform will run the whole program 
inside the master<A NAME="18166"></A> thread. Because tform always has some 
overhead this is usually a little bit slower than using form. Strange 
enough there are exceptions although this may have to do with the fact that 
measuring the time of a program doesn't always give the same numbers.

<P>
It is also possible to specify the number of worker threads in the setup 
file, using the line
<PRE>
    Threads 4
</PRE>
for 4 threads. And as with all setup parameters one can pass this 
information also via the environment variable FORM_threads or with the line
<PRE>
    #: Threads 4
</PRE>
at the beginning of the program file.

<P>
When the master passes terms to the workers, it has to signal<A NAME="18171"></A> 
the workers that there is some data. In their turn, each worker has to send 
the master a signal when it has completed its task and it is ready for 
more. Such signals cost time. Hence it is usually best to send terms in 
groups, called buckets<A NAME="18172"></A>. The optimal number of terms in a 
bucket depends very much on the problem and the size of the expression. 
Bigger buckets mean less overhead in signals. If the buckets are too big 
the workers may have to wait too much. Values between 100 and 1000 are 
usually rather good. There is a default bucket size which is typically 
around 500. The user can change this value in two ways: The first is with 
the ThreadBucketSize<A NAME="18173"></A> setup parameter in the 
form.set file (or at the startup of the program file, or with the 
FORM_threadbucketsize environment variable) and the second is with the 
ThreadBucketSize statement (see <A HREF="#substathreadbucketsize">7.147</A>) which is a 
declaration like Symbol or Dimension. The first terms in an expression will 
be sent in smaller buckets to get the workers something to do as soon as 
possible.

<P>
Usually the bigger buckets give a better performance, but they suffer from 
a nasty side-effect. Complicated terms that need much execution time have a 
tendency to stick together. Hence there can be one bucket with most of the 
difficult terms and at the end of the module all workers and the master 
have to wait for one worker to finish. This can be improved with a 
load<A NAME="18175"></A> balancing mechanism. The current version will 
take terms from the buckets of workers that take more time than the others. 
By default this mechanism is on, but it can be switched on or off with the 
`on ThreadLoadBalancing<A NAME="18176"></A>;' and `off 
ThreadLoadBalancing;' statements. It can also be set as one of the setup 
parameters in the form.set file with
<PRE>
    ThreadLoadBalancing OFF
</PRE>
or
<PRE>
    ThreadLoadBalancing ON
</PRE>
or at the start of the program or in the environment.

<P>
The LINUX<A NAME="18181"></A> operating system tries to cache<A NAME="18182"></A> files 
that are to be written to disk. Somehow, when several big files have to be 
written it gets all confused (it is not known in what way). This means that 
if tform produces 4 large sort files<A NAME="18183"></A> eventually the system 
becomes intolerably slow. At one time a test program was 4.5 times slower 
with 4 worker processors than with just the master running, even though the 
master had a single even bigger sort file. This has been improved by having 
the file-to-file sort of the threads changed into a 
file-to-masterbuffers-to-combined-output. Yet the writing and subsequent 
merging of the 4 files at the same time can be disastrous. Work is done to 
improve this, but it may not be easy to circumvent facilities of the 
operating system. Apparently the quality of the drivers is crucial here. 

<P>
One can switch the parallel processing on or off (for the complete module) 
at any moment in the program with the 
statements<A NAME="18184"></A><A NAME="18185"></A>
<PRE>
    On Threads;
    Off Threads;
</PRE>
or using the moduleoption statement (<A HREF="#substamoduleoption">7.89</A>) that
affects TFORM's behaviour for just the current module:
<PRE>
    ModuleOption Parallel;
    ModuleOption NoParallel;
</PRE>
Additionally one can switch the statistics per thread on or off with
<PRE>
    On ThreadStats;
    Off ThreadStats;
</PRE>
When the thread<A NAME="18194"></A><A NAME="18195"></A> statistics are 
switched off only the statistics of the master thread are printed which is 
usually only the final statistics for each of the expressions.

<P>
The timing information in the statistics is the CPU<A NAME="18196"></A> time 
spent by the thread that prints the statistics. Hence the total CPU time 
spent is the sum of the time of all workers and the time of the master. In 
good running the time of the master should be the smallest number. When the 
statistics per thread are switched off, only the statistics of the master 
process will be printed with this `small' number. Hence it may look like 
the program isn't progressing very much.

<P>
For debugging purposes the term by term print<A NAME="18197"></A> statement (see 
<A HREF="#substaprint">7.113</A>) is equipped with the <code>%W</code> and <code>%w</code> format 
strings. The first will cause the printing of the number of the current 
thread and the CPU-time used thus far in that thread. The second will only 
print the number of the current thread. The thread with the number zero is 
the master thread. Putting a statement like
<PRE>
    Print +f "&lt;%W&gt; %t";
</PRE>
would show which thread is processing which term and when.

<P>
These are all the commands that specifically concern TFORM. When more 
experience is gained using TFORM, more parameters and commands may become 
available.

<P>
The fact that the threads need private<A NAME="18201"></A> data makes that TFORM 
will use more memory than FORM. Most of the buffers are not very large, but 
of course there are some buffers which need to be large, like the sort 
buffers and the scratch input<A NAME="18202"></A>/hide<A NAME="18203"></A> buffers. The 
sizes that the user specifies for these buffers are for the corresponding 
buffers of the master. The workers get each 1/N times the size for these 
buffers, when there are N workers. In the case that makes these buffers too 
small because of for instance MaxTermSize, the buffers may become larger.

<P>

<H1><A ID="SECTION001920000000000000000"></A>
<A ID="parform"></A>
<BR>
ParFORM
</H1>

<P>
Let us call the executable of P<SMALL>AR</SMALL>FORM<A NAME="18206"></A> parform.
The user must execute parform as an MPI<A NAME="18207"></A> application.
In many MPI implementations, this is done by using the mpirun<A NAME="18208"></A>
command:
<PRE>
    mpirun -np 4 parform calcdia
</PRE>
This example executes the program in the file calcdia.frm, using 4 
processes,in which one process is the master process and the other 3 
processes are the worker processes.
One has to keep in mind that in some MPI implementations environment 
variables will not be passed to an MPI application. Alternatively extra 
options are needed for passing them.
If one wants to run P<SMALL>AR</SMALL>FORM under a job scheduler on a computer cluster
environment, one may need to write a job script, which depends to a great 
extent on the environment.

<P>
P<SMALL>AR</SMALL>FORM uses MPI for communications between the master and workers. 
Actually terms are distributed by using point-to-point send/receive 
operations of MPI. Since there is some latency for establishing a 
connection between processes, especially between those running on different 
computers, it is best to send terms in groups, like buckets in TFORM. 
The default number of terms in a bucket is currently 1000 in P<SMALL>AR</SMALL>FORM. It 
can be changed with the ProcessBucketSize statement 
(<A HREF="#substaprocessbucketsize">7.116</A><A NAME="18216"></A>) if this is deemed 
necessary. It can also be changed for the current module with the statement 
(<A HREF="#substamoduleoption">7.89</A><A NAME="18218"></A>).
<PRE>
    ModuleOption ProcessBucketSize number;
</PRE>
And finally it can also be changed in the setup, using the 
ProcessBucketSize (<A HREF="#setupprocessbucketsize">17</A>) setup parameter.
The first terms in an expression will be sent in smaller buckets to get the 
workers something to do as soon as possible.

<P>
One can switch the parallel processing on or off (for the complete module) 
at any moment in the program with the statements<A NAME="18222"></A><A NAME="18223"></A>
<PRE>
    On Parallel;
    Off Parallel;
</PRE>
or using the moduleoption statement (<A HREF="#substamoduleoption">7.89</A>) that
affects P<SMALL>AR</SMALL>FORM's behaviour for just the current module:
<PRE>
    ModuleOption Parallel;
    ModuleOption NoParallel;
</PRE>
Additionally one can switch the statistics per process on or off with
<PRE>
    On ProcessStats;
    Off ProcessStats;
</PRE>
When the process<A NAME="18232"></A><A NAME="18233"></A> statistics 
are switched off only the statistics of the master process are printed 
which are usually only the final statistics for each of the expressions.

<P>
As in TFORM, <code>%W</code> and <code>%w</code> in the term by term 
print<A NAME="18235"></A> statement (see <A HREF="#substaprint">7.113</A>) are available in 
P<SMALL>AR</SMALL>FORM. They print the number of the current process and the 
CPU-time used thus far in that process.

<P>
In principle one can run all FORM or TFORM programs with P<SMALL>AR</SMALL>FORM.
In practice P<SMALL>AR</SMALL>FORM is not so efficient for some problems, in which
more data have to be synchronized between the master and the workers.
The cases for which P<SMALL>AR</SMALL>FORM needs to send data via MPI include:

<UL>
<LI>The redefine statements, which modify preprocessor variables
        on the workers.
</LI>
<LI>Modifying $-variables in regular statements with a moduleoption
        statement (see <A HREF="#pardollars">6.1</A>, <A HREF="#substamoduleoption">7.89</A>
        and&nbsp;<A HREF="#dollars-in-parallel">18.3</A>).
</LI>
<LI>Expression names appearing in right hand sides of definition or
        substitution statements.
</LI>
</UL>
The last case may need more explanation.
Consider the following code:
<PRE>
    Local G = F;
    id a = F;
</PRE>
where the expression F is supposed to be already defined. The point is that 
these substitutions of the expression F are performed on the workers. The 
workers, however, do not know the contents of the expression F because it 
is stored on the master. Therefore, before executing this module P<SMALL>AR</SMALL>FORM 
needs to make the master broadcast the expression F to the workers. This 
may be quite time-consuming because the expression could be very large.

<P>

<H1><A ID="SECTION001930000000000000000"></A>
<A ID="dollars-in-parallel"></A>
<BR>
Some problems
</H1>

<P>
Both parallel versions share a number of problems which are inherent to 
running in an environment in which the order<A NAME="18253"></A> in which 
terms are processed isn't deterministic<A NAME="18254"></A>. Most of these 
problems concern <code>$</code>-variables. They present a mix between private and 
common information. Consider the code
<PRE>
    id  f(x?$xvar) = g(x);
    id  ......
    id  a^n? = b^n*h($var);
</PRE>
Of course one could do this simple example differently, but we are 
discussing the principle. What we have here is that each term that passes 
the first statement will acquire its own value of <code>$var</code>, to be used a 
bit later. It is clear that if we have a common administration of 
<code>$</code>-variables we would have to `lock'<A NAME="18257"></A> the value for a 
considerable amount of time, thereby spoiling much of the gains of parallel 
processing. Hence in this case it would be best that each worker maintains 
its own local value of <code>$var</code>. But in the following example we have 
the opposite:
<PRE>
    #$xmax = -1;
    if ( count(x,1) &gt; $xmax ) $xmax = count_(x,1);
</PRE>
Here we collect a maximum power in the variable <code>$xmax</code>. If each 
worker would have a local value of <code>$xmax</code>, the question is what to do 
with all these local values at the end of the module. A human will see that 
here we are collecting a maximum, but the computer cannot and should not 
see this. Hence the general rule in parallel processing is that when there 
are <code>$</code>-variables<A NAME="18260"></A> obtaining a value during the 
algebraic phase of a module the entire module is run sequentially, unless 
FORM has been helped with a moduleoption statement for each of the 
variables involved. Hence in the last example
<PRE>
    ModuleOption Maximum $xmax;
</PRE>
would tell FORM how to combine the local values in P<SMALL>AR</SMALL>FORM (P<SMALL>AR</SMALL>FORM 
maintains local values of all <code>$</code>-variables). In TFORM it 
would put the value directly into the central administration, provided it 
is bigger than the previous value. Only during the update the variable 
would have to be locked.

<P>
There are several options in the moduleoption statement:

<UL>
<LI>Maximum<A NAME="18264"></A>: The variable must have a 
numerical value and the maximum is collected.
</LI>
<LI>Minimum<A NAME="18265"></A>: The variable must have a 
numerical value and the minimum is collected.
</LI>
<LI>Sum<A NAME="18266"></A>: The variable must have a numerical value 
and the sum is collected.
</LI>
<LI>Local<A NAME="18267"></A>: The value will be kept privately and 
no attempt is made to put it in the central administration, neither during 
the execution of the module, nor at the end. If there was already a 
variable by this name in the central administration it will keep the value 
it had before the module started execution. At the end of the module, all 
private values will be forgotten.
</LI>
</UL>

<P>
The redefine statement is a major inefficiency in a parallel environment. 
It redefines a preprocessor variable and there is only a single bookkeeping 
for such variables. This means that the variable has to be sent to the 
master process (P<SMALL>AR</SMALL>FORM) or that a lock has to be placed to prevent other 
workers to write to the same storage simultaneously (TFORM). In addition 
the final value in the preprocessor variable will be determined by the last 
term processed in any of the workers. This may not be the same term in 
different runs. It is up to the user to write programs that still give 
correct results under such conditions. The best way around the inefficiency 
is using <code>$</code>-variables and preprocessor instructions. We show this in 
an example in which we construct the equivalent of a conditional repeat 
that includes a .sort instruction.
<PRE>
    #do i = 1,1
      statements
      if ( count(x,1) &gt; 0 ) redefine i "0";
      .sort
    #enddo
</PRE>
To run this in parallel, it is better to use the following code.
<PRE>
    #do i = 1,1
      #$i = 1;
      statements
      if ( count(x,1) &gt; 0 ) $i = 0;
      ModuleOption minimum $i;
      .sort
      #redefine i "`$i'"
    #enddo
</PRE>
In this program the centrally stored value of <code>$i</code> is updated at most 
once. Admitedly it isn't as simple as the redefine statement, but it 
works in all versions of FORM starting with version 3.0.

<P>
It should be noted that when a new expression is defined in its defining 
module it starts out as a single term. Hence it cannot benefit from 
parallelization in that module. Therefore the code
<PRE>
    #define MAX "200"
    Symbols x0,...,x10;
    Local F = (x0+...+x`MAX')^3;
    id x1 = -x2-...-x`MAX';
    .end
</PRE>
will execute inside a single worker while
<PRE>
    #define MAX "200"
    Symbols x0,...,x10;
    Local F = (x0+...+x`MAX')^3;
    .sort
    id x1 = -x2-...-x`MAX';
    .end
</PRE>
will make the first expansion inside a single worker and the more costly 
substitution can be made in parallel. A better load<A NAME="18277"></A> 
balancing algorithm in which at any node in the expansion tree tasks can be 
given to idle workers would solve this problem, but due to some 
complications this has not yet been implemented. The structure of FORM will 
however allow such an implementation.

<P>

<H1><A ID="SECTION002000000000000000000"></A>
<A ID="externalcommunication"></A>
<BR>
External communication
</H1>

<P>
To communicate<A NAME="18385"></A> with other programs FORM is 
equipped with special commands. One set of commands is rather simple in 
nature: the #pipe<A NAME="18386"></A> (see section <A HREF="#prepipe">3.39</A>) and 
#system<A NAME="18388"></A> (see section <A HREF="#presystem">3.58</A>) instructions allow 
FORM to run programs in the regular command<A NAME="18390"></A> 
shell<A NAME="18391"></A>. Sometimes however much more sophistication is needed 
because these instructions have a rather large overhead and need to start 
new processes each time they are executed. Hence a second more extensive 
set of instructions was developed that allows the start of an external 
process<A NAME="18392"></A>, keep it open and maintain a two way 
communication<A NAME="18393"></A> with it. Similarly it is 
possible to start FORM in such a way from other programs. Many details of 
the method of implementation and a number of examples are given in a 
separate paper which can also found in the FORM site 
(http://www.nikhef.nl/<SPAN CLASS="MATH"><IMG STYLE="height: 1.06ex; vertical-align: -0.11ex; " SRC="img137.svg"
 ALT="$\sim$"></SPAN>form) under publications (look for the file 
extform.ps<A NAME="18394"></A> or extform.pdf<A NAME="18395"></A>). Here we 
will just show the essentials and the syntax.

<P>
The basic idea is to open (by means of the preprocessor) a number of 
external channels<A NAME="18396"></A> (there is no reason to be 
restricted to just one) by starting the corresponding program in a command 
shell. This program is kept running and a number is assigned to each 
channel. Next we can select a channel and communicate with it. To not run 
into syntactic problems, because the external program may have different 
ideas of what a formula should look like, one may have to install 
filters<A NAME="18397"></A>. These are additional programs that should be 
prepared before the FORM program is started that process the communication 
to convert from one notation to the other.

<P>

<H1><A ID="SECTION002010000000000000000"></A>
<A ID="external"></A>
<BR>
#external
</H1>

<P>
Syntax:

<P>
#external ["prevar"] systemcommand

<P>
See also

<P>
Starts<A NAME="18400"></A> the command in the background, 
connecting to its standard input and output. By default, the external 
command has no controlling terminal, the standard error stream is 
redirected to <code>/dev/null</code> and the command is run in a subshell in a 
new session and in a new process group (see the preprocessor instruction 
<code>#setexternalattr</code>).

<P>
The optional parameter &ldquo;prevar&rdquo; is the name of a preprocessor variable 
placed between double quotes. If it is present, the &ldquo;descriptor&rdquo; (small 
positive integer number) of the external command is stored into this 
variable and can be used for references to this external command (if there 
is more than one external command running simultaneously).

<P>
The external command that is started last becomes the &ldquo;current&rdquo; (active) 
external command.  All further instructions 
#fromexternal<A NAME="18401"></A> and #toexternal<A NAME="18402"></A> 
deal with the current external command.

<P>

<H1><A ID="SECTION002020000000000000000"></A>
<A ID="toexternalcommunication"></A>
<BR>
#toexternal
</H1>

<P>
Syntax:

<P>
#toexternal "formatstring" [,variables]

<P>
See also

<P>
Sends<A NAME="18405"></A> the output to the current 
external<A NAME="18406"></A> command. The semantics of the 
<code>"formatstring"</code> and the <code>[,variables]</code> is the same as for the 
#write<A NAME="18407"></A> instruction, except for the trailing end-of-line symbol. In 
contrast to the #write instruction, the #toexternal instruction does not 
append any newline<A NAME="18408"></A> symbol to the end of its output.

<P>

<H1><A ID="SECTION002030000000000000000"></A>
<A ID="fromexternalcommunication"></A>
<BR>
#fromexternal
</H1>

<P>
Syntax:

<P>
#fromexternal[<SPAN CLASS="MATH"><IMG STYLE="height: 1.75ex; vertical-align: -0.30ex; " SRC="img30.svg"
 ALT="$+-$"></SPAN>] ["[$]varname" [maxlength]]

<P>
Appends<A NAME="18411"></A> the output of the current 
external<A NAME="18412"></A> 
command to the FORM program. The semantics differ depending on the optional 
arguments. After the external command sends the prompt, FORM will continue 
with a next line after the line containing the #fromexternal instruction. 
The prompt string is not appended. The optional + or - sign after the name 
has influence on the listing of the content. The varieties are:

<P>
#fromexternal[<SPAN CLASS="MATH"><IMG STYLE="height: 1.75ex; vertical-align: -0.30ex; " SRC="img30.svg"
 ALT="$+-$"></SPAN>]

<P>
The semantics is similar to the #include<A NAME="18413"></A> 
instruction but folders<A NAME="18414"></A> are not supported. 

<P>
#fromexternal[<SPAN CLASS="MATH"><IMG STYLE="height: 1.75ex; vertical-align: -0.30ex; " SRC="img30.svg"
 ALT="$+-$"></SPAN>] "[$]varname"

<P>
is used to read the text from the running external command into 
the preprocessor variable varname, or into the dollar variable $varname if 
the name of the variable starts with the dollar sign &ldquo;$&rdquo;.

<P>
#fromexternal[<SPAN CLASS="MATH"><IMG STYLE="height: 1.75ex; vertical-align: -0.30ex; " SRC="img30.svg"
 ALT="$+-$"></SPAN>] "[$]varname" maxlength

<P>
is used to read the text from the running external command into 
the preprocessor (or dollar) variable varname. Only the first maxlength 
characters are stored.

<P>

<H1><A ID="SECTION002040000000000000000"></A>
<A ID="promptcommunication"></A>
<BR>
#prompt
</H1>

<P>
Syntax:

<P>
#prompt [newprompt]

<P>
Sets<A NAME="18417"></A> a new prompt for the current external 
command (if present) and all further (newly started) external commands.

<P>
If newprompt is an empty string, the default prompt (an empty line) will be 
used.

<P>
The prompt is a line consisting of a single prompt string. By default, this 
is an empty string.

<P>

<H1><A ID="SECTION002050000000000000000"></A>
<A ID="setexternalcommunication"></A>
<BR>
#setexternal
</H1>

<P>
Syntax:

<P>
#setexternal n

<P>
Sets the &ldquo;current&rdquo; external<A NAME="18420"></A> command. The 
instructions #toexternal<A NAME="18421"></A> and 
#fromexternal<A NAME="18422"></A> deal with the current external 
command.  The integer number n must be the descriptor of a running external 
command.

<P>

<H1><A ID="SECTION002060000000000000000"></A>
<A ID="rmexternalcommunication"></A>
<BR>
#rmexternal
</H1>

<P>
Syntax:

<P>
#rmexternal [n]

<P>
Terminates an external<A NAME="18425"></A> command. The integer 
number n must be either the descriptor of a running external command, or 0.

<P>
If n is 0, then all external programs will be terminated.

<P>
If n is not specified, the current external command will be terminated.

<P>
The action of this instruction depends on the attributes of the external 
channel (see the #setexternalattr<A NAME="18426"></A> (section 
<A HREF="#setexternalcommunication">19.5</A>) instruction). By default, the instruction 
closes the commands' IO channels, sends a KILL<A NAME="18428"></A> signal to 
every process in its process group and waits for the external command to be 
finished.

<P>

<H1><A ID="SECTION002070000000000000000"></A>
<A ID="setexternalattrcommunication"></A>
<BR>
#setexternalattr
</H1>

<P>
Syntax:

<P>
#setexternalattr list_of_attributes

<P>
sets<A NAME="18431"></A> attributes for <EM>newly started</EM> 
external commands. Already running external commands are not affected. The 
list of attributes is a comma separated list of pairs attribute=value, 
e.g.:
<PRE>
   #setexternalattr shell=noshell,kill=9,killall=false
</PRE>
Possible attributes are:
<DL>
<DT><STRONG>kill<A NAME="18436"></A></STRONG></DT>
<DD>Specifies which signal is to be sent to the external command either before 
the termination of the FORM program or by the preprocessor instruction 
#rmexternal<A NAME="18437"></A>. By default this is 9 
(SIGKILL<A NAME="18438"></A>). Number 0 means that no signal will be 
sent.
</DD>
<DT><STRONG>killall<A NAME="18439"></A></STRONG></DT>
<DD>Indicates whether the KILL<A NAME="18440"></A> 
signal will be sent to the whole group or only to the initial process. 
Possible values are &ldquo;<code>true</code>&rdquo; and &ldquo;<code>false</code>&rdquo;. By default, the 
kill signal will be sent to the whole group.
</DD>
<DT><STRONG>daemon<A NAME="18441"></A></STRONG></DT>
<DD>Indicates whether the command should be &ldquo;daemonized&rdquo;, i.e. 
the initial process will be passed to the init process and will belong
to the new process group in the new session.  
Possible values are &ldquo;<code>true</code>&rdquo; and &ldquo;<code>false</code>&rdquo;. By default, 
&ldquo;<code>true</code>&rdquo;.
</DD>
<DT><STRONG>shell<A NAME="18442"></A></STRONG></DT>
<DD>specifies which shell<A NAME="18443"></A> is used to run a command. (Starting an 
external command in a subshell permits to start not only executable files 
but also scripts and pipelined jobs. The disadvantage is that there is no 
way to detect failure upon startup since usually the shell is started 
successfully.) By default this is &ldquo;<code>/bin/sh -c</code>&rdquo;.  If set 
<code>shell=noshell</code>, the command will be started by the instruction 
#external<A NAME="18444"></A> directly but not in a subshell, so the command 
should be a name of the executable file rather than a system command. The 
instruction #external will duplicate the actions of the shell in searching 
for an executable file if the specified file name does not contain a slash 
(/) character.  The search path<A NAME="18445"></A> is the path specified in 
the environment by the PATH<A NAME="18446"></A> variable.  If this variable isn't 
specified, the default path &ldquo;<code>:/bin:/usr/bin</code>&rdquo; is used.
</DD>
<DT><STRONG>stderr<A NAME="18447"></A></STRONG></DT>
<DD>specifies a file to redirect the standard error<A NAME="18448"></A> stream 
to. By default it is &ldquo;<code>/dev/null</code>&rdquo;. If set <code>stderr=terminal</code>,
no redirection occurs.
</DD>
</DL>
Only attributes that are explicitly mentioned are changed, all others remain 
unchanged. Note, changing attributes should be done with care. For example,
<PRE>
   #setexternalattr daemon=false
</PRE>
starts a command in the subshell within the current process group with
default attributes kill=9 and killall=true.
The instruction #rmexternal<A NAME="18452"></A> sends the
KILL<A NAME="18453"></A> signal to the whole group, which means that also 
FORM itself will be killed.

<P>

<H1><A ID="SECTION002080000000000000000">
An example</A>
</H1>

<P>
An example of the above instructions could be:
<PRE>
 1  symbol a,b;
 2
 3  #external "n1" cat -u
 4
 5  #external "n2" cat -u
 6
 7  *  cat simply repeats its input. The default prompt is an
 8  *  empty line. So we use "\n\n" here -- one "\n" is to finish
 9  *  the line, and the next "\n" is the prompt:
10  #toexternal "(a+b)^2\n\n"
11
12  #setexternal `n1'
13  *  For this channel the prompt will be "READY\n":
14  #toexternal "(a+b)^3\nREADY\n"
15
16  #setexternal `n2'
17  *  Set the default prompt:
18  #prompt
19  Local aPLUSbTO2=
20  #fromexternal
21         ;
22
23  #setexternal `n1'
24  #prompt READY
25  Local aPLUSbTO3=
26  #fromexternal
27         ;
28
29  #rmexternal `n1'
30  #rmexternal `n2'
31
32  Print;
33  .end
</PRE>

<P>
Two external channels are opened in lines 3 and 5. The UNIX<A NAME="18457"></A> 
utility &ldquo;<code>cat</code>&rdquo; simply repeats its input.
The option &ldquo;<code>-u</code>&rdquo; is used to prevent the output buffering. The 
option is ignored by the GNU<A NAME="18458"></A> <code>cat</code> utility but is mandatory 
for non-GNU versions of <code>cat</code>.

<P>
After line 5 the current external channel is `<code>n2</code>'. The default 
prompt is an empty line so in line 10 &ldquo;<code>\n\n</code>&rdquo; is used &ndash; 
one&ldquo;<code>\n</code>&rdquo; is to finish the line, and the next &ldquo;<code>\n</code>&rdquo; is the 
prompt.

<P>
Line 12 switches the current channel to `<code>n1</code>'. For this channel
the prompt will be &ldquo;<code>READY</code>&rdquo;, see line 24, hence the expression is
finished by &ldquo;<code>\nREADY\n</code>&rdquo;.

<P>
Line 16 switches to the `<code>n2</code>' external channel and line 18 sets
the default prompt (which is extra in this example since the default
prompt was not changed up to now).

<P>
Results (just a literal repetition of the sent expressions) are read
in lines 20 and 26.

<P>
Lines 29 and 30 close the external channels.

<P>

<H1><A ID="SECTION002090000000000000000"></A>
<A ID="embeddingcommunication"></A>
<BR>
Embedding FORM in other applications
</H1>

<P>
The external channel instructions permit FORM to swallow an external 
program. The same mechanism can be used in order to <EM>embed<A NAME="18461"></A></EM> FORM in other applications.

<P>
There is a possibility to start FORM from another program providing
one (or more) communication channels (see below). These channels will be 
visible from a FORM program as
&ldquo;pre-opened&rdquo;<A NAME="18462"></A> external channels 
existing after FORM starts. There is no need to open them with the 
#external<A NAME="18463"></A> instruction.
In this case, the preprocessor variable &ldquo;PIPES_&rdquo;<A NAME="18464"></A> is 
defined and is equal to the total number of the pre-opened external 
channels. Pre-opened external channel descriptors are contained in the 
preprocessor 
variables &ldquo;PIPE1_&rdquo;<A NAME="18465"></A>, &ldquo;PIPE2_&rdquo;<A NAME="18466"></A>, etc.
For example, if `PIPES_'<A NAME="18467"></A> is 3 then there are 3 
pre-opened external channels with the descriptors `PIPE1_',
`PIPE2_' and `PIPE3_' so e.g. the following instruction could
be used:
<PRE>
   #setexternal `PIPE2_'
</PRE>
without 
<PRE>
   #external "PIPE2_"
</PRE>

<P>
The external channel attributes make no sense for the pre-opened channel 
(see the #setexternalattr<A NAME="18472"></A> instruction (section 
<A HREF="#setexternalattrcommunication">19.7</A>)).
Formally, they are as follows:
<PRE>
   kill=0,
   killall=false,
   daemon=false,
   stderr=/dev/tty,
   shell=noshell
</PRE>

<P>
In order to activate the pre-opened external channels, the parent
application must follow some standards. Here we describe a low-level 
protocol<A NAME="18476"></A>, the corresponding 
C-interface<A NAME="18477"></A> is available from the FORM distribution site 
under packages and then externalchannels.

<P>
Before starting FORM, the parent application must create one or more pairs 
of pipes. A pipe<A NAME="18478"></A> is a pair of file descriptors, one is for 
reading and another is for writing. In LINUX<A NAME="18479"></A>, see &ldquo;man 2 
pipe&rdquo;. The read-only descriptor of the first pipe in the pair and the 
write-only descriptor of the second pipe must be passed to FORM as an 
argument of a command line option &ldquo;<code>-pipe</code>&rdquo; in ASCII decimal format. 
The argument of the option is a comma-separated list of pairs
&ldquo;<code>r#,w#</code>&rdquo; where &ldquo;<code>r#</code>&rdquo; is a read-only descriptor and 
&ldquo;<code>w#</code>&rdquo; is a write-only descriptor; alternatively, an environment 
variable FORM_PIPES<A NAME="18480"></A> containing this list can be used 
(the command line option overrides the environment variable). For example, 
to start FORM with two pre-opened external channels the parent application 
has to create first four pipes. Lets us suppose the first pipe was created 
with the descriptors 5 and 6, the second pipe has the descriptors 7 and 8, 
the third pipe has the descriptors 9 and 10 and the fourth pipe has the 
descriptors 11 and 12. The descriptors 5 and 8 will be used by FORM as the 
input and the output for the first pre-opened external channel while the 
descriptors 9 and 12 will be used by FORM as the input and the output for 
the second pre-opened external channel.

<P>
Then the parent application must start FORM with the following 
command line option:
<PRE>
   -pipe 5,8,9,12
</PRE>

<P>
Upon startup, FORM sends its PID<A NAME="18483"></A> (the Process Identifier) in 
ASCIIdecimal format with an appended newline character to the descriptor 8 
and then FORM will wait for the answer from the descriptor 5. The answer 
must be two comma-separated integers in ASCII decimal format followed by a 
newline character. The first integer corresponds to the FORM PID while the 
second one is the parent process PID. If the answer is not obtained after 
some timeout, or if it is not correct (i.e. it is not a list of two 
integers or the first integer is not the FORM PID) then FORM fails. If 
everything is correct, FORM creates the pre-opened channel and puts its 
descriptor in the preprocessor variable &ldquo;PIPE1_&rdquo;.

<P>
Then FORM processes the second pair of arguments, &ldquo;<code>9,12</code>&rdquo;.

<P>
After all pairs have been processed FORM creates the preprocessor variable 
&ldquo;PIPES_&rdquo; and puts into this variable the total number of created 
pre-opened external channels.

<P>
The order of processing the pairs of numbers in the argument is fixed 
exactly as it was described above i.e. from the left to the right.

<P>

<P>

<H1><A ID="SECTION002100000000000000000"></A>
<A ID="spectators"></A>
<BR>
Spectators
</H1>

<P>
At times expressions contain many terms that will not be treated for many 
modules to come. For the actions in those modules they are considered 
spectator terms. and they may consume much computer time due to their 
presence during the sorting. For this we have the spectator system in which 
we can send those terms to a special file, named a spectator file, in such 
a way that they can be picked up at a convenient time in the future. In 
short:

<P>
Spectators are expressions together with a <A NAME="18660"></A>filename. The 
file is for storage when the spectator becomes too big. Create a spectator 
with the statement<A NAME="18661"></A>
<PRE>
    CreateSpectator Exprname,"filename";
</PRE>
The file will be made in the same directory where the temporary files are made. 
Example:
<PRE>
    CreateSpectator Yintegrals,"Yfile.spec";
</PRE>
One may send terms to a spectator with the executable 
statement<A NAME="18666"></A>
<PRE>
    ToSpectator Exprname;
</PRE>
An example would be
<PRE>
    if ( count(Z,1) == 0 ) ToSpectator Yintegrals;
</PRE>
The terms are dumped into the file as they are at the moment the 
ToSpectator statement is executed. No brackets etc.
In the future they may be compressed. At the moment they are not.

<P>
Recovery of the contents of the spectator is done with the CopySpectator
statement as in<A NAME="18671"></A>
<PRE>
    CopySpectator NewExp = Yintegrals;
</PRE>
Currently you can only read the spectators this way. You cannot make more 
complicated constructions. You can only do things with the terms of the 
spectator expression after the contents have been put in your new 
expression. The spectator file remains in existence. In later modules you 
can still add to it. You cannot read from and add to the same spectator in 
the same module. The CopySpectator command can be followed by executable 
statements in the same module. This may not be economical because the 
contents of the spectator have not been sorted. There could be identical 
terms that occur many times or even cancel. Better sort them first.

<P>
A spectator can be removed from the system with the 
statement<A NAME="18674"></A>
<PRE>
    RemoveSpectator Yintegrals;
</PRE>
It is also possible to truncate a spectator down to zero length 
with<A NAME="18677"></A>
<PRE>
    EmptySpectator Yintegrals;
</PRE>
You can have as many spectators as you like, but they all have some cache 
buffers. There may also be limitations in the file system on the maximum 
number of open files. The filename for the spectator is purely for the sake 
of the users administration and recognition. You cannot carry the file over 
to other programs. There is no variable administration in it as in the 
saved files.

<P>
The .global instruction makes a spectator file survive a .store. It is up 
to the user to make sure that all the variables in it also survive the 
.store. There is no checking!

<P>
One use of the spectator system would be when integrating many different 
terms by means of a very prolonged recursion system in which integrals of a 
given complexity are reduced to integrals of lower complexity, but each 
such reduction may take quite a few steps. One could have:
<PRE>
    #do i = `MAXCOMPLEXITY'-1,0,-1
        CreateSpectator complex`i',"complex`i'.spec";
    #enddo
    Local F`MAXCOMPLEXITY' = ....;
    #do i = `MAXCOMPLEXITY'-1,1,-1
        #do ii = 1,1;
    *       routine for doing a part of the recursion level `i'
            ....

            #do j = `i'-1,0,-1
                if ( complexityofterm == `i' ) ToSpectator complex`i';
            #enddo
            if ( notyetfinished ) redefine ii "0";
            .sort
        #enddo
        Drop F{`i'+1};
        CopySpectator F`i' = complex`i';
        .sort
        RemoveSpectator complex`i';
    #enddo
    *
    * and finally, assuming that complexity zero means finished:
    *
    Drop F1;
    CopySpectator F0 = complex0;
    .sort
    RemoveSpectator complex0;
</PRE>
Some remarks are called for here. If one works with the 
polyratfun<A NAME="18682"></A> concept and the rational 
polynomials<A NAME="18683"></A> become rather complicated, the 
sorting after the CopySpectator statement can have serious bottleneck 
problems in <A NAME="18684"></A>TFORM and <A NAME="18686"></A>P<SMALL>AR</SMALL>FORM because the 
addition of those polynomials can be rather expensive and much of it ends 
up in the master processor. This can be made better with the following 
construction (assuming the function rat was declared as polyratfun at the 
moment of all the ToSpectator statements that wrote to the spectator):
<PRE>
    PolyRatFun;
    Drop F1;
    CopySpactator F0 = complex0;
    ABracket+ rat;
    .sort
    PolyRatFun rat;
    RemoveSpectator complex0;
    .sort
</PRE>
First we remove the declaration of rat as polyratfun. Then we read the 
spectator and sort it such that all terms that should be added eventually 
are grouped together. This sorting is very cheap as only identical terms 
are combined. Then we declare the polyratfun again and because of the way 
the terms are sorted nearly all additions take place inside the workers, 
hence at maximum parallelization efficiency.

<P>
The above method still contains one inefficiency: because the polyratfun is 
declared again, the contents of the rat function need to be 'normalized' 
again, while they were already normalized. This involves calculating a gcd 
of the numerator and the denominator, which is an expensive operation 
and is useless in this case. For this we have a special option in the 
polyratfun declaration:
<PRE>
   PolyRatFun rat-;
</PRE>
This will skip the normalization on the input of the module. One should 
note however that if one uses this option under different conditions in 
which the input rat function might not be normalized, the program might 
crash or even give wrong answers. Hence this option should only be used 
with the highest degree of caution! This is an option for very experienced 
users only. No support is given concerning programs that run correctly 
without the use of this option and fail when using it.

<P>
It should be noted that in the sequential version of FORM this 
construction is not needed at all, because there is only one processor 
anyway.

<P>

<H1><A ID="SECTION002200000000000000000"></A>
<A ID="diagrams"></A>
<BR>
Diagram generation
</H1>

<P>
For an accurate calculation of particle reactions a good, fast and flexible 
diagram generator is a necessity. It was noticed that the fastest available 
generator is the one by Toshiaki Kaneko, which was constructed for the 
Grace system. Hence he was asked whether he would be willing to provide a 
version that could be implemented into Form, thereby making intermediate 
files with diagrams superfluous. He gracefully accepted.

<P>
In the current version the diagram generator is not complete yet. 
Effectively it only accepts one type of scalar particles, but one can have 
any number of particles at the vertices. Hence it can be used as a fast 
topology generator. Because all source code is present and has been 
commented it will be possible to extend the user interface on demand.

<P>
The completion of the full diagram generator is planned for late-2018/ 
early-2019, depending on the availability of time. The source code of the 
generator is in C++, which makes it rather accesible from Form and possibly 
from other programs as well. For more information about that one should 
contact Prof. Toshiaki Kaneko directly.

<P>
The current interface is rather simple, due to the fact that one can 
generate only 'topologies'. First one needs two sets of vectors, one for 
the momenta of the external particles and one for the momenta of internal 
particles. The call is then with the function topologies_ as in
<PRE>
    Vectors Q1,Q2,p1,...,p8;
    Set QQ:Q1,Q2;
    Set PP:p1,...,p8;
    #define LOOPS "2"
    Local F = topologies_(`LOOPS',2,{3,},QQ,PP);
    Print +f +s;
    .end

   F =
       + node_(0,-Q1)*node_(1,-Q2)*node_(2,Q1,-p1,-p2)*node_(3,Q2,p1,-p3)*
      node_(4,p2,-p4,-p5)*node_(5,p3,p4,p5)
       + node_(0,-Q1)*node_(1,-Q2)*node_(2,Q1,-p1,-p2)*node_(3,p1,-p3,-p4)*
      node_(4,p2,p3,-p5)*node_(5,Q2,p4,p5)
      ;
</PRE>
Here the second parameter indicates the number of external legs, the third 
parameter is a set that tells, in this case, that 3-point vertices are 
allowed, QQ is the set of external momenta and PP is the set of internal 
momenta. The function node_ is a built-in function to indicate the 
vertices.

<P>
If one would like to allow more types of vertices one may change 
the third parameter:
<PRE>
    Vectors Q1,Q2,p1,...,p8;
    Set QQ:Q1,Q2;
    Set PP:p1,...,p8;
    #define LOOPS "2"
    Local F = topologies_(`LOOPS',2,{3,4},QQ,PP);
    Print +f +s;
    .end

   F =
       + node_(0,-Q1)*node_(1,-Q2)*node_(2,Q1,Q2,-p1,-p2)*node_(3,p1,p2,-p3,p3
      )
       + node_(0,-Q1)*node_(1,-Q2)*node_(2,Q1,-p1,-p2)*node_(3,Q2,p1,-p3)*
      node_(4,p2,p3,-p4,p4)
       + node_(0,-Q1)*node_(1,-Q2)*node_(2,Q1,-p1,-p2)*node_(3,Q2,p1,-p3)*
      node_(4,p2,-p4,-p5)*node_(5,p3,p4,p5)
       + node_(0,-Q1)*node_(1,-Q2)*node_(2,Q1,-p1,-p2)*node_(3,Q2,-p3,-p4)*
      node_(4,p1,p2,p3,p4)
       + node_(0,-Q1)*node_(1,-Q2)*node_(2,Q1,-p1,-p2)*node_(3,p1,-p3,-p4)*
      node_(4,Q2,p2,p3,p4)
       + node_(0,-Q1)*node_(1,-Q2)*node_(2,Q1,-p1,-p2)*node_(3,p1,-p3,-p4)*
      node_(4,p2,p3,-p5)*node_(5,Q2,p4,p5)
       + node_(0,-Q1)*node_(1,-Q2)*node_(2,Q1,-p1,-p2,-p3)*node_(3,Q2,p1,p2,p3
      )
       + node_(0,-Q1)*node_(1,-Q2)*node_(2,-p1,-p2,-p3)*node_(3,Q2,p1,-p4)*
      node_(4,Q1,p2,p3,p4)
       + node_(0,-Q1)*node_(1,-Q2)*node_(2,-p1,-p2,-p3)*node_(3,p1,p2,-p4)*
      node_(4,Q1,Q2,p3,p4)
      ;
</PRE>
and suddenly there are 9 topologies.

<P>
In the above configuration the program sees the external lines as 
different. If there is however a symmetry between the two external lines of 
a propagator-like diagram (as is the case with boson propagators) one can 
indicate this by putting a minus sign in front of the number 2:
<PRE>
    Vectors Q1,Q2,p1,...,p8;
    Set QQ:Q1,Q2;
    Set PP:p1,...,p8;
    #define LOOPS "2"
    Local F = topologies_(`LOOPS',-2,{3,4},QQ,PP);
    Print +f +s;
    .end

   F =
       + node_(0,-Q1)*node_(1,-Q2)*node_(2,Q1,Q2,-p1,-p2)*node_(3,p1,p2,-p3,p3
      )
       + node_(0,-Q1)*node_(1,-Q2)*node_(2,Q1,-p1,-p2)*node_(3,Q2,p1,-p3)*
      node_(4,p2,p3,-p4,p4)
       + node_(0,-Q1)*node_(1,-Q2)*node_(2,Q1,-p1,-p2)*node_(3,Q2,p1,-p3)*
      node_(4,p2,-p4,-p5)*node_(5,p3,p4,p5)
       + node_(0,-Q1)*node_(1,-Q2)*node_(2,Q1,-p1,-p2)*node_(3,Q2,-p3,-p4)*
      node_(4,p1,p2,p3,p4)
       + node_(0,-Q1)*node_(1,-Q2)*node_(2,Q1,-p1,-p2)*node_(3,Q2,-p3,-p4)*
      node_(4,p1,p3,-p5)*node_(5,p2,p4,p5)
       + node_(0,-Q1)*node_(1,-Q2)*node_(2,Q1,-p1,-p2)*node_(3,p1,-p3,-p4)*
      node_(4,Q2,p2,p3,p4)
       + node_(0,-Q1)*node_(1,-Q2)*node_(2,Q1,-p1,-p2,-p3)*node_(3,Q2,p1,p2,p3
      )
       + node_(0,-Q1)*node_(1,-Q2)*node_(2,-p1,-p2,-p3)*node_(3,p1,p2,-p4)*
      node_(4,Q1,Q2,p3,p4)
      ;
</PRE>
Now the program assumes this symmetry and one notices only 8 topologies 
remaining.

<P>
In the case of the topologies_ function there are no combinatorics 
factors. This will of course be different with the future function 
diagrams_.

<P>
That this function is very fast can be seen when one generates all 
topologies of a 6-loop propagator with only 3-point vertices:
<PRE>
    Vectors Q1,Q2,p1,...,p17;
    Set QQ:Q1,Q2;
    Set PP:p1,...,p17;
    #define LOOPS "6"
    Local F = topologies_(`LOOPS',-2,{3,},QQ,PP);
    .end

Time =       1.75 sec    Generated terms =       2793
               F         Terms in output =       2793
                         Bytes used      =     347156
</PRE>
or without the symmetry
<PRE>
    Vectors Q1,Q2,p1,...,p17;
    Set QQ:Q1,Q2;
    Set PP:p1,...,p17;
    #define LOOPS "6"
    Local F = topologies_(`LOOPS',2,{3,},QQ,PP);
    .end

Time =       0.63 sec    Generated terms =       4999
               F         Terms in output =       4999
                         Bytes used      =     616180
</PRE>
This is very much faster than the program that is used most widely.

<P>
To be continued.....

<P>
<BR>

<H2><A ID="SECTION002300000000000000000">
Index</A>
</H2><DL COMPACT>
<DT><STRONG>#$name</STRONG>
<DD><A HREF="#733">The preprocessor</A>
<DT><STRONG>#:</STRONG>
<DD><A HREF="#729">The preprocessor</A>
<DT><STRONG>#<SPAN CLASS="MATH"><IMG STYLE="height: 1.75ex; vertical-align: -0.30ex; " SRC="img6.svg"
 ALT="$-$"></SPAN></STRONG>
<DD><A HREF="#730">The preprocessor</A>
<DT><STRONG>#<SPAN CLASS="MATH"><IMG STYLE="height: 1.75ex; vertical-align: -0.30ex; " SRC="img7.svg"
 ALT="$+$"></SPAN></STRONG>
<DD><A HREF="#731">The preprocessor</A>
<DT><STRONG>#add</STRONG>
<DD><A HREF="#16354">Dictionaries</A>
<DT><STRONG>#addseparator</STRONG>
<DD><A HREF="#871">#addseparator</A>
<DT><STRONG>#append</STRONG>
<DD><A HREF="#880">#append</A>
 | <A HREF="#1431">#write</A>
<DT><STRONG>#break</STRONG>
<DD><A HREF="#892">#break</A>
 | <A HREF="#943">#case</A>
 | <A HREF="#984">#default</A>
 | <A HREF="#1382">#switch</A>
<DT><STRONG>#breakdo</STRONG>
<DD><A HREF="#902">#breakdo</A>
<DT><STRONG>#call</STRONG>
<DD><A HREF="#907">#call</A>
 | <A HREF="#914">#call</A>
 | <A HREF="#1003">#define</A>
 | <A HREF="#16147">open</A>
 | <A HREF="#17424">The setup</A>
 | <A HREF="#17615">The setup</A>
<DT><STRONG>#case</STRONG>
<DD><A HREF="#940">#case</A>
 | <A HREF="#941">#case</A>
 | <A HREF="#982">#default</A>
 | <A HREF="#1381">#switch</A>
<DT><STRONG>#close</STRONG>
<DD><A HREF="#954">#close</A>
<DT><STRONG>#closedictionary</STRONG>
<DD><A HREF="#16351">Dictionaries</A>
 | <A HREF="#16362">Dictionaries</A>
<DT><STRONG>#commentchar</STRONG>
<DD><A HREF="#964">#commentchar</A>
<DT><STRONG>#create</STRONG>
<DD><A HREF="#973">#create</A>
 | <A HREF="#1430">#write</A>
<DT><STRONG>#default</STRONG>
<DD><A HREF="#981">#default</A>
 | <A HREF="#1383">#switch</A>
<DT><STRONG>#define</STRONG>
<DD><A HREF="#928">#call</A>
 | <A HREF="#990">#define</A>
 | <A HREF="#993">#define</A>
 | <A HREF="#1273">#redefine</A>
<DT><STRONG>#do</STRONG>
<DD><A HREF="#862">The triple dot operator</A>
 | <A HREF="#1008">#do</A>
 | <A HREF="#1056">#enddo</A>
 | <A HREF="#1394">#switch</A>
 | <A HREF="#1418">#undefine</A>
 | <A HREF="#1465">Some remarks</A>
<DT><STRONG>#else</STRONG>
<DD><A HREF="#1035">#else</A>
 | <A HREF="#1047">#elseif</A>
 | <A HREF="#1122">#if</A>
<DT><STRONG>#elseif</STRONG>
<DD><A HREF="#1038">#else</A>
 | <A HREF="#1044">#elseif</A>
 | <A HREF="#1121">#if</A>
<DT><STRONG>#enddo</STRONG>
<DD><A HREF="#1010">#do</A>
 | <A HREF="#1053">#enddo</A>
 | <A HREF="#1466">Some remarks</A>
<DT><STRONG>#endif</STRONG>
<DD><A HREF="#1037">#else</A>
 | <A HREF="#1046">#elseif</A>
 | <A HREF="#1064">#endif</A>
 | <A HREF="#1120">#if</A>
 | <A HREF="#1472">Some remarks</A>
<DT><STRONG>#endinside</STRONG>
<DD><A HREF="#1071">#endinside</A>
<DT><STRONG>#endprocedure</STRONG>
<DD><A HREF="#1078">#endprocedure</A>
 | <A HREF="#1247">#procedure</A>
 | <A HREF="#1468">Some remarks</A>
<DT><STRONG>#endswitch</STRONG>
<DD><A HREF="#894">#break</A>
 | <A HREF="#944">#case</A>
 | <A HREF="#985">#default</A>
 | <A HREF="#1086">#endswitch</A>
 | <A HREF="#1384">#switch</A>
 | <A HREF="#1470">Some remarks</A>
<DT><STRONG>#exchange</STRONG>
<DD><A HREF="#1090">#exchange</A>
<DT><STRONG>#external</STRONG>
<DD><A HREF="#1095">#external</A>
 | <A HREF="#1334">#setexternalattr</A>
 | <A HREF="#18400">#external</A>
 | <A HREF="#18406">#toexternal</A>
 | <A HREF="#18412">#fromexternal</A>
 | <A HREF="#18444">#setexternalattr</A>
 | <A HREF="#18463">Embedding FORM in other</A>
<DT><STRONG>#factdollar</STRONG>
<DD><A HREF="#1106">#factdollar</A>
<DT><STRONG>#fromexternal</STRONG>
<DD><A HREF="#1100">#external</A>
 | <A HREF="#1109">#fromexternal</A>
 | <A HREF="#1318">#setexternal</A>
 | <A HREF="#18401">#external</A>
 | <A HREF="#18411">#fromexternal</A>
 | <A HREF="#18422">#setexternal</A>
<DT><STRONG>#if</STRONG>
<DD><A HREF="#1036">#else</A>
 | <A HREF="#1045">#elseif</A>
 | <A HREF="#1065">#endif</A>
 | <A HREF="#1119">#if</A>
 | <A HREF="#1178">#ifdef</A>
 | <A HREF="#1186">#ifndef</A>
 | <A HREF="#1393">#switch</A>
 | <A HREF="#1471">Some remarks</A>
<DT><STRONG>#ifdef</STRONG>
<DD><A HREF="#1066">#endif</A>
 | <A HREF="#1177">#ifdef</A>
<DT><STRONG>#ifndef</STRONG>
<DD><A HREF="#1067">#endif</A>
 | <A HREF="#1185">#ifndef</A>
<DT><STRONG>#include</STRONG>
<DD><A HREF="#1111">#fromexternal</A>
 | <A HREF="#1189">#include</A>
 | <A HREF="#1250">#procedure</A>
 | <A HREF="#1386">#switch</A>
 | <A HREF="#16054">The TableBase</A>
 | <A HREF="#16149">open</A>
 | <A HREF="#17423">The setup</A>
 | <A HREF="#17614">The setup</A>
 | <A HREF="#18413">#fromexternal</A>
<DT><STRONG>#inside</STRONG>
<DD><A HREF="#1072">#endinside</A>
 | <A HREF="#1204">#inside</A>
<DT><STRONG>#message</STRONG>
<DD><A HREF="#1208">#message</A>
<DT><STRONG>#name</STRONG>
<DD><A HREF="#732">The preprocessor</A>
<DT><STRONG>#opendictionary</STRONG>
<DD><A HREF="#16348">Dictionaries</A>
<DT><STRONG>#pipe</STRONG>
<DD><A HREF="#1222">#pipe</A>
 | <A HREF="#18386">External communication</A>
<DT><STRONG>#preout</STRONG>
<DD><A HREF="#1227">#preout</A>
<DT><STRONG>#printtimes</STRONG>
<DD><A HREF="#1236">#printtimes</A>
<DT><STRONG>#procedure</STRONG>
<DD><A HREF="#910">#call</A>
 | <A HREF="#915">#call</A>
 | <A HREF="#1243">#procedure</A>
 | <A HREF="#1467">Some remarks</A>
<DT><STRONG>#procedureExtension</STRONG>
<DD><A HREF="#931">#call</A>
 | <A HREF="#1254">#procedureextension</A>
 | <A HREF="#17634">The setup</A>
<DT><STRONG>#prompt</STRONG>
<DD><A HREF="#1264">#prompt</A>
 | <A HREF="#18417">#prompt</A>
<DT><STRONG>#redefine</STRONG>
<DD><A HREF="#995">#define</A>
 | <A HREF="#1270">#redefine</A>
<DT><STRONG>#remove</STRONG>
<DD><A HREF="#1280">#remove</A>
 | <A HREF="#1289">#remove</A>
<DT><STRONG>#rmexternal</STRONG>
<DD><A HREF="#1302">#rmexternal</A>
 | <A HREF="#1341">#setexternalattr</A>
 | <A HREF="#18425">#rmexternal</A>
 | <A HREF="#18437">#setexternalattr</A>
 | <A HREF="#18452">#setexternalattr</A>
<DT><STRONG>#rmseparator</STRONG>
<DD><A HREF="#1311">#rmseparator</A>
<DT><STRONG>#setexternal</STRONG>
<DD><A HREF="#1316">#setexternal</A>
 | <A HREF="#18420">#setexternal</A>
<DT><STRONG>#setexternalattr</STRONG>
<DD><A HREF="#1303">#rmexternal</A>
 | <A HREF="#1321">#setexternalattr</A>
 | <A HREF="#18426">#rmexternal</A>
 | <A HREF="#18431">#setexternalattr</A>
 | <A HREF="#18472">Embedding FORM in other</A>
<DT><STRONG>#setrandom</STRONG>
<DD><A HREF="#1347">#setrandom</A>
 | <A HREF="#14696">random_</A>
<DT><STRONG>#show</STRONG>
<DD><A HREF="#1353">#show</A>
<DT><STRONG>#switch</STRONG>
<DD><A HREF="#895">#break</A>
 | <A HREF="#942">#case</A>
 | <A HREF="#983">#default</A>
 | <A HREF="#1087">#endswitch</A>
 | <A HREF="#1377">#switch</A>
 | <A HREF="#1380">#switch</A>
 | <A HREF="#1469">Some remarks</A>
<DT><STRONG>#system</STRONG>
<DD><A HREF="#1288">#remove</A>
 | <A HREF="#1399">#system</A>
 | <A HREF="#18388">External communication</A>
<DT><STRONG>#terminate</STRONG>
<DD><A HREF="#1403">#terminate</A>
<DT><STRONG>#toexternal</STRONG>
<DD><A HREF="#1101">#external</A>
 | <A HREF="#1317">#setexternal</A>
 | <A HREF="#1410">#toexternal</A>
 | <A HREF="#18402">#external</A>
 | <A HREF="#18405">#toexternal</A>
 | <A HREF="#18421">#setexternal</A>
<DT><STRONG>#undefine</STRONG>
<DD><A HREF="#1416">#undefine</A>
<DT><STRONG>#usedictionary</STRONG>
<DD><A HREF="#16357">Dictionaries</A>
<DT><STRONG>#write</STRONG>
<DD><A HREF="#881">#append</A>
 | <A HREF="#956">#close</A>
 | <A HREF="#974">#create</A>
 | <A HREF="#1212">#message</A>
 | <A HREF="#1411">#toexternal</A>
 | <A HREF="#1428">#write</A>
 | <A HREF="#1457">#write</A>
 | <A HREF="#18407">#toexternal</A>
<DT><STRONG>$-variable</STRONG>
<DD><A HREF="#1092">#exchange</A>
 | <A HREF="#1441">#write</A>
 | <A HREF="#2804">Pattern matching</A>
 | <A HREF="#3857">endinside</A>
 | <A HREF="#4724">inside</A>
 | <A HREF="#8894">moduleoption</A>
 | <A HREF="#8910">moduleoption</A>
 | <A HREF="#8924">moduleoption</A>
 | <A HREF="#8938">moduleoption</A>
 | <A HREF="#5728">print</A>
 | <A HREF="#6065">redefine</A>
 | <A HREF="#6646">table</A>
 | <A HREF="#14473">factorin_</A>
 | <A HREF="#18260">Some problems</A>
<DT><STRONG>*...*</STRONG>
<DD><A HREF="#847">The triple dot operator</A>
<DT><STRONG>+...+</STRONG>
<DD><A HREF="#843">The triple dot operator</A>
<DT><STRONG>+...-</STRONG>
<DD><A HREF="#845">The triple dot operator</A>
<DT><STRONG>,...,</STRONG>
<DD><A HREF="#849">The triple dot operator</A>
<DT><STRONG>-...+</STRONG>
<DD><A HREF="#846">The triple dot operator</A>
<DT><STRONG>-...-</STRONG>
<DD><A HREF="#844">The triple dot operator</A>
<DT><STRONG>...</STRONG>
<DD><A HREF="#837">The triple dot operator</A>
<DT><STRONG>.clear</STRONG>
<DD><A HREF="#1260">#procedureextension</A>
 | <A HREF="#2597">Modules</A>
 | <A HREF="#17669">The setup</A>
<DT><STRONG>.end</STRONG>
<DD><A HREF="#2590">Modules</A>
<DT><STRONG>.global</STRONG>
<DD><A HREF="#2595">Modules</A>
<DT><STRONG>.prc</STRONG>
<DD><A HREF="#930">#call</A>
 | <A HREF="#1255">#procedureextension</A>
<DT><STRONG>.sav</STRONG>
<DD><A HREF="#6223">save</A>
<DT><STRONG>.sc1</STRONG>
<DD><A HREF="#17688">The setup</A>
<DT><STRONG>.sc2</STRONG>
<DD><A HREF="#17689">The setup</A>
<DT><STRONG>.sc3</STRONG>
<DD><A HREF="#17690">The setup</A>
<DT><STRONG>.sor extension</STRONG>
<DD><A HREF="#16820">Sorting and statistics</A>
<DT><STRONG>.sort</STRONG>
<DD><A HREF="#1024">#do</A>
 | <A HREF="#1460">#write</A>
 | <A HREF="#2588">Modules</A>
 | <A HREF="#2615">Modules</A>
 | <A HREF="#6062">redefine</A>
 | <A HREF="#6342">sort</A>
 | <A HREF="#6688">term</A>
<DT><STRONG>.store</STRONG>
<DD><A HREF="#2592">Modules</A>
 | <A HREF="#3603">delete</A>
 | <A HREF="#4337">global</A>
 | <A HREF="#4389">hide</A>
 | <A HREF="#4841">local</A>
 | <A HREF="#6219">save</A>
<DT><STRONG>.str</STRONG>
<DD><A HREF="#17706">The setup</A>
<DT><STRONG>.tbl</STRONG>
<DD><A HREF="#16079">The TableBase</A>
<DT><STRONG>/.../</STRONG>
<DD><A HREF="#848">The triple dot operator</A>
<DT><STRONG>32 bits</STRONG>
<DD><A HREF="#816">The preprocessor calculator</A>
 | <A HREF="#4096">fixindex</A>
 | <A HREF="#8501">if</A>
 | <A HREF="#6641">table</A>
 | <A HREF="#14571">maxpowerof_</A>
 | <A HREF="#16520">Dirac algebra</A>
 | <A HREF="#17330">The setup</A>
 | <A HREF="#17471">The setup</A>
 | <A HREF="#17489">The setup</A>
 | <A HREF="#16892">The setup</A>
<DT><STRONG>64  bits</STRONG>
<DD><A HREF="#16893">The setup</A>
<DT><STRONG>64 bits</STRONG>
<DD><A HREF="#819">The preprocessor calculator</A>
 | <A HREF="#4098">fixindex</A>
 | <A HREF="#8503">if</A>
 | <A HREF="#6643">table</A>
 | <A HREF="#14572">maxpowerof_</A>
 | <A HREF="#16522">Dirac algebra</A>
 | <A HREF="#17331">The setup</A>
 | <A HREF="#17472">The setup</A>
 | <A HREF="#17490">The setup</A>
<DT><STRONG>:...:</STRONG>
<DD><A HREF="#850">The triple dot operator</A>
<DT><STRONG>%</STRONG>
<DD><A HREF="#1439">#write</A>
<DT><STRONG>?name</STRONG>
<DD><A HREF="#2765">Pattern matching</A>
<DT><STRONG>aborted</STRONG>
<DD><A HREF="#3922">exit</A>
<DT><STRONG>abrackets</STRONG>
<DD><A HREF="#2994">abrackets, antibrackets</A>
<DT><STRONG>abs_</STRONG>
<DD><A HREF="#14347">abs_</A>
<DT><STRONG>acos_</STRONG>
<DD><A HREF="#14846">Extra reserved names</A>
<DT><STRONG>acosh_</STRONG>
<DD><A HREF="#14888">Extra reserved names</A>
<DT><STRONG>active</STRONG>
<DD><A HREF="#5092">nhide</A>
 | <A HREF="#5730">print</A>
 | <A HREF="#6317">skip</A>
 | <A HREF="#7032">unhide</A>
<DT><STRONG>active expressions</STRONG>
<DD><A HREF="#4377">hide</A>
 | <A HREF="#4754">intohide</A>
<DT><STRONG>addargs</STRONG>
<DD><A HREF="#11043">transform</A>
<DT><STRONG>addition</STRONG>
<DD><A HREF="#800">The preprocessor calculator</A>
<DT><STRONG>addto</STRONG>
<DD><A HREF="#16086">addto</A>
 | <A HREF="#16132">off</A>
 | <A HREF="#16140">on</A>
<DT><STRONG>Adler</STRONG>
<DD><DL COMPACT>
<DT><STRONG>Mark</STRONG>
<DD><A HREF="#16058">The TableBase</A>
</DL>
<DT><STRONG>algebra</STRONG>
<DD><DL COMPACT>
<DT><STRONG>Dirac</STRONG>
<DD><A HREF="#7053">unittrace</A>
</DL>
<DT><STRONG>algorithms</STRONG>
<DD><A HREF="#16538">Dirac algebra</A>
<DT><STRONG>all</STRONG>
<DD><A HREF="#8454">identify</A>
<DT><STRONG>also</STRONG>
<DD><A HREF="#3011">also</A>
 | <A HREF="#4487">idold</A>
<DT><STRONG>alternative</STRONG>
<DD><A HREF="#3400">collect</A>
<DT><STRONG>ambiguity</STRONG>
<DD><A HREF="#2776">Pattern matching</A>
<DT><STRONG>and</STRONG>
<DD><A HREF="#806">The preprocessor calculator</A>
<DT><STRONG>antibracket</STRONG>
<DD><A HREF="#3028">antiputinside</A>
 | <A HREF="#3388">collect</A>
 | <A HREF="#4864">makeinteger</A>
 | <A HREF="#5834">print[&nbsp;]</A>
 | <A HREF="#15528">Brackets</A>
<DT><STRONG>antibrackets</STRONG>
<DD><A HREF="#2995">abrackets, antibrackets</A>
<DT><STRONG>anticommute</STRONG>
<DD><A HREF="#16550">Dirac algebra</A>
<DT><STRONG>antiputinside</STRONG>
<DD><A HREF="#3027">antiputinside</A>
<DT><STRONG>antisymmetric</STRONG>
<DD><A HREF="#7695">cfunctions</A>
 | <A HREF="#8279">functions</A>
 | <A HREF="#6188">replaceloop</A>
 | <A HREF="#14413">distrib_</A>
 | <A HREF="#14442">e_</A>
<DT><STRONG>antisymmetrize</STRONG>
<DD><A HREF="#3046">antisymmetrize</A>
<DT><STRONG>append</STRONG>
<DD><A HREF="#10291">printtable</A>
<DT><STRONG>apply</STRONG>
<DD><A HREF="#3058">apply</A>
 | <A HREF="#16076">The TableBase</A>
 | <A HREF="#16095">apply</A>
 | <A HREF="#16164">use</A>
<DT><STRONG>argexplode</STRONG>
<DD><A HREF="#3090">argimplode</A>
<DT><STRONG>argimplode</STRONG>
<DD><A HREF="#3087">argimplode</A>
<DT><STRONG>argument</STRONG>
<DD><A HREF="#3132">argument</A>
 | <A HREF="#3730">dropcoefficient</A>
 | <A HREF="#3803">endargument</A>
 | <A HREF="#4722">inside</A>
 | <A HREF="#4859">makeinteger</A>
 | <A HREF="#5111">normalize</A>
 | <A HREF="#5648">polyfun</A>
 | <A HREF="#5673">polyratfun</A>
 | <A HREF="#6358">splitarg</A>
<DT><STRONG>argument field</STRONG>
<DD><A HREF="#2866">The dollar variables</A>
 | <A HREF="#6622">table</A>
 | <A HREF="#14976">Functions</A>
<DT><STRONG>argument field wildcard</STRONG>
<DD><A HREF="#2762">Pattern matching</A>
<DT><STRONG>argument statement</STRONG>
<DD><A HREF="#6361">splitarg</A>
<DT><STRONG>arguments of functions</STRONG>
<DD><A HREF="#16830">Sorting and statistics</A>
<DT><STRONG>arithmetic</STRONG>
<DD><A HREF="#789">The preprocessor calculator</A>
 | <A HREF="#815">The preprocessor calculator</A>
 | <A HREF="#2799">Pattern matching</A>
<DT><STRONG>arithmetic operations</STRONG>
<DD><A HREF="#15641">Output optimization</A>
<DT><STRONG>array</STRONG>
<DD><A HREF="#2794">Pattern matching</A>
<DT><STRONG>asin_</STRONG>
<DD><A HREF="#14840">Extra reserved names</A>
<DT><STRONG>asinh_</STRONG>
<DD><A HREF="#14882">Extra reserved names</A>
<DT><STRONG>atan2_</STRONG>
<DD><A HREF="#14858">Extra reserved names</A>
<DT><STRONG>atan_</STRONG>
<DD><A HREF="#14852">Extra reserved names</A>
<DT><STRONG>atanh_</STRONG>
<DD><A HREF="#14894">Extra reserved names</A>
<DT><STRONG>audit</STRONG>
<DD><A HREF="#16102">audit</A>
<DT><STRONG>auto</STRONG>
<DD><A HREF="#3157">auto, autodeclare</A>
<DT><STRONG>autodeclare</STRONG>
<DD><A HREF="#448">The autodeclare conventions</A>
 | <A HREF="#3158">auto, autodeclare</A>
<DT><STRONG>backquote</STRONG>
<DD><A HREF="#740">The preprocessor variables</A>
 | <A HREF="#1245">#procedure</A>
<DT><STRONG>backslash</STRONG>
<DD><A HREF="#916">#call</A>
 | <A HREF="#1438">#write</A>
<DT><STRONG>bernoulli_</STRONG>
<DD><A HREF="#14351">bernoulli_</A>
<DT><STRONG>binom_</STRONG>
<DD><A HREF="#14356">binom_</A>
<DT><STRONG>binomials</STRONG>
<DD><A HREF="#6020">ratio</A>
<DT><STRONG>Bjorken &amp; Drell metric</STRONG>
<DD><A HREF="#16498">Dirac algebra</A>
<DT><STRONG>bottleneck</STRONG>
<DD><A HREF="#18149">The parallel version</A>
<DT><STRONG>braces</STRONG>
<DD><A HREF="#422">Sets</A>
 | <A HREF="#15537">Brackets</A>
<DT><STRONG>bracket</STRONG>
<DD><A HREF="#1395">#switch</A>
 | <A HREF="#3214">bracket</A>
 | <A HREF="#4385">hide</A>
 | <A HREF="#5833">print[&nbsp;]</A>
 | <A HREF="#5962">putinside</A>
 | <A HREF="#6319">skip</A>
 | <A HREF="#14427">dum_</A>
 | <A HREF="#14792">termsinbracket_</A>
 | <A HREF="#15523">Brackets</A>
<DL COMPACT>
<DT><STRONG>curly</STRONG>
<DD><A HREF="#792">The preprocessor calculator</A>
 | <A HREF="#2785">Pattern matching</A>
</DL>
<DT><STRONG>bracket  index</STRONG>
<DD><A HREF="#15541">Brackets</A>
<DT><STRONG>bracket index</STRONG>
<DD><A HREF="#4387">hide</A>
<DT><STRONG>bracketindexsize</STRONG>
<DD><A HREF="#15548">Brackets</A>
 | <A HREF="#17277">The setup</A>
<DT><STRONG>brackets</STRONG>
<DD><A HREF="#3215">bracket</A>
 | <A HREF="#3387">collect</A>
 | <A HREF="#4074">fillexpression</A>
 | <A HREF="#16827">Sorting and statistics</A>
<DL COMPACT>
<DT><STRONG>curly</STRONG>
<DD><A HREF="#427">Sets</A>
<DT><STRONG>indexing</STRONG>
<DD><A HREF="#3226">bracket</A>
<DT><STRONG>keep</STRONG>
<DD><A HREF="#4770">keep</A>
</DL>
<DT><STRONG>bucket</STRONG>
<DD><A HREF="#6714">threadbucketsize</A>
 | <A HREF="#18172">TFORM</A>
<DT><STRONG>buffer</STRONG>
<DD><DL COMPACT>
<DT><STRONG>large</STRONG>
<DD><A HREF="#16812">Sorting and statistics</A>
 | <A HREF="#17132">The setup</A>
<DT><STRONG>procedure</STRONG>
<DD><A HREF="#909">#call</A>
<DT><STRONG>small</STRONG>
<DD><A HREF="#16803">Sorting and statistics</A>
 | <A HREF="#17127">The setup</A>
</DL>
<DT><STRONG>bug</STRONG>
<DD><A HREF="#523">Some common bugs</A>
<DT><STRONG>C</STRONG>
<DD><A HREF="#805">The preprocessor calculator</A>
 | <A HREF="#996">#define</A>
 | <A HREF="#1433">#write</A>
 | <A HREF="#8134">format</A>
 | <A HREF="#5779">print</A>
<DT><STRONG>C-interface</STRONG>
<DD><A HREF="#18477">Embedding FORM in other</A>
<DT><STRONG>cache</STRONG>
<DD><A HREF="#17138">The setup</A>
 | <A HREF="#18182">TFORM</A>
<DT><STRONG>caches</STRONG>
<DD><A HREF="#17705">The setup</A>
<DT><STRONG>caching</STRONG>
<DD><A HREF="#16825">Sorting and statistics</A>
<DT><STRONG>calculator</STRONG>
<DD><A HREF="#790">The preprocessor calculator</A>
 | <A HREF="#920">#call</A>
 | <A HREF="#1019">#do</A>
<DL COMPACT>
<DT><STRONG>preprocessor</STRONG>
<DD><A HREF="#430">Sets</A>
</DL>
<DT><STRONG>caveat</STRONG>
<DD><A HREF="#493">Dummy indices</A>
<DT><STRONG>chainin</STRONG>
<DD><A HREF="#3316">chainin</A>
<DT><STRONG>chainout</STRONG>
<DD><A HREF="#3327">chainout</A>
<DT><STRONG>channel</STRONG>
<DD><DL COMPACT>
<DT><STRONG>external</STRONG>
<DD><A HREF="#18396">External communication</A>
</DL>
<DT><STRONG>checkpoints</STRONG>
<DD><A HREF="#2627">Checkpoints</A>
<DT><STRONG>Chinese  remainder theorem</STRONG>
<DD><A HREF="#14680">prime_</A>
<DT><STRONG>Chinese remainder theorem</STRONG>
<DD><A HREF="#14456">exteuclidean_</A>
<DT><STRONG>chisholm</STRONG>
<DD><A HREF="#3341">chisholm</A>
 | <A HREF="#10801">trace4</A>
 | <A HREF="#10816">trace4</A>
 | <A HREF="#10831">trace4</A>
 | <A HREF="#16524">Dirac algebra</A>
 | <A HREF="#16533">Dirac algebra</A>
 | <A HREF="#16542">Dirac algebra</A>
 | <A HREF="#16545">Dirac algebra</A>
<DT><STRONG>clock</STRONG>
<DD><A HREF="#2599">Modules</A>
<DT><STRONG>CMODULE_</STRONG>
<DD><A HREF="#751">The preprocessor variables</A>
<DT><STRONG>coeff_</STRONG>
<DD><A HREF="#299">Symbols</A>
<DT><STRONG>coefficient</STRONG>
<DD><A HREF="#7889">factarg</A>
 | <A HREF="#8607">if</A>
 | <A HREF="#5112">normalize</A>
 | <A HREF="#5649">polyfun</A>
 | <A HREF="#5654">polyfun</A>
 | <A HREF="#5674">polyratfun</A>
 | <A HREF="#5679">polyratfun</A>
<DT><STRONG>coefficients</STRONG>
<DD><DL COMPACT>
<DT><STRONG>integer</STRONG>
<DD><A HREF="#4860">makeinteger</A>
</DL>
<DT><STRONG>collect</STRONG>
<DD><A HREF="#1027">#do</A>
 | <A HREF="#3386">collect</A>
 | <A HREF="#15559">Brackets</A>
<DT><STRONG>colon</STRONG>
<DD><A HREF="#385">Sets</A>
<DT><STRONG>color package</STRONG>
<DD><A HREF="#6199">replaceloop</A>
<DT><STRONG>combinatorics</STRONG>
<DD><A HREF="#14392">dd_</A>
 | <A HREF="#14410">distrib_</A>
<DT><STRONG>comma</STRONG>
<DD><A HREF="#432">Sets</A>
 | <A HREF="#822">The preprocessor calculator</A>
<DT><STRONG>command shell</STRONG>
<DD><A HREF="#18390">External communication</A>
<DT><STRONG>commentary</STRONG>
<DD><A HREF="#727">The preprocessor</A>
 | <A HREF="#966">#commentchar</A>
 | <A HREF="#1200">#include</A>
<DT><STRONG>commentchar</STRONG>
<DD><A HREF="#17294">The setup</A>
<DT><STRONG>Common subexpression elimination</STRONG>
<DD><A HREF="#15709">Optimization options of the</A>
<DT><STRONG>communication</STRONG>
<DD><A HREF="#18145">The parallel version</A>
<DL COMPACT>
<DT><STRONG>external</STRONG>
<DD><A HREF="#18385">External communication</A>
<DT><STRONG>two way</STRONG>
<DD><A HREF="#18393">External communication</A>
</DL>
<DT><STRONG>commuteinset</STRONG>
<DD><A HREF="#3415">commuteinset</A>
<DT><STRONG>commuting</STRONG>
<DD><A HREF="#359">Functions</A>
 | <A HREF="#2743">Pattern matching</A>
 | <A HREF="#7557">auto, autodeclare</A>
 | <A HREF="#3270">cfunctions</A>
 | <A HREF="#3429">commuting</A>
 | <A HREF="#3530">ctable</A>
 | <A HREF="#3545">ctensors</A>
 | <A HREF="#4247">functions</A>
 | <A HREF="#8444">identify</A>
 | <A HREF="#6607">table</A>
 | <A HREF="#6668">tensors</A>
 | <A HREF="#14315">Functions</A>
<DT><STRONG>compilation</STRONG>
<DD><A HREF="#6056">redefine</A>
<DT><STRONG>compile</STRONG>
<DD><A HREF="#16065">The TableBase</A>
<DT><STRONG>compiler</STRONG>
<DD><A HREF="#725">The preprocessor</A>
<DT><STRONG>complex</STRONG>
<DD><A HREF="#287">Symbols</A>
 | <A HREF="#365">Functions</A>
 | <A HREF="#7650">cfunctions</A>
 | <A HREF="#8234">functions</A>
 | <A HREF="#10470">symbols</A>
 | <A HREF="#16687">A few notes on</A>
<DT><STRONG>complicated</STRONG>
<DD><A HREF="#419">Sets</A>
<DT><STRONG>complication</STRONG>
<DD><A HREF="#3395">collect</A>
 | <A HREF="#16797">Sorting and statistics</A>
<DT><STRONG>compress</STRONG>
<DD><A HREF="#3442">compress</A>
 | <A HREF="#16116">enter</A>
 | <A HREF="#16131">off</A>
 | <A HREF="#16138">on</A>
<DT><STRONG>compressed</STRONG>
<DD><A HREF="#16048">The TableBase</A>
<DT><STRONG>compresssize</STRONG>
<DD><A HREF="#17308">The setup</A>
<DT><STRONG>condition</STRONG>
<DD><A HREF="#4509">if</A>
<DT><STRONG>conflicts</STRONG>
<DD><A HREF="#452">The autodeclare conventions</A>
<DT><STRONG>conjg_</STRONG>
<DD><A HREF="#14360">conjg_</A>
<DT><STRONG>conjugate</STRONG>
<DD><DL COMPACT>
<DT><STRONG>complex</STRONG>
<DD><A HREF="#275">Names</A>
</DL>
<DT><STRONG>conjugation</STRONG>
<DD><A HREF="#16684">A few notes on</A>
<DL COMPACT>
<DT><STRONG>complex</STRONG>
<DD><A HREF="#283">Symbols</A>
</DL>
<DT><STRONG>constindex</STRONG>
<DD><A HREF="#4092">fixindex</A>
 | <A HREF="#17323">The setup</A>
<DT><STRONG>content_</STRONG>
<DD><A HREF="#14364">content_</A>
<DT><STRONG>continuationlines</STRONG>
<DD><A HREF="#17339">The setup</A>
<DT><STRONG>contract</STRONG>
<DD><A HREF="#3454">contract</A>
 | <A HREF="#16530">Dirac algebra</A>
<DT><STRONG>contracted  indices</STRONG>
<DD><A HREF="#6146">replaceloop</A>
<DT><STRONG>contraction</STRONG>
<DD><A HREF="#16674">A few notes on</A>
<DT><STRONG>contractions</STRONG>
<DD><DL COMPACT>
<DT><STRONG>trace</STRONG>
<DD><A HREF="#7871">dimension</A>
</DL>
<DT><STRONG>conv2to3</STRONG>
<DD><A HREF="#5267">nwrite</A>
<DT><STRONG>copyspectator</STRONG>
<DD><A HREF="#18671">Spectators</A>
<DT><STRONG>cos_</STRONG>
<DD><A HREF="#14828">Extra reserved names</A>
<DT><STRONG>cosh_</STRONG>
<DD><A HREF="#14870">Extra reserved names</A>
<DT><STRONG>count</STRONG>
<DD><A HREF="#8492">if</A>
 | <A HREF="#10530">symbols</A>
<DT><STRONG>count_</STRONG>
<DD><A HREF="#14377">count_</A>
<DT><STRONG>CPU time</STRONG>
<DD><A HREF="#18196">TFORM</A>
<DT><STRONG>crash</STRONG>
<DD><A HREF="#2629">Checkpoints</A>
<DT><STRONG>crashed FORM program</STRONG>
<DD><A HREF="#2658">Checkpoints</A>
<DT><STRONG>create</STRONG>
<DD><A HREF="#16106">create</A>
 | <A HREF="#16145">open</A>
<DT><STRONG>createspectator</STRONG>
<DD><A HREF="#18661">Spectators</A>
<DT><STRONG>CSE</STRONG>
<DD><A HREF="#15708">Optimization options of the</A>
<DT><STRONG>curly bracket</STRONG>
<DD><A HREF="#791">The preprocessor calculator</A>
<DT><STRONG>cycle</STRONG>
<DD><A HREF="#10999">transform</A>
<DT><STRONG>cycle symmetric</STRONG>
<DD><A HREF="#7710">cfunctions</A>
 | <A HREF="#8294">functions</A>
<DT><STRONG>cyclesymmetric</STRONG>
<DD><A HREF="#6185">replaceloop</A>
<DT><STRONG>cyclesymmetrize</STRONG>
<DD><A HREF="#3562">cyclesymmetrize</A>
<DT><STRONG>Cygwin</STRONG>
<DD><A HREF="#169">Running FORM</A>
<DT><STRONG>d_</STRONG>
<DD><A HREF="#14382">d_</A>
<DT><STRONG>daemon</STRONG>
<DD><A HREF="#1329">#setexternalattr</A>
 | <A HREF="#18441">#setexternalattr</A>
<DT><STRONG>dangerous</STRONG>
<DD><A HREF="#16696">A few notes on</A>
<DT><STRONG>database</STRONG>
<DD><A HREF="#16041">The TableBase</A>
<DT><STRONG>DATE_</STRONG>
<DD><A HREF="#750">The preprocessor variables</A>
<DT><STRONG>dd_</STRONG>
<DD><A HREF="#14389">dd_</A>
<DT><STRONG>deallocatetable</STRONG>
<DD><A HREF="#3574">deallocatetable</A>
<DT><STRONG>debugging</STRONG>
<DD><A HREF="#5729">print</A>
 | <A HREF="#15719">Optimization options of the</A>
<DT><STRONG>declarations</STRONG>
<DD><A HREF="#2579">Modules</A>
<DT><STRONG>decode</STRONG>
<DD><A HREF="#10911">transform</A>
<DT><STRONG>dedup</STRONG>
<DD><A HREF="#10985">transform</A>
<DT><STRONG>default dimension</STRONG>
<DD><A HREF="#6462">sum</A>
<DT><STRONG>define</STRONG>
<DD><A HREF="#17355">The setup</A>
<DT><STRONG>definitions</STRONG>
<DD><A HREF="#2581">Modules</A>
<DT><STRONG>delayed substitution</STRONG>
<DD><A HREF="#997">#define</A>
 | <A HREF="#2881">The dollar variables</A>
<DT><STRONG>delete</STRONG>
<DD><A HREF="#3600">delete</A>
 | <A HREF="#3604">delete</A>
<DT><STRONG>delta</STRONG>
<DD><DL COMPACT>
<DT><STRONG>Kronecker</STRONG>
<DD><A HREF="#334">Indices</A>
 | <A HREF="#500">Kronecker delta's</A>
 | <A HREF="#3459">contract</A>
 | <A HREF="#14386">d_</A>
 | <A HREF="#16665">A few notes on</A>
 | <A HREF="#16695">A few notes on</A>
</DL>
<DT><STRONG>delta_</STRONG>
<DD><A HREF="#14395">delta_</A>
<DT><STRONG>deltap_</STRONG>
<DD><A HREF="#14399">deltap_</A>
<DT><STRONG>den_</STRONG>
<DD><A HREF="#301">Symbols</A>
<DT><STRONG>denom_</STRONG>
<DD><A HREF="#14403">denom_</A>
<DT><STRONG>denominators</STRONG>
<DD><A HREF="#257">Names</A>
 | <A HREF="#3616">denominators</A>
<DT><STRONG>deterministic</STRONG>
<DD><A HREF="#18254">Some problems</A>
<DT><STRONG>dictionaries</STRONG>
<DD><A HREF="#16344">Dictionaries</A>
<DT><STRONG>dimension</STRONG>
<DD><A HREF="#308">Vectors</A>
 | <A HREF="#326">Indices</A>
 | <A HREF="#4669">index, indices</A>
<DL COMPACT>
<DT><STRONG>default</STRONG>
<DD><A HREF="#472">Dummy indices</A>
 | <A HREF="#3631">dimension</A>
 | <A HREF="#6463">sum</A>
</DL>
<DT><STRONG>Dirac</STRONG>
<DD><A HREF="#7052">unittrace</A>
 | <A HREF="#14493">g5_</A>
 | <A HREF="#14510">g_</A>
<DT><STRONG>Dirac algebra</STRONG>
<DD><A HREF="#16493">Dirac algebra</A>
<DT><STRONG>discard</STRONG>
<DD><A HREF="#3668">discard</A>
 | <A HREF="#10533">symbols</A>
<DT><STRONG>disk to disk sort</STRONG>
<DD><A HREF="#16821">Sorting and statistics</A>
<DT><STRONG>disorder</STRONG>
<DD><A HREF="#3683">disorder</A>
 | <A HREF="#8434">identify</A>
<DT><STRONG>distrib_</STRONG>
<DD><A HREF="#6289">shuffle</A>
 | <A HREF="#14407">distrib_</A>
 | <A HREF="#16560">Dirac algebra</A>
<DT><STRONG>div_</STRONG>
<DD><A HREF="#14417">div_</A>
 | <A HREF="#15932">Polynomials and Factorization</A>
<DT><STRONG>division</STRONG>
<DD><A HREF="#803">The preprocessor calculator</A>
<DT><STRONG>do loop</STRONG>
<DD><A HREF="#1009">#do</A>
 | <A HREF="#1055">#enddo</A>
<DT><STRONG>dollar</STRONG>
<DD><A HREF="#4037">fill</A>
<DL COMPACT>
<DT><STRONG>printing</STRONG>
<DD><A HREF="#2898">The dollar variables</A>
</DL>
<DT><STRONG>dotchar</STRONG>
<DD><A HREF="#264">Names</A>
 | <A HREF="#8144">format</A>
 | <A HREF="#17372">The setup</A>
<DT><STRONG>dotproducts</STRONG>
<DD><A HREF="#261">Names</A>
 | <A HREF="#17379">The setup</A>
<DT><STRONG>double quote</STRONG>
<DD><A HREF="#1437">#write</A>
<DT><STRONG>doublefortran</STRONG>
<DD><A HREF="#8073">format</A>
 | <A HREF="#16382">Dictionaries</A>
<DT><STRONG>drop</STRONG>
<DD><A HREF="#3718">drop</A>
 | <A HREF="#4840">local</A>
 | <A HREF="#5042">ndrop</A>
<DT><STRONG>dropargs</STRONG>
<DD><A HREF="#11071">transform</A>
<DT><STRONG>dum_</STRONG>
<DD><A HREF="#4866">makeinteger</A>
 | <A HREF="#14423">dum_</A>
<DT><STRONG>dummy</STRONG>
<DD><A HREF="#6088">renumber</A>
 | <A HREF="#6460">sum</A>
 | <A HREF="#14938">Functions</A>
<DT><STRONG>dummy arguments</STRONG>
<DD><A HREF="#4344">global</A>
<DT><STRONG>dummy_</STRONG>
<DD><A HREF="#14429">dummy_</A>
<DT><STRONG>dummyindices_</STRONG>
<DD><A HREF="#410">Sets</A>
<DT><STRONG>dummyten_</STRONG>
<DD><A HREF="#14433">dummyten_</A>
<DT><STRONG>dynamical loading</STRONG>
<DD><A HREF="#4071">fillexpression</A>
<DT><STRONG>e_</STRONG>
<DD><A HREF="#14437">e_</A>
<DT><STRONG>edit</STRONG>
<DD><A HREF="#724">The preprocessor</A>
 | <A HREF="#738">The preprocessor variables</A>
<DT><STRONG>efficient</STRONG>
<DD><A HREF="#16795">Sorting and statistics</A>
<DT><STRONG>Einstein</STRONG>
<DD><A HREF="#327">Indices</A>
 | <A HREF="#374">Functions</A>
 | <A HREF="#501">Kronecker delta's</A>
<DT><STRONG>elements</STRONG>
<DD><A HREF="#6260">set</A>
<DT><STRONG>else</STRONG>
<DD><A HREF="#3753">else</A>
 | <A HREF="#3782">elseif</A>
 | <A HREF="#4510">if</A>
<DT><STRONG>else statement</STRONG>
<DD><A HREF="#3752">else</A>
 | <A HREF="#3781">elseif</A>
<DT><STRONG>elseif</STRONG>
<DD><A HREF="#3759">else</A>
 | <A HREF="#3780">elseif</A>
 | <A HREF="#4512">if</A>
<DT><STRONG>elseif statement</STRONG>
<DD><A HREF="#3779">elseif</A>
<DT><STRONG>embed</STRONG>
<DD><A HREF="#18461">Embedding FORM in other</A>
<DT><STRONG>emptyspectator</STRONG>
<DD><A HREF="#18677">Spectators</A>
<DT><STRONG>encode</STRONG>
<DD><A HREF="#10897">transform</A>
<DT><STRONG>end of module specifications</STRONG>
<DD><A HREF="#2584">Modules</A>
<DT><STRONG>endargument</STRONG>
<DD><A HREF="#3135">argument</A>
 | <A HREF="#3731">dropcoefficient</A>
 | <A HREF="#3804">endargument</A>
<DT><STRONG>endif</STRONG>
<DD><A HREF="#3755">else</A>
 | <A HREF="#3777">elseif</A>
 | <A HREF="#3830">endif</A>
 | <A HREF="#4514">if</A>
<DT><STRONG>endif statement</STRONG>
<DD><A HREF="#3754">else</A>
 | <A HREF="#3776">elseif</A>
 | <A HREF="#3829">endif</A>
<DT><STRONG>endinexpression</STRONG>
<DD><A HREF="#3839">endinexpression</A>
<DT><STRONG>endinside</STRONG>
<DD><A HREF="#4725">inside</A>
<DT><STRONG>endrepeat</STRONG>
<DD><A HREF="#3871">endrepeat</A>
 | <A HREF="#6111">repeat</A>
<DT><STRONG>endterm</STRONG>
<DD><A HREF="#3896">endterm</A>
 | <A HREF="#6684">term</A>
<DT><STRONG>endwhile</STRONG>
<DD><A HREF="#3910">endwhile</A>
 | <A HREF="#7079">while</A>
<DT><STRONG>enter</STRONG>
<DD><A HREF="#16113">enter</A>
<DT><STRONG>environment</STRONG>
<DD><A HREF="#779">The preprocessor variables</A>
 | <A HREF="#17184">The setup</A>
<DL COMPACT>
<DT><STRONG>argument</STRONG>
<DD><A HREF="#3133">argument</A>
 | <A HREF="#3801">endargument</A>
<DT><STRONG>inside</STRONG>
<DD><A HREF="#3855">endinside</A>
<DT><STRONG>repeat</STRONG>
<DD><A HREF="#3869">endrepeat</A>
<DT><STRONG>term</STRONG>
<DD><A HREF="#3894">endterm</A>
 | <A HREF="#6339">sort</A>
 | <A HREF="#6683">term</A>
<DT><STRONG>while</STRONG>
<DD><A HREF="#3908">endwhile</A>
 | <A HREF="#7078">while</A>
</DL>
<DT><STRONG>environment variables</STRONG>
<DD><A HREF="#193">Running FORM</A>
<DT><STRONG>error</STRONG>
<DD><A HREF="#522">Some common bugs</A>
<DL COMPACT>
<DT><STRONG>runtime</STRONG>
<DD><A HREF="#2869">The dollar variables</A>
</DL>
<DT><STRONG>error stream</STRONG>
<DD><A HREF="#18448">#setexternalattr</A>
<DT><STRONG>even_</STRONG>
<DD><A HREF="#406">Sets</A>
<DT><STRONG>exclamation</STRONG>
<DD><A HREF="#435">Sets</A>
<DT><STRONG>executable statements</STRONG>
<DD><A HREF="#2582">Modules</A>
<DT><STRONG>execution</STRONG>
<DD><A HREF="#2570">Modules</A>
 | <A HREF="#6278">setexitflag</A>
<DT><STRONG>exists</STRONG>
<DD><A HREF="#1523">#if</A>
<DT><STRONG>exit</STRONG>
<DD><A HREF="#3921">exit</A>
<DT><STRONG>exp_</STRONG>
<DD><A HREF="#14445">exp_</A>
<DT><STRONG>explode</STRONG>
<DD><A HREF="#10943">transform</A>
<DT><STRONG>exponent</STRONG>
<DD><A HREF="#808">The preprocessor calculator</A>
<DT><STRONG>exponent operator</STRONG>
<DD><A HREF="#8142">format</A>
<DT><STRONG>expression</STRONG>
<DD><A HREF="#245">Variables</A>
 | <A HREF="#1091">#exchange</A>
 | <A HREF="#1442">#write</A>
 | <A HREF="#3719">drop</A>
 | <A HREF="#4336">global</A>
 | <A HREF="#8539">if</A>
 | <A HREF="#8552">if</A>
 | <A HREF="#14474">factorin_</A>
<DT><STRONG>extension</STRONG>
<DD><DL COMPACT>
<DT><STRONG>.sav</STRONG>
<DD><A HREF="#6224">save</A>
<DT><STRONG>small</STRONG>
<DD><A HREF="#16805">Sorting and statistics</A>
</DL>
<DT><STRONG>exteuclidean_</STRONG>
<DD><A HREF="#14449">exteuclidean_</A>
<DT><STRONG>extform.pdf</STRONG>
<DD><A HREF="#18395">External communication</A>
<DT><STRONG>extform.ps</STRONG>
<DD><A HREF="#18394">External communication</A>
<DT><STRONG>extra symbols</STRONG>
<DD><A HREF="#1365">#skipextrasymbols</A>
 | <A HREF="#3606">delete</A>
 | <A HREF="#3940">extrasymbols</A>
 | <A HREF="#15650">Output optimization</A>
 | <A HREF="#15656">Output optimization</A>
 | <A HREF="#15658">Output optimization</A>
 | <A HREF="#16409">Dictionaries</A>
<DT><STRONG>extrasymbol_</STRONG>
<DD><A HREF="#14460">extrasymbol_</A>
<DT><STRONG>extrasymbols</STRONG>
<DD><A HREF="#1452">#write</A>
<DT><STRONG>extrasymbols_</STRONG>
<DD><A HREF="#302">Symbols</A>
 | <A HREF="#753">The preprocessor variables</A>
<DT><STRONG>fac_</STRONG>
<DD><A HREF="#14465">fac_</A>
<DT><STRONG>factarg</STRONG>
<DD><A HREF="#3957">factarg</A>
 | <A HREF="#9334">off</A>
 | <A HREF="#9749">on</A>
<DT><STRONG>factorial</STRONG>
<DD><A HREF="#809">The preprocessor calculator</A>
 | <A HREF="#14468">fac_</A>
 | <A HREF="#14552">invfac_</A>
<DT><STRONG>factorin_</STRONG>
<DD><A HREF="#14470">factorin_</A>
<DT><STRONG>fall-through</STRONG>
<DD><A HREF="#1391">#switch</A>
<DT><STRONG>farg_</STRONG>
<DD><A HREF="#14478">farg_</A>
<DT><STRONG>file</STRONG>
<DD><A HREF="#1448">#write</A>
<DL COMPACT>
<DT><STRONG>close</STRONG>
<DD><A HREF="#955">#close</A>
<DT><STRONG>disk</STRONG>
<DD><A HREF="#4342">global</A>
<DT><STRONG>hide</STRONG>
<DD><A HREF="#4380">hide</A>
 | <A HREF="#7031">unhide</A>
<DT><STRONG>include</STRONG>
<DD><A HREF="#1387">#switch</A>
<DT><STRONG>input</STRONG>
<DD><A HREF="#172">Running FORM</A>
 | <A HREF="#16115">enter</A>
<DT><STRONG>intermediate</STRONG>
<DD><A HREF="#2574">Modules</A>
<DT><STRONG>log</STRONG>
<DD><A HREF="#188">Running FORM</A>
 | <A HREF="#10016">print</A>
 | <A HREF="#10031">print</A>
 | <A HREF="#5872">printtable</A>
<DT><STRONG>new</STRONG>
<DD><A HREF="#16107">create</A>
<DT><STRONG>program</STRONG>
<DD><A HREF="#16889">The setup</A>
<DT><STRONG>saved</STRONG>
<DD><A HREF="#4822">load</A>
<DT><STRONG>setup</STRONG>
<DD><A HREF="#201">Running FORM</A>
 | <A HREF="#203">Running FORM</A>
 | <A HREF="#16888">The setup</A>
<DT><STRONG>sort</STRONG>
<DD><A HREF="#17136">The setup</A>
 | <A HREF="#18183">TFORM</A>
<DT><STRONG>storage</STRONG>
<DD><A HREF="#2594">Modules</A>
 | <A HREF="#3602">delete</A>
 | <A HREF="#4339">global</A>
 | <A HREF="#4824">load</A>
<DT><STRONG>store</STRONG>
<DD><A HREF="#6218">save</A>
 | <A HREF="#17707">The setup</A>
<DT><STRONG>temporary</STRONG>
<DD><A HREF="#197">Running FORM</A>
</DL>
<DT><STRONG>filename</STRONG>
<DD><A HREF="#18660">Spectators</A>
<DT><STRONG>filepatches</STRONG>
<DD><A HREF="#16824">Sorting and statistics</A>
 | <A HREF="#17137">The setup</A>
 | <A HREF="#17899">The setup</A>
<DT><STRONG>files</STRONG>
<DD><DL COMPACT>
<DT><STRONG>.sav</STRONG>
<DD><A HREF="#495">Dummy indices</A>
</DL>
<DT><STRONG>fill</STRONG>
<DD><A HREF="#3577">deallocatetable</A>
 | <A HREF="#4020">fill</A>
 | <A HREF="#4075">fillexpression</A>
 | <A HREF="#5873">printtable</A>
 | <A HREF="#6617">table</A>
 | <A HREF="#16044">The TableBase</A>
 | <A HREF="#16088">addto</A>
 | <A HREF="#16096">apply</A>
 | <A HREF="#16114">enter</A>
 | <A HREF="#16123">load</A>
<DT><STRONG>fillexpression</STRONG>
<DD><A HREF="#4070">fillexpression</A>
 | <A HREF="#5866">printtable</A>
 | <A HREF="#14768">table_</A>
<DT><STRONG>filter</STRONG>
<DD><A HREF="#18397">External communication</A>
<DT><STRONG>findloop</STRONG>
<DD><A HREF="#8565">if</A>
 | <A HREF="#6201">replaceloop</A>
<DT><STRONG>firstbracket_</STRONG>
<DD><A HREF="#14482">firstbracket_</A>
<DT><STRONG>firstterm_</STRONG>
<DD><A HREF="#14486">firstterm_</A>
<DT><STRONG>fixed index</STRONG>
<DD><A HREF="#4090">fixindex</A>
<DT><STRONG>fixed_</STRONG>
<DD><A HREF="#402">Sets</A>
<DT><STRONG>fixindex</STRONG>
<DD><A HREF="#2790">Pattern matching</A>
 | <A HREF="#4089">fixindex</A>
 | <A HREF="#16697">A few notes on</A>
<DT><STRONG>flexibility</STRONG>
<DD><A HREF="#16693">A few notes on</A>
<DT><STRONG>float</STRONG>
<DD><A HREF="#7934">format</A>
<DT><STRONG>floating point</STRONG>
<DD><A HREF="#7944">format</A>
<DT><STRONG>fold</STRONG>
<DD><A HREF="#1192">#include</A>
<DT><STRONG>folders</STRONG>
<DD><A HREF="#18414">#fromexternal</A>
<DT><STRONG>foldname</STRONG>
<DD><A HREF="#1191">#include</A>
<DT><STRONG>folds</STRONG>
<DD><A HREF="#1385">#switch</A>
<DT><STRONG>form.set</STRONG>
<DD><A HREF="#205">Running FORM</A>
 | <A HREF="#16890">The setup</A>
<DT><STRONG>FORM_PIPES</STRONG>
<DD><A HREF="#18480">Embedding FORM in other</A>
<DT><STRONG>format</STRONG>
<DD><A HREF="#2903">The dollar variables</A>
 | <A HREF="#4111">format</A>
 | <A HREF="#10083">print</A>
 | <A HREF="#10264">printtable</A>
<DL COMPACT>
<DT><STRONG>C</STRONG>
<DD><A HREF="#8135">format</A>
<DT><STRONG>doublefortran</STRONG>
<DD><A HREF="#8074">format</A>
<DT><STRONG>float</STRONG>
<DD><A HREF="#7935">format</A>
<DT><STRONG>fortran</STRONG>
<DD><A HREF="#8058">format</A>
<DT><STRONG>fortran90</STRONG>
<DD><A HREF="#8118">format</A>
<DT><STRONG>maple</STRONG>
<DD><A HREF="#8154">format</A>
<DT><STRONG>mathematica</STRONG>
<DD><A HREF="#8168">format</A>
<DT><STRONG>normal</STRONG>
<DD><A HREF="#8196">format</A>
<DT><STRONG>nospaces</STRONG>
<DD><A HREF="#7966">format</A>
<DT><STRONG>optimize</STRONG>
<DD><A HREF="#7994">format</A>
 | <A HREF="#8010">format</A>
 | <A HREF="#8026">format</A>
 | <A HREF="#8042">format</A>
<DT><STRONG>quadfortran</STRONG>
<DD><A HREF="#8104">format</A>
<DT><STRONG>quadruplefortran</STRONG>
<DD><A HREF="#8089">format</A>
<DT><STRONG>rational</STRONG>
<DD><A HREF="#7952">format</A>
<DT><STRONG>reduce</STRONG>
<DD><A HREF="#8182">format</A>
<DT><STRONG>spaces</STRONG>
<DD><A HREF="#7980">format</A>
</DL>
<DT><STRONG>format string</STRONG>
<DD><A HREF="#1432">#write</A>
 | <A HREF="#5777">print</A>
<DT><STRONG>FORMPATH</STRONG>
<DD><A HREF="#195">Running FORM</A>
 | <A HREF="#913">#call</A>
 | <A HREF="#1195">#include</A>
 | <A HREF="#1450">#write</A>
 | <A HREF="#16146">open</A>
<DT><STRONG>FORMSETUP</STRONG>
<DD><A HREF="#200">Running FORM</A>
<DT><STRONG>FORMTMP</STRONG>
<DD><A HREF="#196">Running FORM</A>
<DT><STRONG>FORMTMPSORT</STRONG>
<DD><A HREF="#198">Running FORM</A>
<DT><STRONG>fortran</STRONG>
<DD><A HREF="#263">Names</A>
 | <A HREF="#1443">#write</A>
 | <A HREF="#1461">#write</A>
 | <A HREF="#8057">format</A>
 | <A HREF="#16377">Dictionaries</A>
 | <A HREF="#17380">The setup</A>
<DT><STRONG>fortran90</STRONG>
<DD><A HREF="#8117">format</A>
<DT><STRONG>fractions</STRONG>
<DD><A HREF="#4988">modulus</A>
<DT><STRONG>function</STRONG>
<DD><A HREF="#5074">nfunctions</A>
 | <A HREF="#14314">Functions</A>
<DL COMPACT>
<DT><STRONG>abs_</STRONG>
<DD><A HREF="#14348">abs_</A>
<DT><STRONG>acos_</STRONG>
<DD><A HREF="#14847">Extra reserved names</A>
<DT><STRONG>acosh_</STRONG>
<DD><A HREF="#14889">Extra reserved names</A>
<DT><STRONG>asin_</STRONG>
<DD><A HREF="#14841">Extra reserved names</A>
<DT><STRONG>asinh_</STRONG>
<DD><A HREF="#14883">Extra reserved names</A>
<DT><STRONG>atan2_</STRONG>
<DD><A HREF="#14859">Extra reserved names</A>
<DT><STRONG>atan_</STRONG>
<DD><A HREF="#14853">Extra reserved names</A>
<DT><STRONG>atanh_</STRONG>
<DD><A HREF="#14895">Extra reserved names</A>
<DT><STRONG>bernoulli_</STRONG>
<DD><A HREF="#14352">bernoulli_</A>
<DT><STRONG>binom_</STRONG>
<DD><A HREF="#14357">binom_</A>
<DT><STRONG>commuting</STRONG>
<DD><A HREF="#360">Functions</A>
<DT><STRONG>conjg_</STRONG>
<DD><A HREF="#14361">conjg_</A>
<DT><STRONG>content_</STRONG>
<DD><A HREF="#14365">content_</A>
<DT><STRONG>cos_</STRONG>
<DD><A HREF="#14829">Extra reserved names</A>
<DT><STRONG>cosh_</STRONG>
<DD><A HREF="#14871">Extra reserved names</A>
<DT><STRONG>count_</STRONG>
<DD><A HREF="#14378">count_</A>
<DT><STRONG>d_</STRONG>
<DD><A HREF="#14383">d_</A>
<DT><STRONG>dd_</STRONG>
<DD><A HREF="#14390">dd_</A>
<DT><STRONG>delta_</STRONG>
<DD><A HREF="#14396">delta_</A>
<DT><STRONG>deltap_</STRONG>
<DD><A HREF="#14400">deltap_</A>
<DT><STRONG>denom_</STRONG>
<DD><A HREF="#14404">denom_</A>
<DT><STRONG>distrib_</STRONG>
<DD><A HREF="#6290">shuffle</A>
 | <A HREF="#14408">distrib_</A>
<DT><STRONG>div_</STRONG>
<DD><A HREF="#14418">div_</A>
 | <A HREF="#15933">Polynomials and Factorization</A>
<DT><STRONG>dum_</STRONG>
<DD><A HREF="#14424">dum_</A>
<DT><STRONG>dummy_</STRONG>
<DD><A HREF="#14430">dummy_</A>
<DT><STRONG>dummyten_</STRONG>
<DD><A HREF="#14434">dummyten_</A>
<DT><STRONG>e_</STRONG>
<DD><A HREF="#14438">e_</A>
<DT><STRONG>exp_</STRONG>
<DD><A HREF="#14446">exp_</A>
<DT><STRONG>exteuclidean_</STRONG>
<DD><A HREF="#14450">exteuclidean_</A>
<DT><STRONG>extrasymbol_</STRONG>
<DD><A HREF="#14461">extrasymbol_</A>
<DT><STRONG>fac_</STRONG>
<DD><A HREF="#14466">fac_</A>
<DT><STRONG>factorin_</STRONG>
<DD><A HREF="#14471">factorin_</A>
<DT><STRONG>farg_</STRONG>
<DD><A HREF="#14479">farg_</A>
<DT><STRONG>firstbracket_</STRONG>
<DD><A HREF="#14483">firstbracket_</A>
<DT><STRONG>firstterm_</STRONG>
<DD><A HREF="#14487">firstterm_</A>
<DT><STRONG>g5_</STRONG>
<DD><A HREF="#14491">g5_</A>
<DT><STRONG>g6_</STRONG>
<DD><A HREF="#14498">g6_</A>
<DT><STRONG>g7_</STRONG>
<DD><A HREF="#14503">g7_</A>
<DT><STRONG>g_</STRONG>
<DD><A HREF="#14508">g_</A>
<DT><STRONG>gcd_</STRONG>
<DD><A HREF="#14514">gcd_</A>
 | <A HREF="#15930">Polynomials and Factorization</A>
<DT><STRONG>gi_</STRONG>
<DD><A HREF="#14520">gi_</A>
<DT><STRONG>id_</STRONG>
<DD><A HREF="#14524">id_</A>
<DT><STRONG>integer_</STRONG>
<DD><A HREF="#14541">integer_</A>
<DT><STRONG>inverse_</STRONG>
<DD><A HREF="#14546">inverse_</A>
<DT><STRONG>invfac_</STRONG>
<DD><A HREF="#14550">invfac_</A>
<DT><STRONG>li2_</STRONG>
<DD><A HREF="#14901">Extra reserved names</A>
<DT><STRONG>lin_</STRONG>
<DD><A HREF="#14907">Extra reserved names</A>
<DT><STRONG>ln_</STRONG>
<DD><A HREF="#14817">Extra reserved names</A>
<DT><STRONG>makerational_</STRONG>
<DD><A HREF="#14555">makerational_</A>
<DT><STRONG>match_</STRONG>
<DD><A HREF="#14561">match_</A>
<DT><STRONG>max_</STRONG>
<DD><A HREF="#14565">max_</A>
<DT><STRONG>maxpowerof_</STRONG>
<DD><A HREF="#14569">maxpowerof_</A>
<DT><STRONG>min_</STRONG>
<DD><A HREF="#14575">min_</A>
<DT><STRONG>minpowerof_</STRONG>
<DD><A HREF="#14579">minpowerof_</A>
<DT><STRONG>mod2_</STRONG>
<DD><A HREF="#14591">mod2_</A>
<DT><STRONG>mod_</STRONG>
<DD><A HREF="#14583">mod_</A>
<DT><STRONG>moebius_</STRONG>
<DD><A HREF="#14596">moebius_</A>
<DT><STRONG>mul_</STRONG>
<DD><A HREF="#14605">mul_</A>
<DT><STRONG>nargs_</STRONG>
<DD><A HREF="#14610">nargs_</A>
<DT><STRONG>node_</STRONG>
<DD><A HREF="#14614">node_</A>
<DT><STRONG>non-commuting</STRONG>
<DD><A HREF="#362">Functions</A>
<DT><STRONG>nterms_</STRONG>
<DD><A HREF="#14619">nterms_</A>
<DT><STRONG>numfactors_</STRONG>
<DD><A HREF="#14623">numfactors_</A>
<DT><STRONG>partitions_</STRONG>
<DD><A HREF="#14629">partitions_</A>
<DT><STRONG>pattern_</STRONG>
<DD><A HREF="#14641">pattern_</A>
<DT><STRONG>perm_</STRONG>
<DD><A HREF="#14645">perm_</A>
<DT><STRONG>poly_</STRONG>
<DD><A HREF="#14651">poly_</A>
<DT><STRONG>polyadd_</STRONG>
<DD><A HREF="#14654">poly_</A>
<DT><STRONG>polydiv_</STRONG>
<DD><A HREF="#14421">div_</A>
 | <A HREF="#14656">poly_</A>
<DT><STRONG>polygcd_</STRONG>
<DD><A HREF="#14517">gcd_</A>
 | <A HREF="#14658">poly_</A>
 | <A HREF="#15987">Polynomials and Factorization</A>
<DT><STRONG>polyintfac_</STRONG>
<DD><A HREF="#14660">poly_</A>
<DT><STRONG>polymul_</STRONG>
<DD><A HREF="#14662">poly_</A>
<DT><STRONG>polynorm_</STRONG>
<DD><A HREF="#14664">poly_</A>
<DT><STRONG>polyrem_</STRONG>
<DD><A HREF="#14666">poly_</A>
 | <A HREF="#14713">rem_</A>
<DT><STRONG>polysub_</STRONG>
<DD><A HREF="#14668">poly_</A>
<DT><STRONG>prime_</STRONG>
<DD><A HREF="#14675">prime_</A>
<DT><STRONG>putfirst_</STRONG>
<DD><A HREF="#14685">putfirst_</A>
<DT><STRONG>random_</STRONG>
<DD><A HREF="#1350">#setrandom</A>
 | <A HREF="#14693">random_</A>
 | <A HREF="#14705">ranperm_</A>
<DT><STRONG>ranperm_</STRONG>
<DD><A HREF="#14699">ranperm_</A>
<DT><STRONG>regular</STRONG>
<DD><A HREF="#14317">Functions</A>
<DT><STRONG>rem_</STRONG>
<DD><A HREF="#14710">rem_</A>
 | <A HREF="#15936">Polynomials and Factorization</A>
<DT><STRONG>replace_</STRONG>
<DD><A HREF="#6998">tryreplace</A>
 | <A HREF="#14716">replace_</A>
<DT><STRONG>reverse_</STRONG>
<DD><A HREF="#14725">reverse_</A>
<DT><STRONG>root_</STRONG>
<DD><A HREF="#14729">root_</A>
<DT><STRONG>setfun_</STRONG>
<DD><A HREF="#14733">setfun_</A>
<DT><STRONG>sig_</STRONG>
<DD><A HREF="#14737">sig_</A>
<DT><STRONG>sign_</STRONG>
<DD><A HREF="#14741">sign_</A>
<DT><STRONG>sin_</STRONG>
<DD><A HREF="#14823">Extra reserved names</A>
<DT><STRONG>sinh_</STRONG>
<DD><A HREF="#14865">Extra reserved names</A>
<DT><STRONG>sizeof_</STRONG>
<DD><A HREF="#14745">sizeof_</A>
<DT><STRONG>sqrt_</STRONG>
<DD><A HREF="#14811">Extra reserved names</A>
<DT><STRONG>sum_</STRONG>
<DD><A HREF="#14751">sum_</A>
<DT><STRONG>sump_</STRONG>
<DD><A HREF="#14758">sump_</A>
<DT><STRONG>table_</STRONG>
<DD><A HREF="#14765">table_</A>
<DT><STRONG>tan_</STRONG>
<DD><A HREF="#14835">Extra reserved names</A>
<DT><STRONG>tanh_</STRONG>
<DD><A HREF="#14877">Extra reserved names</A>
<DT><STRONG>tbl_</STRONG>
<DD><A HREF="#14772">tbl_</A>
<DT><STRONG>term_</STRONG>
<DD><A HREF="#14778">term_</A>
<DT><STRONG>termsin_</STRONG>
<DD><A HREF="#14784">termsin_</A>
<DT><STRONG>termsinbracket_</STRONG>
<DD><A HREF="#14790">termsinbracket_</A>
<DT><STRONG>theta_</STRONG>
<DD><A HREF="#14796">theta_</A>
<DT><STRONG>thetap_</STRONG>
<DD><A HREF="#14800">thetap_</A>
<DT><STRONG>topologies_</STRONG>
<DD><A HREF="#14804">topologies_</A>
</DL>
<DT><STRONG>function  arguments</STRONG>
<DD><A HREF="#3958">factarg</A>
<DT><STRONG>functionlevels</STRONG>
<DD><A HREF="#17388">The setup</A>
<DT><STRONG>functions</STRONG>
<DD><A HREF="#356">Functions</A>
 | <A HREF="#4245">functions</A>
<DL COMPACT>
<DT><STRONG>commuting</STRONG>
<DD><A HREF="#7558">auto, autodeclare</A>
 | <A HREF="#3271">cfunctions</A>
<DT><STRONG>noncommuting</STRONG>
<DD><A HREF="#7530">auto, autodeclare</A>
 | <A HREF="#8442">identify</A>
</DL>
<DT><STRONG>funpowers</STRONG>
<DD><A HREF="#4302">funpowers</A>
<DT><STRONG>g5_</STRONG>
<DD><A HREF="#14490">g5_</A>
 | <A HREF="#16499">Dirac algebra</A>
<DT><STRONG>g6_</STRONG>
<DD><A HREF="#14497">g6_</A>
<DT><STRONG>g7_</STRONG>
<DD><A HREF="#14502">g7_</A>
<DT><STRONG>g_</STRONG>
<DD><A HREF="#14507">g_</A>
 | <A HREF="#16494">Dirac algebra</A>
<DT><STRONG>Gailly</STRONG>
<DD><DL COMPACT>
<DT><STRONG>Jean-loup</STRONG>
<DD><A HREF="#16057">The TableBase</A>
</DL>
<DT><STRONG>gamma algebra</STRONG>
<DD><A HREF="#3354">chisholm</A>
<DT><STRONG>gamma matrices</STRONG>
<DD><A HREF="#349">Indices</A>
 | <A HREF="#3346">chisholm</A>
 | <A HREF="#6838">trace4</A>
 | <A HREF="#6875">tracen</A>
 | <A HREF="#14494">g5_</A>
 | <A HREF="#14511">g_</A>
 | <A HREF="#16492">Dirac algebra</A>
<DT><STRONG>garbage collection</STRONG>
<DD><A HREF="#16808">Sorting and statistics</A>
<DT><STRONG>GCD</STRONG>
<DD><A HREF="#14475">factorin_</A>
<DT><STRONG>gcd_</STRONG>
<DD><A HREF="#14513">gcd_</A>
 | <A HREF="#15929">Polynomials and Factorization</A>
<DT><STRONG>gi_</STRONG>
<DD><A HREF="#14519">gi_</A>
 | <A HREF="#16515">Dirac algebra</A>
<DT><STRONG>global</STRONG>
<DD><A HREF="#4335">global</A>
 | <A HREF="#4842">local</A>
<DT><STRONG>GNU</STRONG>
<DD><A HREF="#18458">An example</A>
<DT><STRONG>goto</STRONG>
<DD><A HREF="#4359">goto</A>
 | <A HREF="#4787">label</A>
<DT><STRONG>Grace</STRONG>
<DD><A HREF="#1256">#procedureextension</A>
<DT><STRONG>greater than</STRONG>
<DD><A HREF="#841">The triple dot operator</A>
<DT><STRONG>greedy optimizations</STRONG>
<DD><A HREF="#15710">Optimization options of the</A>
<DT><STRONG>group theory</STRONG>
<DD><A HREF="#6200">replaceloop</A>
<DT><STRONG>guarantee</STRONG>
<DD><A HREF="#5026">multiply</A>
<DT><STRONG>gzip</STRONG>
<DD><A HREF="#9616">on</A>
 | <A HREF="#16139">on</A>
<DT><STRONG>harmonic  polylogarithms</STRONG>
<DD><A HREF="#3083">argimplode</A>
<DT><STRONG>harmonic  sums</STRONG>
<DD><A HREF="#3081">argimplode</A>
 | <A HREF="#6977">transform</A>
<DT><STRONG>harmonic polylogarithm</STRONG>
<DD><A HREF="#6301">shuffle</A>
 | <A HREF="#6978">transform</A>
<DT><STRONG>harmonic sum</STRONG>
<DD><A HREF="#6300">shuffle</A>
 | <A HREF="#6441">stuffle</A>
<DT><STRONG>hide</STRONG>
<DD><A HREF="#4376">hide</A>
 | <A HREF="#4753">intohide</A>
 | <A HREF="#5091">nhide</A>
 | <A HREF="#5247">nunhide</A>
 | <A HREF="#5946">pushhide</A>
 | <A HREF="#7030">unhide</A>
 | <A HREF="#17685">The setup</A>
 | <A HREF="#17841">The setup</A>
 | <A HREF="#18203">TFORM</A>
<DT><STRONG>hide file</STRONG>
<DD><A HREF="#4379">hide</A>
<DT><STRONG>hide files</STRONG>
<DD><A HREF="#2656">Checkpoints</A>
<DT><STRONG>hidesize</STRONG>
<DD><A HREF="#17402">The setup</A>
<DT><STRONG>hierarchy</STRONG>
<DD><A HREF="#4601">if</A>
<DT><STRONG>high energy physics</STRONG>
<DD><A HREF="#16491">Dirac algebra</A>
<DT><STRONG>highfirst</STRONG>
<DD><A HREF="#17725">The setup</A>
<DT><STRONG>Horner scheme</STRONG>
<DD><A HREF="#15677">Optimization options of the</A>
 | <A HREF="#15722">Optimization options of the</A>
<DT><STRONG>i_</STRONG>
<DD><A HREF="#296">Symbols</A>
 | <A HREF="#316">Vectors</A>
 | <A HREF="#16523">Dirac algebra</A>
<DT><STRONG>id</STRONG>
<DD><A HREF="#2739">Pattern matching</A>
 | <A HREF="#3012">also</A>
 | <A HREF="#3686">disorder</A>
 | <A HREF="#4340">global</A>
 | <A HREF="#4414">identify</A>
 | <A HREF="#4467">idnew</A>
 | <A HREF="#4489">idold</A>
 | <A HREF="#4885">many</A>
 | <A HREF="#5003">multi</A>
 | <A HREF="#5612">once</A>
 | <A HREF="#5631">only</A>
 | <A HREF="#6240">select</A>
 | <A HREF="#6324">skip</A>
 | <A HREF="#6468">sum</A>
 | <A HREF="#14719">replace_</A>
<DT><STRONG>id statement</STRONG>
<DD><A HREF="#3685">disorder</A>
<DT><STRONG>id_</STRONG>
<DD><A HREF="#14523">id_</A>
<DT><STRONG>identify</STRONG>
<DD><A HREF="#4415">identify</A>
 | <A HREF="#4468">idnew</A>
 | <A HREF="#4490">idold</A>
<DT><STRONG>idnew</STRONG>
<DD><A HREF="#4466">idnew</A>
<DT><STRONG>idold</STRONG>
<DD><A HREF="#4486">idold</A>
<DT><STRONG>if</STRONG>
<DD><A HREF="#3758">else</A>
 | <A HREF="#3774">elseif</A>
 | <A HREF="#3825">endif</A>
 | <A HREF="#4508">if</A>
 | <A HREF="#6202">replaceloop</A>
 | <A HREF="#10531">symbols</A>
 | <A HREF="#7081">while</A>
<DL COMPACT>
<DT><STRONG>count</STRONG>
<DD><A HREF="#10529">symbols</A>
</DL>
<DT><STRONG>if statement</STRONG>
<DD><A HREF="#3757">else</A>
 | <A HREF="#3773">elseif</A>
 | <A HREF="#3824">endif</A>
<DT><STRONG>ifmatch</STRONG>
<DD><A HREF="#8406">identify</A>
 | <A HREF="#8420">identify</A>
 | <A HREF="#4628">ifmatch</A>
 | <A HREF="#4789">label</A>
<DT><STRONG>ifnomatch</STRONG>
<DD><A HREF="#4648">ifnomatch</A>
<DT><STRONG>imaginary</STRONG>
<DD><A HREF="#288">Symbols</A>
 | <A HREF="#364">Functions</A>
 | <A HREF="#7667">cfunctions</A>
 | <A HREF="#8251">functions</A>
 | <A HREF="#10486">symbols</A>
 | <A HREF="#16685">A few notes on</A>
 | <A HREF="#16688">A few notes on</A>
<DT><STRONG>implode</STRONG>
<DD><A HREF="#10927">transform</A>
<DT><STRONG>improvement factor</STRONG>
<DD><A HREF="#18157">The parallel version</A>
<DT><STRONG>inactive</STRONG>
<DD><A HREF="#4910">metric</A>
<DT><STRONG>incdir</STRONG>
<DD><A HREF="#17416">The setup</A>
 | <A HREF="#17617">The setup</A>
<DT><STRONG>index</STRONG>
<DD><A HREF="#307">Vectors</A>
 | <A HREF="#325">Indices</A>
 | <A HREF="#7501">auto, autodeclare</A>
 | <A HREF="#4091">fixindex</A>
 | <A HREF="#4667">index, indices</A>
<DL COMPACT>
<DT><STRONG>bracket</STRONG>
<DD><A HREF="#15542">Brackets</A>
<DT><STRONG>contracted</STRONG>
<DD><A HREF="#6147">replaceloop</A>
<DT><STRONG>dummy</STRONG>
<DD><A HREF="#6461">sum</A>
 | <A HREF="#14939">Functions</A>
<DT><STRONG>main</STRONG>
<DD><A HREF="#16061">The TableBase</A>
<DT><STRONG>table</STRONG>
<DD><A HREF="#14321">Functions</A>
<DT><STRONG>trace line</STRONG>
<DD><A HREF="#6840">trace4</A>
</DL>
<DT><STRONG>index loop</STRONG>
<DD><A HREF="#8574">if</A>
 | <A HREF="#6144">replaceloop</A>
<DT><STRONG>index tree</STRONG>
<DD><A HREF="#15551">Brackets</A>
<DT><STRONG>index_</STRONG>
<DD><A HREF="#403">Sets</A>
 | <A HREF="#404">Sets</A>
<DT><STRONG>indices</STRONG>
<DD><A HREF="#324">Indices</A>
 | <A HREF="#7515">auto, autodeclare</A>
 | <A HREF="#3632">dimension</A>
 | <A HREF="#4668">index, indices</A>
<DL COMPACT>
<DT><STRONG>dummy</STRONG>
<DD><A HREF="#464">Dummy indices</A>
 | <A HREF="#3633">dimension</A>
 | <A HREF="#6089">renumber</A>
<DT><STRONG>fixed</STRONG>
<DD><A HREF="#335">Indices</A>
<DT><STRONG>lower</STRONG>
<DD><A HREF="#3467">contract</A>
 | <A HREF="#16661">A few notes on</A>
<DT><STRONG>numeric</STRONG>
<DD><A HREF="#336">Indices</A>
<DT><STRONG>renumber</STRONG>
<DD><A HREF="#474">Dummy indices</A>
<DT><STRONG>summable</STRONG>
<DD><A HREF="#345">Indices</A>
 | <A HREF="#16667">A few notes on</A>
<DT><STRONG>upper</STRONG>
<DD><A HREF="#3468">contract</A>
 | <A HREF="#16660">A few notes on</A>
</DL>
<DT><STRONG>individual expressions</STRONG>
<DD><A HREF="#5776">print</A>
<DT><STRONG>inexpression</STRONG>
<DD><A HREF="#3840">endinexpression</A>
 | <A HREF="#4689">inexpression</A>
<DT><STRONG>infinite loop</STRONG>
<DD><A HREF="#6121">repeat</A>
 | <A HREF="#7087">while</A>
<DT><STRONG>input</STRONG>
<DD><A HREF="#18202">TFORM</A>
<DL COMPACT>
<DT><STRONG>standard</STRONG>
<DD><A HREF="#1098">#external</A>
</DL>
<DT><STRONG>inside</STRONG>
<DD><A HREF="#3854">endinside</A>
 | <A HREF="#4721">inside</A>
<DT><STRONG>insidefirst</STRONG>
<DD><A HREF="#4739">insidefirst</A>
 | <A HREF="#17435">The setup</A>
<DT><STRONG>installation</STRONG>
<DD><A HREF="#16887">The setup</A>
<DT><STRONG>instance</STRONG>
<DD><A HREF="#994">#define</A>
<DT><STRONG>int_</STRONG>
<DD><A HREF="#391">Sets</A>
<DT><STRONG>integer_</STRONG>
<DD><A HREF="#14540">integer_</A>
<DT><STRONG>inverse_</STRONG>
<DD><A HREF="#14545">inverse_</A>
<DT><STRONG>invfac_</STRONG>
<DD><A HREF="#14549">invfac_</A>
<DT><STRONG>isdefined</STRONG>
<DD><A HREF="#1536">#if</A>
<DT><STRONG>isfactorized</STRONG>
<DD><A HREF="#1551">#if</A>
<DT><STRONG>islyndon</STRONG>
<DD><A HREF="#11013">transform</A>
<DT><STRONG>isnumerical</STRONG>
<DD><A HREF="#1564">#if</A>
<DT><STRONG>jumpratio</STRONG>
<DD><A HREF="#17449">The setup</A>
<DT><STRONG>Karlsruhe</STRONG>
<DD><A HREF="#18146">The parallel version</A>
<DT><STRONG>keep</STRONG>
<DD><A HREF="#4769">keep</A>
<DT><STRONG>keep brackets</STRONG>
<DD><A HREF="#4768">keep</A>
 | <A HREF="#15554">Brackets</A>
<DT><STRONG>kill</STRONG>
<DD><A HREF="#1326">#setexternalattr</A>
 | <A HREF="#18436">#setexternalattr</A>
<DT><STRONG>KILL signal</STRONG>
<DD><A HREF="#1305">#rmexternal</A>
 | <A HREF="#1342">#setexternalattr</A>
 | <A HREF="#18428">#rmexternal</A>
 | <A HREF="#18440">#setexternalattr</A>
 | <A HREF="#18453">#setexternalattr</A>
<DT><STRONG>killall</STRONG>
<DD><A HREF="#1328">#setexternalattr</A>
 | <A HREF="#18439">#setexternalattr</A>
<DT><STRONG>Knuth</STRONG>
<DD><A HREF="#16815">Sorting and statistics</A>
<DT><STRONG>Kronecker</STRONG>
<DD><A HREF="#333">Indices</A>
 | <A HREF="#499">Kronecker delta's</A>
 | <A HREF="#3458">contract</A>
 | <A HREF="#14385">d_</A>
 | <A HREF="#16664">A few notes on</A>
 | <A HREF="#16694">A few notes on</A>
<DT><STRONG>label</STRONG>
<DD><A HREF="#4360">goto</A>
 | <A HREF="#8413">identify</A>
 | <A HREF="#8427">identify</A>
 | <A HREF="#4786">label</A>
<DT><STRONG>large buffer</STRONG>
<DD><A HREF="#16811">Sorting and statistics</A>
 | <A HREF="#17131">The setup</A>
<DT><STRONG>largepatches</STRONG>
<DD><A HREF="#17134">The setup</A>
 | <A HREF="#17913">The setup</A>
<DT><STRONG>largesize</STRONG>
<DD><A HREF="#17133">The setup</A>
 | <A HREF="#17969">The setup</A>
<DT><STRONG>last</STRONG>
<DD><A HREF="#6890">transform</A>
<DT><STRONG>LCM</STRONG>
<DD><A HREF="#14476">factorin_</A>
<DT><STRONG>legal</STRONG>
<DD><A HREF="#526">Some common bugs</A>
<DT><STRONG>less than</STRONG>
<DD><A HREF="#840">The triple dot operator</A>
<DT><STRONG>Levi-Civita</STRONG>
<DD><A HREF="#3455">contract</A>
 | <A HREF="#16671">A few notes on</A>
<DT><STRONG>Levi-Civita tensor</STRONG>
<DD><A HREF="#14440">e_</A>
<DT><STRONG>li2_</STRONG>
<DD><A HREF="#14900">Extra reserved names</A>
<DT><STRONG>library</STRONG>
<DD><A HREF="#1249">#procedure</A>
<DL COMPACT>
<DT><STRONG>making a</STRONG>
<DD><A HREF="#1248">#procedure</A>
</DL>
<DT><STRONG>lin_</STRONG>
<DD><A HREF="#14906">Extra reserved names</A>
<DT><STRONG>linebreaks</STRONG>
<DD><A HREF="#10082">print</A>
<DT><STRONG>linefeed</STRONG>
<DD><A HREF="#917">#call</A>
 | <A HREF="#1440">#write</A>
 | <A HREF="#10213">print</A>
 | <A HREF="#5812">print</A>
<DT><STRONG>LINUX</STRONG>
<DD><A HREF="#18181">TFORM</A>
 | <A HREF="#18479">Embedding FORM in other</A>
<DT><STRONG>listed loop</STRONG>
<DD><A HREF="#1012">#do</A>
 | <A HREF="#1014">#do</A>
<DT><STRONG>lists</STRONG>
<DD><A HREF="#456">Name lists</A>
<DT><STRONG>ln_</STRONG>
<DD><A HREF="#14816">Extra reserved names</A>
<DT><STRONG>load</STRONG>
<DD><A HREF="#4820">load</A>
 | <A HREF="#6220">save</A>
 | <A HREF="#16062">The TableBase</A>
 | <A HREF="#16117">enter</A>
 | <A HREF="#16122">load</A>
<DT><STRONG>load balancing</STRONG>
<DD><A HREF="#18175">TFORM</A>
 | <A HREF="#18277">Some problems</A>
<DT><STRONG>loading dynamically</STRONG>
<DD><A HREF="#4072">fillexpression</A>
<DT><STRONG>local</STRONG>
<DD><A HREF="#4348">global</A>
 | <A HREF="#4804">lfactorized</A>
 | <A HREF="#4839">local</A>
<DT><STRONG>lock</STRONG>
<DD><A HREF="#18257">Some problems</A>
<DT><STRONG>log</STRONG>
<DD><A HREF="#187">Running FORM</A>
 | <A HREF="#10015">print</A>
 | <A HREF="#10030">print</A>
 | <A HREF="#5871">printtable</A>
<DT><STRONG>logical</STRONG>
<DD><A HREF="#1125">#if</A>
<DT><STRONG>loop</STRONG>
<DD><A HREF="#6059">redefine</A>
<DL COMPACT>
<DT><STRONG>index</STRONG>
<DD><A HREF="#6145">replaceloop</A>
<DT><STRONG>infinite</STRONG>
<DD><A HREF="#6122">repeat</A>
<DT><STRONG>listed</STRONG>
<DD><A HREF="#1013">#do</A>
 | <A HREF="#1015">#do</A>
<DT><STRONG>numerical</STRONG>
<DD><A HREF="#1018">#do</A>
<DT><STRONG>while</STRONG>
<DD><A HREF="#6060">redefine</A>
</DL>
<DT><STRONG>loops</STRONG>
<DD><DL COMPACT>
<DT><STRONG>infinite</STRONG>
<DD><A HREF="#7088">while</A>
</DL>
<DT><STRONG>loopsize</STRONG>
<DD><A HREF="#10373">replaceloop</A>
 | <A HREF="#6179">replaceloop</A>
<DT><STRONG>lower</STRONG>
<DD><A HREF="#3466">contract</A>
<DT><STRONG>lowfirst</STRONG>
<DD><A HREF="#17724">The setup</A>
<DT><STRONG>Lyndon word</STRONG>
<DD><A HREF="#11020">transform</A>
 | <A HREF="#11035">transform</A>
<DT><STRONG>macro</STRONG>
<DD><A HREF="#1002">#define</A>
<DT><STRONG>makeinteger</STRONG>
<DD><A HREF="#4858">makeinteger</A>
 | <A HREF="#15568">Brackets</A>
<DT><STRONG>makerational_</STRONG>
<DD><A HREF="#14554">makerational_</A>
<DT><STRONG>many</STRONG>
<DD><A HREF="#8348">identify</A>
 | <A HREF="#8528">if</A>
 | <A HREF="#4884">many</A>
<DT><STRONG>maple</STRONG>
<DD><A HREF="#8153">format</A>
<DT><STRONG>master</STRONG>
<DD><A HREF="#6715">threadbucketsize</A>
 | <A HREF="#16712">A few notes on</A>
 | <A HREF="#18150">The parallel version</A>
 | <A HREF="#18166">TFORM</A>
<DT><STRONG>match</STRONG>
<DD><A HREF="#8518">if</A>
<DT><STRONG>match_</STRONG>
<DD><A HREF="#14560">match_</A>
<DT><STRONG>mathematica</STRONG>
<DD><A HREF="#8167">format</A>
<DT><STRONG>matrices</STRONG>
<DD><DL COMPACT>
<DT><STRONG>gamma</STRONG>
<DD><A HREF="#350">Indices</A>
 | <A HREF="#16670">A few notes on</A>
</DL>
<DT><STRONG>matrix</STRONG>
<DD><DL COMPACT>
<DT><STRONG>unit</STRONG>
<DD><A HREF="#7051">unittrace</A>
</DL>
<DT><STRONG>matrix like</STRONG>
<DD><A HREF="#6612">table</A>
<DT><STRONG>max_</STRONG>
<DD><A HREF="#14564">max_</A>
<DT><STRONG>maxnumbersize</STRONG>
<DD><A HREF="#17464">The setup</A>
<DT><STRONG>maxpowerof</STRONG>
<DD><A HREF="#1577">#if</A>
<DT><STRONG>maxpowerof_</STRONG>
<DD><A HREF="#14568">maxpowerof_</A>
<DT><STRONG>maxtermsize</STRONG>
<DD><A HREF="#3396">collect</A>
 | <A HREF="#17481">The setup</A>
 | <A HREF="#17687">The setup</A>
 | <A HREF="#17709">The setup</A>
<DT><STRONG>maxwildcards</STRONG>
<DD><A HREF="#17500">The setup</A>
<DT><STRONG>MCTS</STRONG>
<DD><A HREF="#15680">Optimization options of the</A>
 | <A HREF="#15684">Optimization options of the</A>
<DT><STRONG>memory</STRONG>
<DD><A HREF="#2575">Modules</A>
<DL COMPACT>
<DT><STRONG>total amount of</STRONG>
<DD><A HREF="#518">Restrictions</A>
</DL>
<DT><STRONG>merge</STRONG>
<DD><A HREF="#6288">shuffle</A>
<DT><STRONG>metric</STRONG>
<DD><A HREF="#4099">fixindex</A>
 | <A HREF="#4909">metric</A>
 | <A HREF="#16656">A few notes on</A>
 | <A HREF="#16690">A few notes on</A>
<DT><STRONG>min_</STRONG>
<DD><A HREF="#14574">min_</A>
<DT><STRONG>mincer</STRONG>
<DD><A HREF="#4775">keep</A>
<DT><STRONG>minpowerof</STRONG>
<DD><A HREF="#1591">#if</A>
<DT><STRONG>minpowerof_</STRONG>
<DD><A HREF="#14578">minpowerof_</A>
<DT><STRONG>mixed statements</STRONG>
<DD><A HREF="#2585">Modules</A>
<DT><STRONG>mod2_</STRONG>
<DD><A HREF="#14590">mod2_</A>
<DT><STRONG>mod_</STRONG>
<DD><A HREF="#14582">mod_</A>
<DT><STRONG>mode</STRONG>
<DD><DL COMPACT>
<DT><STRONG>single term</STRONG>
<DD><A HREF="#10045">print</A>
</DL>
<DT><STRONG>module</STRONG>
<DD><A HREF="#726">The preprocessor</A>
 | <A HREF="#2569">Modules</A>
 | <A HREF="#2638">Checkpoints</A>
<DT><STRONG>module instruction</STRONG>
<DD><A HREF="#2573">Modules</A>
<DT><STRONG>module number</STRONG>
<DD><A HREF="#2649">Checkpoints</A>
<DT><STRONG>moduleoption</STRONG>
<DD><A HREF="#2608">Modules</A>
 | <A HREF="#2923">Dollar variables in a</A>
 | <A HREF="#4707">inparallel</A>
 | <A HREF="#4925">moduleoption</A>
<DL COMPACT>
<DT><STRONG>inparallel</STRONG>
<DD><A HREF="#8814">moduleoption</A>
<DT><STRONG>local</STRONG>
<DD><A HREF="#8887">moduleoption</A>
 | <A HREF="#18267">Some problems</A>
<DT><STRONG>maximum</STRONG>
<DD><A HREF="#8903">moduleoption</A>
 | <A HREF="#18264">Some problems</A>
<DT><STRONG>minimum</STRONG>
<DD><A HREF="#8917">moduleoption</A>
 | <A HREF="#18265">Some problems</A>
<DT><STRONG>noparallel</STRONG>
<DD><A HREF="#8800">moduleoption</A>
<DT><STRONG>notinparallel</STRONG>
<DD><A HREF="#8828">moduleoption</A>
<DT><STRONG>parallel</STRONG>
<DD><A HREF="#8786">moduleoption</A>
<DT><STRONG>polyfun</STRONG>
<DD><A HREF="#8842">moduleoption</A>
 | <A HREF="#8857">moduleoption</A>
<DT><STRONG>processbucketsize</STRONG>
<DD><A HREF="#8872">moduleoption</A>
 | <A HREF="#18218">ParFORM</A>
<DT><STRONG>sum</STRONG>
<DD><A HREF="#8931">moduleoption</A>
 | <A HREF="#18266">Some problems</A>
</DL>
<DT><STRONG>modulus</STRONG>
<DD><A HREF="#4987">modulus</A>
<DT><STRONG>moebius_</STRONG>
<DD><A HREF="#14595">moebius_</A>
<DT><STRONG>Monte Carlo tree search</STRONG>
<DD><A HREF="#15681">Optimization options of the</A>
 | <A HREF="#15685">Optimization options of the</A>
<DT><STRONG>mountains</STRONG>
<DD><A HREF="#16709">A few notes on</A>
<DT><STRONG>MPI</STRONG>
<DD><A HREF="#18144">The parallel version</A>
 | <A HREF="#18153">The parallel version</A>
 | <A HREF="#18207">ParFORM</A>
<DT><STRONG>mpirun</STRONG>
<DD><A HREF="#18208">ParFORM</A>
<DT><STRONG>MS-DOS</STRONG>
<DD><A HREF="#1284">#remove</A>
<DT><STRONG>mul_</STRONG>
<DD><A HREF="#14604">mul_</A>
<DT><STRONG>mulargs</STRONG>
<DD><A HREF="#11057">transform</A>
<DT><STRONG>multi</STRONG>
<DD><A HREF="#8334">identify</A>
 | <A HREF="#8527">if</A>
 | <A HREF="#5002">multi</A>
 | <A HREF="#5029">multiply</A>
<DT><STRONG>Multiple  Zeta Value</STRONG>
<DD><A HREF="#6975">transform</A>
<DT><STRONG>multiple zeta value</STRONG>
<DD><A HREF="#6302">shuffle</A>
<DT><STRONG>multiple zeta values</STRONG>
<DD><A HREF="#3084">argimplode</A>
<DT><STRONG>multipleof</STRONG>
<DD><A HREF="#8582">if</A>
<DT><STRONG>multiplication</STRONG>
<DD><A HREF="#802">The preprocessor calculator</A>
<DT><STRONG>multiply</STRONG>
<DD><A HREF="#5020">multiply</A>
 | <A HREF="#6326">skip</A>
<DL COMPACT>
<DT><STRONG>left</STRONG>
<DD><A HREF="#8950">multiply</A>
<DT><STRONG>right</STRONG>
<DD><A HREF="#8963">multiply</A>
</DL>
<DT><STRONG>MZV</STRONG>
<DD><A HREF="#6303">shuffle</A>
 | <A HREF="#6976">transform</A>
<DT><STRONG>MZV data mine</STRONG>
<DD><A HREF="#6979">transform</A>
<DT><STRONG>NAME_</STRONG>
<DD><A HREF="#749">The preprocessor variables</A>
 | <A HREF="#1358">#show</A>
<DT><STRONG>names</STRONG>
<DD><A HREF="#253">Names</A>
<DL COMPACT>
<DT><STRONG>definition</STRONG>
<DD><A HREF="#254">Names</A>
<DT><STRONG>length</STRONG>
<DD><A HREF="#277">Names</A>
</DL>
<DT><STRONG>nargs_</STRONG>
<DD><A HREF="#14609">nargs_</A>
<DT><STRONG>ndrop</STRONG>
<DD><A HREF="#5041">ndrop</A>
<DT><STRONG>neg0_</STRONG>
<DD><A HREF="#399">Sets</A>
<DT><STRONG>neg_</STRONG>
<DD><A HREF="#397">Sets</A>
<DT><STRONG>nested</STRONG>
<DD><A HREF="#1392">#switch</A>
 | <A HREF="#6132">repeat</A>
 | <A HREF="#6690">term</A>
<DT><STRONG>nesting</STRONG>
<DD><A HREF="#742">The preprocessor variables</A>
<DT><STRONG>newline</STRONG>
<DD><A HREF="#1435">#write</A>
 | <A HREF="#18408">#toexternal</A>
<DT><STRONG>nfunction</STRONG>
<DD><A HREF="#5072">nfunctions</A>
<DT><STRONG>nhide</STRONG>
<DD><A HREF="#4394">hide</A>
 | <A HREF="#5090">nhide</A>
<DT><STRONG>non-commuting</STRONG>
<DD><A HREF="#361">Functions</A>
<DT><STRONG>noncommuting</STRONG>
<DD><A HREF="#2744">Pattern matching</A>
 | <A HREF="#7529">auto, autodeclare</A>
 | <A HREF="#4246">functions</A>
 | <A HREF="#8441">identify</A>
 | <A HREF="#5073">nfunctions</A>
 | <A HREF="#5189">ntable</A>
 | <A HREF="#5206">ntensors</A>
 | <A HREF="#6608">table</A>
 | <A HREF="#6669">tensors</A>
 | <A HREF="#14316">Functions</A>
<DT><STRONG>nondeterministic</STRONG>
<DD><A HREF="#2918">Dollar variables in a</A>
<DT><STRONG>normal</STRONG>
<DD><A HREF="#8195">format</A>
<DT><STRONG>normalization</STRONG>
<DD><A HREF="#10515">symbols</A>
<DT><STRONG>normalize</STRONG>
<DD><A HREF="#4861">makeinteger</A>
 | <A HREF="#5110">normalize</A>
 | <A HREF="#15566">Brackets</A>
<DT><STRONG>nospaces</STRONG>
<DD><A HREF="#7965">format</A>
<DT><STRONG>nospacesinnumbers</STRONG>
<DD><A HREF="#17514">The setup</A>
<DT><STRONG>nosymmetrize</STRONG>
<DD><A HREF="#16532">Dirac algebra</A>
<DT><STRONG>notation</STRONG>
<DD><DL COMPACT>
<DT><STRONG>ambiguous</STRONG>
<DD><A HREF="#347">Indices</A>
</DL>
<DT><STRONG>nprint</STRONG>
<DD><A HREF="#5156">nprint</A>
<DT><STRONG>nskip</STRONG>
<DD><A HREF="#5169">nskip</A>
 | <A HREF="#6321">skip</A>
<DT><STRONG>ntable</STRONG>
<DD><A HREF="#5188">ntable</A>
 | <A HREF="#6609">table</A>
<DT><STRONG>ntensor</STRONG>
<DD><A HREF="#5205">ntensors</A>
 | <A HREF="#6670">tensors</A>
<DT><STRONG>nterms_</STRONG>
<DD><A HREF="#14618">nterms_</A>
<DT><STRONG>num_</STRONG>
<DD><A HREF="#300">Symbols</A>
<DT><STRONG>number of FORMwords</STRONG>
<DD><A HREF="#14747">sizeof_</A>
<DT><STRONG>number of terms</STRONG>
<DD><A HREF="#14786">termsin_</A>
<DT><STRONG>number_</STRONG>
<DD><A HREF="#405">Sets</A>
<DT><STRONG>numerical loop</STRONG>
<DD><A HREF="#1017">#do</A>
<DT><STRONG>numerical output</STRONG>
<DD><A HREF="#16376">Dictionaries</A>
<DT><STRONG>numerical processing</STRONG>
<DD><A HREF="#15640">Output optimization</A>
<DT><STRONG>numfactors_</STRONG>
<DD><A HREF="#14622">numfactors_</A>
<DT><STRONG>numstorecaches</STRONG>
<DD><A HREF="#17534">The setup</A>
 | <A HREF="#17708">The setup</A>
<DT><STRONG>nunhide</STRONG>
<DD><A HREF="#5241">nunhide</A>
<DT><STRONG>nwrite</STRONG>
<DD><A HREF="#5259">nwrite</A>
<DL COMPACT>
<DT><STRONG>allnames</STRONG>
<DD><A HREF="#9124">nwrite</A>
<DT><STRONG>allwarnings</STRONG>
<DD><A HREF="#9085">nwrite</A>
<DT><STRONG>highfirst</STRONG>
<DD><A HREF="#9150">nwrite</A>
<DT><STRONG>lowfirst</STRONG>
<DD><A HREF="#9163">nwrite</A>
<DT><STRONG>names</STRONG>
<DD><A HREF="#9111">nwrite</A>
<DT><STRONG>powerfirst</STRONG>
<DD><A HREF="#9176">nwrite</A>
<DT><STRONG>setup</STRONG>
<DD><A HREF="#9098">nwrite</A>
<DT><STRONG>shortstatistics</STRONG>
<DD><A HREF="#9059">nwrite</A>
<DT><STRONG>shortstats</STRONG>
<DD><A HREF="#9046">nwrite</A>
 | <A HREF="#9137">nwrite</A>
<DT><STRONG>statistics</STRONG>
<DD><A HREF="#9033">nwrite</A>
<DT><STRONG>stats</STRONG>
<DD><A HREF="#9020">nwrite</A>
<DT><STRONG>warnings</STRONG>
<DD><A HREF="#9072">nwrite</A>
</DL>
<DT><STRONG>nwritestatistics</STRONG>
<DD><A HREF="#17548">The setup</A>
<DT><STRONG>nwritethreadstatistics</STRONG>
<DD><A HREF="#17562">The setup</A>
<DT><STRONG>obsolete</STRONG>
<DD><A HREF="#2607">Modules</A>
 | <A HREF="#4303">funpowers</A>
 | <A HREF="#4740">insidefirst</A>
 | <A HREF="#5260">nwrite</A>
 | <A HREF="#5929">propercount</A>
 | <A HREF="#7105">write</A>
<DT><STRONG>occurrence order</STRONG>
<DD><A HREF="#15679">Optimization options of the</A>
<DT><STRONG>odd_</STRONG>
<DD><A HREF="#408">Sets</A>
<DT><STRONG>off</STRONG>
<DD><A HREF="#2633">Checkpoints</A>
 | <A HREF="#4306">funpowers</A>
 | <A HREF="#5261">nwrite</A>
 | <A HREF="#5335">off</A>
 | <A HREF="#5932">propercount</A>
 | <A HREF="#7108">write</A>
 | <A HREF="#16130">off</A>
<DL COMPACT>
<DT><STRONG>allnames</STRONG>
<DD><A HREF="#9189">off</A>
<DT><STRONG>allwarnings</STRONG>
<DD><A HREF="#9202">off</A>
<DT><STRONG>checkpoint</STRONG>
<DD><A HREF="#9215">off</A>
<DT><STRONG>compress</STRONG>
<DD><A HREF="#9229">off</A>
<DT><STRONG>finalstats</STRONG>
<DD><A HREF="#9242">off</A>
<DT><STRONG>highfirst</STRONG>
<DD><A HREF="#9255">off</A>
<DT><STRONG>insidefirst</STRONG>
<DD><A HREF="#9268">off</A>
<DT><STRONG>lowfirst</STRONG>
<DD><A HREF="#9281">off</A>
<DT><STRONG>names</STRONG>
<DD><A HREF="#9294">off</A>
<DT><STRONG>nospacesinnumbers</STRONG>
<DD><A HREF="#9307">off</A>
<DT><STRONG>oldfactarg</STRONG>
<DD><A HREF="#9325">off</A>
<DT><STRONG>parallel</STRONG>
<DD><A HREF="#9341">off</A>
 | <A HREF="#18223">ParFORM</A>
<DT><STRONG>powerfirst</STRONG>
<DD><A HREF="#9355">off</A>
<DT><STRONG>processstats</STRONG>
<DD><A HREF="#9368">off</A>
<DT><STRONG>propercount</STRONG>
<DD><A HREF="#9385">off</A>
<DT><STRONG>properorder</STRONG>
<DD><A HREF="#9398">off</A>
<DT><STRONG>setup</STRONG>
<DD><A HREF="#9411">off</A>
<DT><STRONG>shortstatistics</STRONG>
<DD><A HREF="#9463">off</A>
<DT><STRONG>shortstats</STRONG>
<DD><A HREF="#9450">off</A>
<DT><STRONG>statistics</STRONG>
<DD><A HREF="#9437">off</A>
<DT><STRONG>stats</STRONG>
<DD><A HREF="#9424">off</A>
<DT><STRONG>threadloadbalancing</STRONG>
<DD><A HREF="#9476">off</A>
<DT><STRONG>threads</STRONG>
<DD><A HREF="#9492">off</A>
 | <A HREF="#18185">TFORM</A>
<DT><STRONG>threadstats</STRONG>
<DD><A HREF="#9507">off</A>
<DT><STRONG>totalsize</STRONG>
<DD><A HREF="#9522">off</A>
<DT><STRONG>warnings</STRONG>
<DD><A HREF="#9536">off</A>
<DT><STRONG>wtimestats</STRONG>
<DD><A HREF="#9549">off</A>
</DL>
<DT><STRONG>old notation</STRONG>
<DD><A HREF="#743">The preprocessor variables</A>
<DT><STRONG>OLDNUMEXTRASYMBOLS_</STRONG>
<DD><A HREF="#755">The preprocessor variables</A>
<DT><STRONG>oldorder</STRONG>
<DD><A HREF="#17579">The setup</A>
<DT><STRONG>on</STRONG>
<DD><A HREF="#2631">Checkpoints</A>
 | <A HREF="#4304">funpowers</A>
 | <A HREF="#5263">nwrite</A>
 | <A HREF="#5930">propercount</A>
 | <A HREF="#7106">write</A>
 | <A HREF="#16137">on</A>
 | <A HREF="#17727">The setup</A>
<DL COMPACT>
<DT><STRONG>allnames</STRONG>
<DD><A HREF="#9562">on</A>
<DT><STRONG>allwarnings</STRONG>
<DD><A HREF="#9575">on</A>
<DT><STRONG>checkpoint</STRONG>
<DD><A HREF="#9588">on</A>
<DT><STRONG>compress</STRONG>
<DD><A HREF="#9603">on</A>
<DT><STRONG>fewerstatistics</STRONG>
<DD><A HREF="#9629">on</A>
<DT><STRONG>fewerstats</STRONG>
<DD><A HREF="#9643">on</A>
<DT><STRONG>finalstats</STRONG>
<DD><A HREF="#9656">on</A>
<DT><STRONG>highfirst</STRONG>
<DD><A HREF="#9670">on</A>
<DT><STRONG>insidefirst</STRONG>
<DD><A HREF="#9683">on</A>
<DT><STRONG>lowfirst</STRONG>
<DD><A HREF="#9696">on</A>
<DT><STRONG>names</STRONG>
<DD><A HREF="#9709">on</A>
<DT><STRONG>nospacesinnumbers</STRONG>
<DD><A HREF="#9722">on</A>
<DT><STRONG>oldfactarg</STRONG>
<DD><A HREF="#9740">on</A>
<DT><STRONG>parallel</STRONG>
<DD><A HREF="#9756">on</A>
 | <A HREF="#18222">ParFORM</A>
<DT><STRONG>powerfirst</STRONG>
<DD><A HREF="#9770">on</A>
<DT><STRONG>processstats</STRONG>
<DD><A HREF="#9783">on</A>
 | <A HREF="#18232">ParFORM</A>
 | <A HREF="#18233">ParFORM</A>
<DT><STRONG>propercount</STRONG>
<DD><A HREF="#9798">on</A>
<DT><STRONG>properorder</STRONG>
<DD><A HREF="#9811">on</A>
<DT><STRONG>setup</STRONG>
<DD><A HREF="#9826">on</A>
<DT><STRONG>shortstatistics</STRONG>
<DD><A HREF="#9839">on</A>
<DT><STRONG>shortstats</STRONG>
<DD><A HREF="#9852">on</A>
<DT><STRONG>statistics</STRONG>
<DD><A HREF="#9865">on</A>
<DT><STRONG>stats</STRONG>
<DD><A HREF="#9879">on</A>
<DT><STRONG>threadloadbalancing</STRONG>
<DD><A HREF="#9892">on</A>
<DT><STRONG>threads</STRONG>
<DD><A HREF="#9908">on</A>
 | <A HREF="#18184">TFORM</A>
<DT><STRONG>threadstats</STRONG>
<DD><A HREF="#9923">on</A>
 | <A HREF="#18194">TFORM</A>
 | <A HREF="#18195">TFORM</A>
<DT><STRONG>totalsize</STRONG>
<DD><A HREF="#9937">on</A>
<DT><STRONG>warnings</STRONG>
<DD><A HREF="#9956">on</A>
<DT><STRONG>wtimestats</STRONG>
<DD><A HREF="#9969">on</A>
</DL>
<DT><STRONG>once</STRONG>
<DD><A HREF="#8376">identify</A>
 | <A HREF="#8525">if</A>
 | <A HREF="#5611">once</A>
<DT><STRONG>only</STRONG>
<DD><A HREF="#8393">identify</A>
 | <A HREF="#8526">if</A>
 | <A HREF="#5630">only</A>
<DT><STRONG>open</STRONG>
<DD><A HREF="#16055">The TableBase</A>
 | <A HREF="#16108">create</A>
 | <A HREF="#16144">open</A>
<DT><STRONG>opteron</STRONG>
<DD><A HREF="#18159">The parallel version</A>
<DT><STRONG>optimization buffer</STRONG>
<DD><A HREF="#15659">Output optimization</A>
 | <A HREF="#15664">Output optimization</A>
<DT><STRONG>optimize</STRONG>
<DD><A HREF="#7993">format</A>
 | <A HREF="#8009">format</A>
 | <A HREF="#8025">format</A>
 | <A HREF="#8041">format</A>
<DT><STRONG>OPTIMMAXVAR_</STRONG>
<DD><A HREF="#759">The preprocessor variables</A>
 | <A HREF="#15653">Output optimization</A>
 | <A HREF="#15661">Output optimization</A>
<DT><STRONG>OPTIMMINVAR_</STRONG>
<DD><A HREF="#757">The preprocessor variables</A>
 | <A HREF="#15652">Output optimization</A>
 | <A HREF="#15660">Output optimization</A>
<DT><STRONG>OPTIMSCHEME_</STRONG>
<DD><A HREF="#761">The preprocessor variables</A>
 | <A HREF="#15674">Optimization options of the</A>
<DT><STRONG>OPTIMVALUE_</STRONG>
<DD><A HREF="#763">The preprocessor variables</A>
 | <A HREF="#15675">Optimization options of the</A>
<DT><STRONG>option</STRONG>
<DD><DL COMPACT>
<DT><STRONG>disorder</STRONG>
<DD><A HREF="#3684">disorder</A>
<DT><STRONG>select</STRONG>
<DD><A HREF="#423">Sets</A>
</DL>
<DT><STRONG>or</STRONG>
<DD><A HREF="#807">The preprocessor calculator</A>
<DT><STRONG>order of terms</STRONG>
<DD><A HREF="#18253">Some problems</A>
<DT><STRONG>ordered set</STRONG>
<DD><A HREF="#6265">set</A>
<DT><STRONG>output</STRONG>
<DD><DL COMPACT>
<DT><STRONG>standard</STRONG>
<DD><A HREF="#1099">#external</A>
</DL>
<DT><STRONG>output channel</STRONG>
<DD><A HREF="#1429">#write</A>
<DT><STRONG>output specifications</STRONG>
<DD><A HREF="#2583">Modules</A>
<DT><STRONG>overflow</STRONG>
<DD><A HREF="#4045">fill</A>
<DT><STRONG>overwrite</STRONG>
<DD><A HREF="#10278">printtable</A>
<DT><STRONG>package</STRONG>
<DD><DL COMPACT>
<DT><STRONG>color</STRONG>
<DD><A HREF="#6198">replaceloop</A>
</DL>
<DT><STRONG>parallel</STRONG>
<DD><A HREF="#8793">moduleoption</A>
 | <A HREF="#8807">moduleoption</A>
 | <A HREF="#5913">processbucketsize</A>
<DT><STRONG>parallel execution</STRONG>
<DD><A HREF="#4975">moduleoption</A>
<DT><STRONG>parallel processing</STRONG>
<DD><A HREF="#2915">Dollar variables in a</A>
<DT><STRONG>parentheses</STRONG>
<DD><A HREF="#15522">Brackets</A>
 | <A HREF="#17593">The setup</A>
<DT><STRONG>ParFORM</STRONG>
<DD><A HREF="#2916">Dollar variables in a</A>
 | <A HREF="#5912">processbucketsize</A>
 | <A HREF="#18143">The parallel version</A>
 | <A HREF="#18206">ParFORM</A>
 | <A HREF="#18686">Spectators</A>
<DT><STRONG>partial fractioning</STRONG>
<DD><A HREF="#5978">ratio</A>
<DT><STRONG>partitions_</STRONG>
<DD><A HREF="#14628">partitions_</A>
<DT><STRONG>patch</STRONG>
<DD><A HREF="#16813">Sorting and statistics</A>
 | <A HREF="#17135">The setup</A>
<DT><STRONG>path</STRONG>
<DD><A HREF="#885">#appendpath</A>
 | <A HREF="#911">#call</A>
 | <A HREF="#1193">#include</A>
 | <A HREF="#1233">#prependpath</A>
 | <A HREF="#1335">#setexternalattr</A>
 | <A HREF="#17426">The setup</A>
 | <A HREF="#17607">The setup</A>
 | <A HREF="#17123">The setup</A>
 | <A HREF="#18446">#setexternalattr</A>
<DL COMPACT>
<DT><STRONG>search</STRONG>
<DD><A HREF="#18445">#setexternalattr</A>
</DL>
<DT><STRONG>pattern</STRONG>
<DD><A HREF="#853">The triple dot operator</A>
 | <A HREF="#2735">Pattern matching</A>
 | <A HREF="#4416">identify</A>
<DT><STRONG>pattern matcher</STRONG>
<DD><A HREF="#8531">if</A>
<DT><STRONG>pattern matching</STRONG>
<DD><A HREF="#425">Sets</A>
 | <A HREF="#2734">Pattern matching</A>
<DT><STRONG>pattern_</STRONG>
<DD><A HREF="#14640">pattern_</A>
<DT><STRONG>pentium</STRONG>
<DD><A HREF="#18158">The parallel version</A>
<DT><STRONG>percentage</STRONG>
<DD><A HREF="#3403">collect</A>
<DT><STRONG>period</STRONG>
<DD><A HREF="#267">Names</A>
 | <A HREF="#2572">Modules</A>
<DT><STRONG>perm_</STRONG>
<DD><A HREF="#14644">perm_</A>
<DT><STRONG>permutation</STRONG>
<DD><A HREF="#6587">symmetrize</A>
<DT><STRONG>permutations</STRONG>
<DD><A HREF="#6040">rcyclesymmetrize</A>
 | <A HREF="#10322">renumber</A>
<DT><STRONG>permute</STRONG>
<DD><A HREF="#10957">transform</A>
<DT><STRONG>pi_</STRONG>
<DD><A HREF="#298">Symbols</A>
<DT><STRONG>PID</STRONG>
<DD><A HREF="#765">The preprocessor variables</A>
 | <A HREF="#18483">Embedding FORM in other</A>
<DT><STRONG>PID_</STRONG>
<DD><A HREF="#766">The preprocessor variables</A>
<DT><STRONG>pipe</STRONG>
<DD><A HREF="#1223">#pipe</A>
 | <A HREF="#18478">Embedding FORM in other</A>
<DT><STRONG>PIPE1_</STRONG>
<DD><A HREF="#18465">Embedding FORM in other</A>
<DT><STRONG>PIPE2_</STRONG>
<DD><A HREF="#18466">Embedding FORM in other</A>
<DT><STRONG>pipelined job</STRONG>
<DD><A HREF="#1333">#setexternalattr</A>
<DT><STRONG>PIPES_</STRONG>
<DD><A HREF="#18464">Embedding FORM in other</A>
 | <A HREF="#18467">Embedding FORM in other</A>
<DT><STRONG>poly_</STRONG>
<DD><A HREF="#14650">poly_</A>
<DT><STRONG>polyadd_</STRONG>
<DD><A HREF="#14653">poly_</A>
<DT><STRONG>polydiv_</STRONG>
<DD><A HREF="#14420">div_</A>
 | <A HREF="#14655">poly_</A>
<DT><STRONG>polyfun</STRONG>
<DD><A HREF="#2612">Modules</A>
 | <A HREF="#8849">moduleoption</A>
 | <A HREF="#5647">polyfun</A>
 | <A HREF="#15570">Brackets</A>
 | <A HREF="#16807">Sorting and statistics</A>
<DT><STRONG>polygcd_</STRONG>
<DD><A HREF="#14516">gcd_</A>
 | <A HREF="#14657">poly_</A>
 | <A HREF="#15986">Polynomials and Factorization</A>
<DT><STRONG>polyintfac_</STRONG>
<DD><A HREF="#14659">poly_</A>
<DT><STRONG>polylogarithms</STRONG>
<DD><DL COMPACT>
<DT><STRONG>harmonic</STRONG>
<DD><A HREF="#3082">argimplode</A>
</DL>
<DT><STRONG>polymul_</STRONG>
<DD><A HREF="#14661">poly_</A>
<DT><STRONG>polynorm_</STRONG>
<DD><A HREF="#14663">poly_</A>
<DT><STRONG>polyratfun</STRONG>
<DD><A HREF="#3619">denominators</A>
 | <A HREF="#8864">moduleoption</A>
 | <A HREF="#5672">polyratfun</A>
 | <A HREF="#18682">Spectators</A>
<DT><STRONG>polyrem_</STRONG>
<DD><A HREF="#14665">poly_</A>
 | <A HREF="#14712">rem_</A>
<DT><STRONG>polysub_</STRONG>
<DD><A HREF="#14667">poly_</A>
<DT><STRONG>pophide</STRONG>
<DD><A HREF="#5702">pophide</A>
 | <A HREF="#5949">pushhide</A>
<DT><STRONG>pos0_</STRONG>
<DD><A HREF="#395">Sets</A>
<DT><STRONG>pos_</STRONG>
<DD><A HREF="#393">Sets</A>
<DT><STRONG>POSIX</STRONG>
<DD><A HREF="#18155">The parallel version</A>
<DT><STRONG>pow</STRONG>
<DD><A HREF="#8143">format</A>
<DT><STRONG>power series</STRONG>
<DD><A HREF="#2620">Modules</A>
<DT><STRONG>powerfirst</STRONG>
<DD><A HREF="#17726">The setup</A>
<DT><STRONG>pre-opened external channels</STRONG>
<DD><A HREF="#18462">Embedding FORM in other</A>
<DT><STRONG>precedence</STRONG>
<DD><A HREF="#16891">The setup</A>
<DT><STRONG>premature</STRONG>
<DD><A HREF="#6128">repeat</A>
<DT><STRONG>preprocessor</STRONG>
<DD><A HREF="#723">The preprocessor</A>
<DT><STRONG>preprocessor variable</STRONG>
<DD><A HREF="#991">#define</A>
 | <A HREF="#1271">#redefine</A>
<DL COMPACT>
<DT><STRONG>numeric</STRONG>
<DD><A HREF="#788">The preprocessor calculator</A>
</DL>
<DT><STRONG>preprocessor variables</STRONG>
<DD><A HREF="#739">The preprocessor variables</A>
 | <A HREF="#6054">redefine</A>
 | <A HREF="#16894">The setup</A>
<DT><STRONG>prime_</STRONG>
<DD><A HREF="#14674">prime_</A>
<DT><STRONG>print</STRONG>
<DD><A HREF="#5157">nprint</A>
 | <A HREF="#5727">print</A>
 | <A HREF="#5830">print[&nbsp;]</A>
 | <A HREF="#5868">printtable</A>
 | <A HREF="#18197">TFORM</A>
 | <A HREF="#18235">ParFORM</A>
<DL COMPACT>
<DT><STRONG>%$</STRONG>
<DD><A HREF="#10169">print</A>
<DT><STRONG>%%</STRONG>
<DD><A HREF="#10182">print</A>
<DT><STRONG>%t</STRONG>
<DD><A HREF="#10115">print</A>
 | <A HREF="#10128">print</A>
<DT><STRONG>%w</STRONG>
<DD><A HREF="#10141">print</A>
 | <A HREF="#10155">print</A>
</DL>
<DT><STRONG>print[]</STRONG>
<DD><A HREF="#5831">print[&nbsp;]</A>
<DT><STRONG>printf</STRONG>
<DD><A HREF="#5778">print</A>
<DT><STRONG>printing</STRONG>
<DD><A HREF="#4112">format</A>
<DT><STRONG>printtable</STRONG>
<DD><A HREF="#5865">printtable</A>
<DT><STRONG>private</STRONG>
<DD><A HREF="#18201">TFORM</A>
<DT><STRONG>procedure</STRONG>
<DD><A HREF="#908">#call</A>
 | <A HREF="#1077">#endprocedure</A>
 | <A HREF="#1244">#procedure</A>
<DT><STRONG>procedureextension</STRONG>
<DD><A HREF="#17627">The setup</A>
<DT><STRONG>process</STRONG>
<DD><DL COMPACT>
<DT><STRONG>external</STRONG>
<DD><A HREF="#18392">External communication</A>
</DL>
<DT><STRONG>processbucketsize</STRONG>
<DD><A HREF="#8879">moduleoption</A>
 | <A HREF="#5911">processbucketsize</A>
 | <A HREF="#17644">The setup</A>
 | <A HREF="#18216">ParFORM</A>
<DT><STRONG>processor</STRONG>
<DD><A HREF="#8895">moduleoption</A>
<DT><STRONG>prompt</STRONG>
<DD><A HREF="#1110">#fromexternal</A>
 | <A HREF="#1265">#prompt</A>
<DT><STRONG>propagator</STRONG>
<DD><A HREF="#16669">A few notes on</A>
<DT><STRONG>propercount</STRONG>
<DD><A HREF="#5928">propercount</A>
<DT><STRONG>properorder</STRONG>
<DD><A HREF="#8383">identify</A>
<DT><STRONG>protocol</STRONG>
<DD><DL COMPACT>
<DT><STRONG>lowlevel</STRONG>
<DD><A HREF="#18476">Embedding FORM in other</A>
</DL>
<DT><STRONG>pushhide</STRONG>
<DD><A HREF="#5703">pophide</A>
 | <A HREF="#5947">pushhide</A>
<DT><STRONG>putfirst_</STRONG>
<DD><A HREF="#14684">putfirst_</A>
<DT><STRONG>putinside</STRONG>
<DD><A HREF="#5961">putinside</A>
<DT><STRONG>quadfortran</STRONG>
<DD><A HREF="#8103">format</A>
 | <A HREF="#16387">Dictionaries</A>
<DT><STRONG>quadruplefortran</STRONG>
<DD><A HREF="#8088">format</A>
<DT><STRONG>question mark</STRONG>
<DD><A HREF="#2738">Pattern matching</A>
<DT><STRONG>quote</STRONG>
<DD><A HREF="#741">The preprocessor variables</A>
 | <A HREF="#1246">#procedure</A>
<DT><STRONG>random</STRONG>
<DD><A HREF="#14704">ranperm_</A>
<DT><STRONG>random_</STRONG>
<DD><A HREF="#1349">#setrandom</A>
 | <A HREF="#14692">random_</A>
<DT><STRONG>range</STRONG>
<DD><A HREF="#6891">transform</A>
 | <A HREF="#16364">Dictionaries</A>
 | <A HREF="#16411">Dictionaries</A>
<DT><STRONG>ranperm_</STRONG>
<DD><A HREF="#14698">ranperm_</A>
<DT><STRONG>ratio</STRONG>
<DD><A HREF="#5977">ratio</A>
<DT><STRONG>rational</STRONG>
<DD><A HREF="#7951">format</A>
<DT><STRONG>rational polynomials</STRONG>
<DD><A HREF="#18683">Spectators</A>
<DT><STRONG>rcyclesymmetrize</STRONG>
<DD><A HREF="#6035">rcyclesymmetrize</A>
<DT><STRONG>reading</STRONG>
<DD><A HREF="#1190">#include</A>
<DT><STRONG>real</STRONG>
<DD><A HREF="#289">Symbols</A>
 | <A HREF="#363">Functions</A>
 | <A HREF="#7635">cfunctions</A>
 | <A HREF="#8219">functions</A>
 | <A HREF="#10455">symbols</A>
 | <A HREF="#16408">Dictionaries</A>
 | <A HREF="#16686">A few notes on</A>
<DT><STRONG>recovery</STRONG>
<DD><A HREF="#2634">Checkpoints</A>
<DT><STRONG>recovery option</STRONG>
<DD><A HREF="#2652">Checkpoints</A>
<DT><STRONG>recursively</STRONG>
<DD><A HREF="#4027">fill</A>
<DT><STRONG>redefine</STRONG>
<DD><A HREF="#1022">#do</A>
 | <A HREF="#6053">redefine</A>
<DT><STRONG>reduce</STRONG>
<DD><A HREF="#8181">format</A>
 | <A HREF="#16658">A few notes on</A>
<DT><STRONG>rem_</STRONG>
<DD><A HREF="#14709">rem_</A>
 | <A HREF="#15935">Polynomials and Factorization</A>
<DT><STRONG>remainder</STRONG>
<DD><A HREF="#804">The preprocessor calculator</A>
 | <A HREF="#6388">splitfirstarg</A>
<DT><STRONG>removespectator</STRONG>
<DD><A HREF="#18674">Spectators</A>
<DT><STRONG>renumber</STRONG>
<DD><A HREF="#473">Dummy indices</A>
 | <A HREF="#6087">renumber</A>
<DT><STRONG>repeat</STRONG>
<DD><A HREF="#3868">endrepeat</A>
 | <A HREF="#6109">repeat</A>
<DT><STRONG>repeat environment</STRONG>
<DD><A HREF="#6110">repeat</A>
<DT><STRONG>replace</STRONG>
<DD><A HREF="#10883">transform</A>
<DT><STRONG>replace_</STRONG>
<DD><A HREF="#2773">Pattern matching</A>
 | <A HREF="#6997">tryreplace</A>
 | <A HREF="#14526">id_</A>
 | <A HREF="#14715">replace_</A>
<DT><STRONG>replaceloop</STRONG>
<DD><A HREF="#8572">if</A>
 | <A HREF="#6143">replaceloop</A>
<DT><STRONG>replacement</STRONG>
<DD><A HREF="#14718">replace_</A>
<DT><STRONG>representation</STRONG>
<DD><DL COMPACT>
<DT><STRONG>textual</STRONG>
<DD><A HREF="#2872">The dollar variables</A>
</DL>
<DT><STRONG>resettimeonclear</STRONG>
<DD><A HREF="#2600">Modules</A>
 | <A HREF="#17662">The setup</A>
<DT><STRONG>restriction</STRONG>
<DD><DL COMPACT>
<DT><STRONG>power</STRONG>
<DD><A HREF="#290">Symbols</A>
</DL>
<DT><STRONG>restrictions</STRONG>
<DD><A HREF="#515">Restrictions</A>
<DT><STRONG>reverse</STRONG>
<DD><A HREF="#10971">transform</A>
<DT><STRONG>reverse cycle symmetric</STRONG>
<DD><A HREF="#7725">cfunctions</A>
 | <A HREF="#8310">functions</A>
<DT><STRONG>reverse cycle symmetrize</STRONG>
<DD><A HREF="#6038">rcyclesymmetrize</A>
<DT><STRONG>reverse_</STRONG>
<DD><A HREF="#14724">reverse_</A>
<DT><STRONG>root of unity</STRONG>
<DD><A HREF="#6447">stuffle</A>
 | <A HREF="#10501">symbols</A>
<DT><STRONG>root_</STRONG>
<DD><A HREF="#14728">root_</A>
<DT><STRONG>rounding</STRONG>
<DD><A HREF="#14543">integer_</A>
<DT><STRONG>run</STRONG>
<DD><A HREF="#2647">Checkpoints</A>
<DT><STRONG>run a script</STRONG>
<DD><A HREF="#2643">Checkpoints</A>
<DT><STRONG>running FORM</STRONG>
<DD><A HREF="#167">Running FORM</A>
<DT><STRONG>runtime error</STRONG>
<DD><A HREF="#2868">The dollar variables</A>
<DT><STRONG>save</STRONG>
<DD><A HREF="#6216">save</A>
<DT><STRONG>save files</STRONG>
<DD><A HREF="#2655">Checkpoints</A>
<DT><STRONG>saved file</STRONG>
<DD><A HREF="#4821">load</A>
<DT><STRONG>scalar objects</STRONG>
<DD><A HREF="#2756">Pattern matching</A>
<DT><STRONG>Schoonschip</STRONG>
<DD><A HREF="#2749">Pattern matching</A>
 | <A HREF="#6017">ratio</A>
 | <A HREF="#6667">tensors</A>
 | <A HREF="#14500">g6_</A>
 | <A HREF="#14505">g7_</A>
 | <A HREF="#14762">sump_</A>
 | <A HREF="#16657">A few notes on</A>
<DT><STRONG>scratch files</STRONG>
<DD><A HREF="#2654">Checkpoints</A>
<DT><STRONG>ScratchSize</STRONG>
<DD><A HREF="#2576">Modules</A>
 | <A HREF="#4381">hide</A>
 | <A HREF="#17678">The setup</A>
<DT><STRONG>screen</STRONG>
<DD><A HREF="#10029">print</A>
<DT><STRONG>script</STRONG>
<DD><A HREF="#1332">#setexternalattr</A>
<DT><STRONG>select</STRONG>
<DD><A HREF="#8362">identify</A>
 | <A HREF="#8529">if</A>
 | <A HREF="#6239">select</A>
<DT><STRONG>selectargs</STRONG>
<DD><A HREF="#11085">transform</A>
<DT><STRONG>semicolon</STRONG>
<DD><A HREF="#1211">#message</A>
 | <A HREF="#1445">#write</A>
 | <A HREF="#4516">if</A>
<DT><STRONG>set</STRONG>
<DD><A HREF="#2781">Pattern matching</A>
 | <A HREF="#8369">identify</A>
 | <A HREF="#6259">set</A>
 | <A HREF="#6371">splitarg</A>
 | <A HREF="#6389">splitfirstarg</A>
 | <A HREF="#6406">splitlastarg</A>
<DL COMPACT>
<DT><STRONG>ambiguous</STRONG>
<DD><A HREF="#2792">Pattern matching</A>
<DT><STRONG>corresponding element</STRONG>
<DD><A HREF="#2802">Pattern matching</A>
<DT><STRONG>dynamical</STRONG>
<DD><A HREF="#825">The preprocessor calculator</A>
 | <A HREF="#2784">Pattern matching</A>
<DT><STRONG>inside</STRONG>
<DD><A HREF="#433">Sets</A>
<DT><STRONG>mixed</STRONG>
<DD><A HREF="#6263">set</A>
<DT><STRONG>ordered</STRONG>
<DD><A HREF="#6264">set</A>
<DT><STRONG>outside</STRONG>
<DD><A HREF="#434">Sets</A>
</DL>
<DT><STRONG>set of indices</STRONG>
<DD><A HREF="#2789">Pattern matching</A>
<DT><STRONG>Set of symbols</STRONG>
<DD><A HREF="#2788">Pattern matching</A>
<DT><STRONG>setexitflag</STRONG>
<DD><A HREF="#6276">setexitflag</A>
<DT><STRONG>setfun_</STRONG>
<DD><A HREF="#14732">setfun_</A>
<DT><STRONG>setrandom</STRONG>
<DD><A HREF="#14707">ranperm_</A>
<DT><STRONG>sets</STRONG>
<DD><A HREF="#384">Sets</A>
<DL COMPACT>
<DT><STRONG>array</STRONG>
<DD><A HREF="#2793">Pattern matching</A>
<DT><STRONG>implicitly declared</STRONG>
<DD><A HREF="#426">Sets</A>
<DT><STRONG>named</STRONG>
<DD><A HREF="#440">Sets</A>
</DL>
<DT><STRONG>settings</STRONG>
<DD><A HREF="#5336">off</A>
<DT><STRONG>setup</STRONG>
<DD><A HREF="#16828">Sorting and statistics</A>
 | <A HREF="#16886">The setup</A>
<DL COMPACT>
<DT><STRONG>bracketindexsize</STRONG>
<DD><A HREF="#17276">The setup</A>
<DT><STRONG>commentchar</STRONG>
<DD><A HREF="#17293">The setup</A>
<DT><STRONG>compresssize</STRONG>
<DD><A HREF="#17307">The setup</A>
<DT><STRONG>constindex</STRONG>
<DD><A HREF="#17322">The setup</A>
<DT><STRONG>continuationlines</STRONG>
<DD><A HREF="#17338">The setup</A>
<DT><STRONG>define</STRONG>
<DD><A HREF="#17354">The setup</A>
<DT><STRONG>dotchar</STRONG>
<DD><A HREF="#17371">The setup</A>
<DT><STRONG>filepatches</STRONG>
<DD><A HREF="#17898">The setup</A>
<DT><STRONG>functionlevels</STRONG>
<DD><A HREF="#17387">The setup</A>
<DT><STRONG>hidesize</STRONG>
<DD><A HREF="#17401">The setup</A>
<DT><STRONG>incdir</STRONG>
<DD><A HREF="#17415">The setup</A>
 | <A HREF="#17616">The setup</A>
<DT><STRONG>insidefirst</STRONG>
<DD><A HREF="#17434">The setup</A>
<DT><STRONG>jumpratio</STRONG>
<DD><A HREF="#17448">The setup</A>
<DT><STRONG>largepatches</STRONG>
<DD><A HREF="#17912">The setup</A>
<DT><STRONG>largesize</STRONG>
<DD><A HREF="#17968">The setup</A>
<DT><STRONG>maxnumbersize</STRONG>
<DD><A HREF="#17463">The setup</A>
<DT><STRONG>maxtermsize</STRONG>
<DD><A HREF="#17480">The setup</A>
<DT><STRONG>maxwildcards</STRONG>
<DD><A HREF="#17499">The setup</A>
<DT><STRONG>nospacesinnumbers</STRONG>
<DD><A HREF="#17513">The setup</A>
<DT><STRONG>numstorecaches</STRONG>
<DD><A HREF="#17533">The setup</A>
<DT><STRONG>nwritestatistics</STRONG>
<DD><A HREF="#17547">The setup</A>
<DT><STRONG>nwritethreadstatistics</STRONG>
<DD><A HREF="#17561">The setup</A>
<DT><STRONG>oldorder</STRONG>
<DD><A HREF="#17578">The setup</A>
<DT><STRONG>parentheses</STRONG>
<DD><A HREF="#17592">The setup</A>
<DT><STRONG>path</STRONG>
<DD><A HREF="#17425">The setup</A>
 | <A HREF="#17606">The setup</A>
<DT><STRONG>procedureEetension</STRONG>
<DD><A HREF="#17626">The setup</A>
<DT><STRONG>processbucketsize</STRONG>
<DD><A HREF="#17643">The setup</A>
<DT><STRONG>resettimeonclear</STRONG>
<DD><A HREF="#17661">The setup</A>
<DT><STRONG>scratchsize</STRONG>
<DD><A HREF="#17677">The setup</A>
<DT><STRONG>sizestorecache</STRONG>
<DD><A HREF="#17697">The setup</A>
<DT><STRONG>smallextension</STRONG>
<DD><A HREF="#17954">The setup</A>
<DT><STRONG>smallsize</STRONG>
<DD><A HREF="#17940">The setup</A>
<DT><STRONG>sortiosize</STRONG>
<DD><A HREF="#17982">The setup</A>
<DT><STRONG>sorttype</STRONG>
<DD><A HREF="#17716">The setup</A>
<DT><STRONG>tempdir</STRONG>
<DD><A HREF="#17735">The setup</A>
<DT><STRONG>tempsortdir</STRONG>
<DD><A HREF="#17752">The setup</A>
<DT><STRONG>termsinsmall</STRONG>
<DD><A HREF="#17926">The setup</A>
<DT><STRONG>threadbucketsize</STRONG>
<DD><A HREF="#17770">The setup</A>
<DT><STRONG>threadloadbalancing</STRONG>
<DD><A HREF="#17786">The setup</A>
<DT><STRONG>threads</STRONG>
<DD><A HREF="#17802">The setup</A>
<DT><STRONG>threadscratchoutsize</STRONG>
<DD><A HREF="#17818">The setup</A>
<DT><STRONG>threadscratchsize</STRONG>
<DD><A HREF="#17833">The setup</A>
<DT><STRONG>totalsize</STRONG>
<DD><A HREF="#17848">The setup</A>
<DT><STRONG>workspace</STRONG>
<DD><A HREF="#17866">The setup</A>
<DT><STRONG>wtimestats</STRONG>
<DD><A HREF="#17880">The setup</A>
</DL>
<DT><STRONG>setup file</STRONG>
<DD><A HREF="#265">Names</A>
<DT><STRONG>shell</STRONG>
<DD><A HREF="#1330">#setexternalattr</A>
 | <A HREF="#1331">#setexternalattr</A>
 | <A HREF="#2648">Checkpoints</A>
 | <A HREF="#18391">External communication</A>
 | <A HREF="#18442">#setexternalattr</A>
 | <A HREF="#18443">#setexternalattr</A>
<DT><STRONG>short integer</STRONG>
<DD><A HREF="#4094">fixindex</A>
<DT><STRONG>shorthand</STRONG>
<DD><A HREF="#4612">if</A>
 | <A HREF="#6116">repeat</A>
<DT><STRONG>SHOWINPUT_</STRONG>
<DD><A HREF="#752">The preprocessor variables</A>
 | <A HREF="#1360">#show</A>
<DT><STRONG>shuffle</STRONG>
<DD><A HREF="#4899">merge</A>
 | <A HREF="#6444">stuffle</A>
<DT><STRONG>sig_</STRONG>
<DD><A HREF="#14736">sig_</A>
<DT><STRONG>SIGKILL signal</STRONG>
<DD><A HREF="#1327">#setexternalattr</A>
 | <A HREF="#18438">#setexternalattr</A>
<DT><STRONG>sign_</STRONG>
<DD><A HREF="#14740">sign_</A>
<DT><STRONG>signal</STRONG>
<DD><A HREF="#18171">TFORM</A>
<DT><STRONG>sin_</STRONG>
<DD><A HREF="#14822">Extra reserved names</A>
<DT><STRONG>single term mode</STRONG>
<DD><A HREF="#10044">print</A>
<DT><STRONG>sinh_</STRONG>
<DD><A HREF="#14864">Extra reserved names</A>
<DT><STRONG>sizeof_</STRONG>
<DD><A HREF="#14744">sizeof_</A>
<DT><STRONG>sizestorecache</STRONG>
<DD><A HREF="#17698">The setup</A>
<DT><STRONG>skip</STRONG>
<DD><A HREF="#5170">nskip</A>
 | <A HREF="#6316">skip</A>
<DT><STRONG>skipped expressions</STRONG>
<DD><A HREF="#4383">hide</A>
<DT><STRONG>slow</STRONG>
<DD><A HREF="#15540">Brackets</A>
<DT><STRONG>small buffer</STRONG>
<DD><A HREF="#16802">Sorting and statistics</A>
 | <A HREF="#17126">The setup</A>
<DT><STRONG>small extension</STRONG>
<DD><A HREF="#16804">Sorting and statistics</A>
<DT><STRONG>smallextension</STRONG>
<DD><A HREF="#16806">Sorting and statistics</A>
 | <A HREF="#17130">The setup</A>
 | <A HREF="#17955">The setup</A>
<DT><STRONG>smallsize</STRONG>
<DD><A HREF="#17128">The setup</A>
 | <A HREF="#17941">The setup</A>
<DT><STRONG>sort</STRONG>
<DD><A HREF="#6318">skip</A>
 | <A HREF="#6337">sort</A>
 | <A HREF="#6686">term</A>
<DL COMPACT>
<DT><STRONG>final stage</STRONG>
<DD><A HREF="#15575">Brackets</A>
</DL>
<DT><STRONG>sort file</STRONG>
<DD><A HREF="#16818">Sorting and statistics</A>
<DT><STRONG>sorting</STRONG>
<DD><A HREF="#15582">Brackets</A>
 | <A HREF="#16794">Sorting and statistics</A>
<DT><STRONG>sortiosize</STRONG>
<DD><A HREF="#16826">Sorting and statistics</A>
 | <A HREF="#17139">The setup</A>
 | <A HREF="#17983">The setup</A>
<DT><STRONG>sorttype</STRONG>
<DD><A HREF="#17717">The setup</A>
<DT><STRONG>spaces</STRONG>
<DD><A HREF="#7979">format</A>
<DT><STRONG>sparse</STRONG>
<DD><A HREF="#3575">deallocatetable</A>
 | <A HREF="#6613">table</A>
 | <A HREF="#16051">The TableBase</A>
 | <A HREF="#16087">addto</A>
<DT><STRONG>specifications</STRONG>
<DD><A HREF="#2580">Modules</A>
<DT><STRONG>spin line</STRONG>
<DD><A HREF="#6876">tracen</A>
 | <A HREF="#16497">Dirac algebra</A>
<DT><STRONG>spinline</STRONG>
<DD><A HREF="#3347">chisholm</A>
<DT><STRONG>splitarg</STRONG>
<DD><A HREF="#3959">factarg</A>
 | <A HREF="#5113">normalize</A>
 | <A HREF="#6357">splitarg</A>
 | <A HREF="#6386">splitfirstarg</A>
 | <A HREF="#6404">splitlastarg</A>
<DT><STRONG>splitfirstarg</STRONG>
<DD><A HREF="#6385">splitfirstarg</A>
<DT><STRONG>splitlastarg</STRONG>
<DD><A HREF="#6403">splitlastarg</A>
<DT><STRONG>sqrt_</STRONG>
<DD><A HREF="#14810">Extra reserved names</A>
<DT><STRONG>square root</STRONG>
<DD><A HREF="#813">The preprocessor calculator</A>
<DT><STRONG>stack overflow</STRONG>
<DD><A HREF="#4028">fill</A>
<DT><STRONG>stages in the sorting</STRONG>
<DD><A HREF="#16823">Sorting and statistics</A>
<DT><STRONG>standard error</STRONG>
<DD><A HREF="#1337">#setexternalattr</A>
<DT><STRONG>standard input</STRONG>
<DD><A HREF="#1097">#external</A>
<DT><STRONG>standard output</STRONG>
<DD><A HREF="#1096">#external</A>
<DT><STRONG>statements</STRONG>
<DD><A HREF="#2571">Modules</A>
<DT><STRONG>stderr</STRONG>
<DD><A HREF="#1336">#setexternalattr</A>
 | <A HREF="#18447">#setexternalattr</A>
<DT><STRONG>storage  file</STRONG>
<DD><A HREF="#4338">global</A>
<DT><STRONG>storage file</STRONG>
<DD><A HREF="#3601">delete</A>
<DT><STRONG>store file</STRONG>
<DD><A HREF="#6217">save</A>
<DT><STRONG>strict</STRONG>
<DD><A HREF="#6620">table</A>
<DT><STRONG>string</STRONG>
<DD><A HREF="#1447">#write</A>
<DT><STRONG>strong typing</STRONG>
<DD><A HREF="#447">The autodeclare conventions</A>
<DT><STRONG>stub</STRONG>
<DD><A HREF="#16155">testuse</A>
<DT><STRONG>stub function</STRONG>
<DD><A HREF="#16068">The TableBase</A>
<DT><STRONG>student</STRONG>
<DD><A HREF="#16711">A few notes on</A>
<DT><STRONG>stuffle</STRONG>
<DD><A HREF="#6304">shuffle</A>
<DT><STRONG>subexpressions</STRONG>
<DD><A HREF="#17176">The setup</A>
<DT><STRONG>substaidentify</STRONG>
<DD><A HREF="#14528">id_</A>
<DT><STRONG>substitution</STRONG>
<DD><DL COMPACT>
<DT><STRONG>delayed</STRONG>
<DD><A HREF="#998">#define</A>
 | <A HREF="#2882">The dollar variables</A>
</DL>
<DT><STRONG>substitutions</STRONG>
<DD><A HREF="#2733">Pattern matching</A>
<DT><STRONG>subtraction</STRONG>
<DD><A HREF="#801">The preprocessor calculator</A>
<DT><STRONG>SUBVERSION_</STRONG>
<DD><A HREF="#747">The preprocessor variables</A>
<DT><STRONG>sum</STRONG>
<DD><A HREF="#411">Sets</A>
 | <A HREF="#6459">sum</A>
 | <A HREF="#14753">sum_</A>
<DT><STRONG>sum_</STRONG>
<DD><A HREF="#14750">sum_</A>
<DT><STRONG>summation</STRONG>
<DD><DL COMPACT>
<DT><STRONG>Einstein</STRONG>
<DD><A HREF="#328">Indices</A>
 | <A HREF="#375">Functions</A>
 | <A HREF="#502">Kronecker delta's</A>
</DL>
<DT><STRONG>sump_</STRONG>
<DD><A HREF="#14757">sump_</A>
<DT><STRONG>sums</STRONG>
<DD><DL COMPACT>
<DT><STRONG>harmonic</STRONG>
<DD><A HREF="#3080">argimplode</A>
</DL>
<DT><STRONG>superpatch</STRONG>
<DD><A HREF="#17140">The setup</A>
<DT><STRONG>symbol</STRONG>
<DD><A HREF="#6494">symbols</A>
<DT><STRONG>symbol_</STRONG>
<DD><A HREF="#401">Sets</A>
<DT><STRONG>symbols</STRONG>
<DD><A HREF="#281">Symbols</A>
 | <A HREF="#7473">auto, autodeclare</A>
 | <A HREF="#7868">dimension</A>
 | <A HREF="#15655">Output optimization</A>
<DL COMPACT>
<DT><STRONG>built in</STRONG>
<DD><A HREF="#295">Symbols</A>
</DL>
<DT><STRONG>symmetric</STRONG>
<DD><A HREF="#7680">cfunctions</A>
 | <A HREF="#8264">functions</A>
<DL COMPACT>
<DT><STRONG>anti</STRONG>
<DD><A HREF="#6189">replaceloop</A>
<DT><STRONG>cycle</STRONG>
<DD><A HREF="#8295">functions</A>
 | <A HREF="#6184">replaceloop</A>
<DT><STRONG>reverse cycle</STRONG>
<DD><A HREF="#8311">functions</A>
</DL>
<DT><STRONG>symmetrization</STRONG>
<DD><A HREF="#10624">symmetrize</A>
<DT><STRONG>symmetrize</STRONG>
<DD><A HREF="#6036">rcyclesymmetrize</A>
 | <A HREF="#6545">symmetrize</A>
 | <A HREF="#16531">Dirac algebra</A>
<DL COMPACT>
<DT><STRONG>reverse cycle</STRONG>
<DD><A HREF="#6039">rcyclesymmetrize</A>
</DL>
<DT><STRONG>SYSTEMERROR_</STRONG>
<DD><A HREF="#771">The preprocessor variables</A>
 | <A HREF="#1400">#system</A>
<DT><STRONG>tab</STRONG>
<DD><A HREF="#1436">#write</A>
<DT><STRONG>table</STRONG>
<DD><A HREF="#4021">fill</A>
 | <A HREF="#4073">fillexpression</A>
 | <A HREF="#5191">ntable</A>
 | <A HREF="#5869">printtable</A>
 | <A HREF="#6262">set</A>
 | <A HREF="#6606">table</A>
 | <A HREF="#14319">Functions</A>
 | <A HREF="#16043">The TableBase</A>
<DL COMPACT>
<DT><STRONG>check</STRONG>
<DD><A HREF="#10654">table</A>
<DT><STRONG>commuting</STRONG>
<DD><A HREF="#3531">ctable</A>
<DT><STRONG>matrix  like</STRONG>
<DD><A HREF="#6614">table</A>
<DT><STRONG>matrix like</STRONG>
<DD><A HREF="#10688">table</A>
<DT><STRONG>noncommuting</STRONG>
<DD><A HREF="#5190">ntable</A>
<DT><STRONG>onefill</STRONG>
<DD><A HREF="#10721">table</A>
<DT><STRONG>relax</STRONG>
<DD><A HREF="#10667">table</A>
<DT><STRONG>sparse</STRONG>
<DD><A HREF="#3576">deallocatetable</A>
 | <A HREF="#10680">table</A>
 | <A HREF="#6615">table</A>
<DT><STRONG>strict</STRONG>
<DD><A HREF="#10695">table</A>
<DT><STRONG>zerofill</STRONG>
<DD><A HREF="#10708">table</A>
</DL>
<DT><STRONG>table elements</STRONG>
<DD><A HREF="#16042">The TableBase</A>
<DT><STRONG>table index</STRONG>
<DD><A HREF="#14320">Functions</A>
<DT><STRONG>table indices</STRONG>
<DD><A HREF="#6611">table</A>
<DT><STRONG>table_</STRONG>
<DD><A HREF="#14764">table_</A>
<DT><STRONG>tablebase</STRONG>
<DD><A HREF="#6652">tablebase</A>
 | <A HREF="#6703">testuse</A>
 | <A HREF="#14774">tbl_</A>
 | <A HREF="#16040">The TableBase</A>
<DT><STRONG>tables</STRONG>
<DD><A HREF="#370">Functions</A>
<DT><STRONG>tan_</STRONG>
<DD><A HREF="#14834">Extra reserved names</A>
<DT><STRONG>tanh_</STRONG>
<DD><A HREF="#14876">Extra reserved names</A>
<DT><STRONG>tbl_</STRONG>
<DD><A HREF="#14771">tbl_</A>
 | <A HREF="#16047">The TableBase</A>
 | <A HREF="#16069">The TableBase</A>
 | <A HREF="#16156">testuse</A>
<DT><STRONG>tempdir</STRONG>
<DD><A HREF="#17736">The setup</A>
<DT><STRONG>temporary  variables</STRONG>
<DD><A HREF="#15648">Output optimization</A>
<DT><STRONG>temporary files</STRONG>
<DD><A HREF="#16819">Sorting and statistics</A>
<DT><STRONG>tempsortdir</STRONG>
<DD><A HREF="#17753">The setup</A>
<DT><STRONG>tensor</STRONG>
<DD><A HREF="#5208">ntensors</A>
 | <A HREF="#6261">set</A>
 | <A HREF="#6666">tensors</A>
 | <A HREF="#14318">Functions</A>
<DL COMPACT>
<DT><STRONG>commuting</STRONG>
<DD><A HREF="#3546">ctensors</A>
<DT><STRONG>Levi-Civita</STRONG>
<DD><A HREF="#3456">contract</A>
 | <A HREF="#14441">e_</A>
 | <A HREF="#16672">A few notes on</A>
<DT><STRONG>metric</STRONG>
<DD><A HREF="#16662">A few notes on</A>
<DT><STRONG>noncommuting</STRONG>
<DD><A HREF="#5207">ntensors</A>
</DL>
<DT><STRONG>tensors</STRONG>
<DD><A HREF="#369">Functions</A>
 | <A HREF="#373">Functions</A>
<DL COMPACT>
<DT><STRONG>commuting</STRONG>
<DD><A HREF="#7585">auto, autodeclare</A>
 | <A HREF="#7613">auto, autodeclare</A>
<DT><STRONG>noncommuting</STRONG>
<DD><A HREF="#7599">auto, autodeclare</A>
 | <A HREF="#8443">identify</A>
</DL>
<DT><STRONG>term</STRONG>
<DD><A HREF="#3893">endterm</A>
 | <A HREF="#6338">sort</A>
 | <A HREF="#6682">term</A>
<DT><STRONG>term_</STRONG>
<DD><A HREF="#14777">term_</A>
<DT><STRONG>terminate</STRONG>
<DD><A HREF="#1054">#enddo</A>
<DT><STRONG>termination</STRONG>
<DD><A HREF="#2628">Checkpoints</A>
 | <A HREF="#6277">setexitflag</A>
<DL COMPACT>
<DT><STRONG>premature</STRONG>
<DD><A HREF="#6129">repeat</A>
</DL>
<DT><STRONG>terms</STRONG>
<DD><A HREF="#246">Variables</A>
<DT><STRONG>termsin</STRONG>
<DD><A HREF="#1605">#if</A>
 | <A HREF="#1619">#if</A>
<DT><STRONG>termsin_</STRONG>
<DD><A HREF="#14783">termsin_</A>
<DT><STRONG>termsinbracket_</STRONG>
<DD><A HREF="#14789">termsinbracket_</A>
<DT><STRONG>termsinsmall</STRONG>
<DD><A HREF="#17129">The setup</A>
 | <A HREF="#17927">The setup</A>
<DT><STRONG>testuse</STRONG>
<DD><A HREF="#6702">testuse</A>
 | <A HREF="#16070">The TableBase</A>
 | <A HREF="#16097">apply</A>
 | <A HREF="#16154">testuse</A>
 | <A HREF="#16163">use</A>
<DT><STRONG>TFORM</STRONG>
<DD><A HREF="#2917">Dollar variables in a</A>
 | <A HREF="#4705">inparallel</A>
 | <A HREF="#5140">notinparallel</A>
 | <A HREF="#6713">threadbucketsize</A>
 | <A HREF="#18147">The parallel version</A>
 | <A HREF="#18162">TFORM</A>
 | <A HREF="#18684">Spectators</A>
<DT><STRONG>theta_</STRONG>
<DD><A HREF="#14795">theta_</A>
<DT><STRONG>thetap_</STRONG>
<DD><A HREF="#14799">thetap_</A>
<DT><STRONG>thread</STRONG>
<DD><A HREF="#2922">Dollar variables in a</A>
 | <A HREF="#8896">moduleoption</A>
<DT><STRONG>threadbucketsize</STRONG>
<DD><A HREF="#6712">threadbucketsize</A>
 | <A HREF="#17771">The setup</A>
 | <A HREF="#18173">TFORM</A>
<DT><STRONG>threadloadbalancing</STRONG>
<DD><A HREF="#17787">The setup</A>
 | <A HREF="#18176">TFORM</A>
<DT><STRONG>threads</STRONG>
<DD><A HREF="#17803">The setup</A>
<DT><STRONG>threadscratchoutsize</STRONG>
<DD><A HREF="#17819">The setup</A>
<DT><STRONG>threadscratchsize</STRONG>
<DD><A HREF="#17834">The setup</A>
<DT><STRONG>time</STRONG>
<DD><A HREF="#2639">Checkpoints</A>
<DT><STRONG>time_</STRONG>
<DD><A HREF="#772">The preprocessor variables</A>
<DT><STRONG>timer_</STRONG>
<DD><A HREF="#773">The preprocessor variables</A>
<DT><STRONG>tointegralnotation</STRONG>
<DD><A HREF="#10941">transform</A>
<DT><STRONG>tolyndon</STRONG>
<DD><A HREF="#11028">transform</A>
<DT><STRONG>topologies_</STRONG>
<DD><A HREF="#14613">node_</A>
 | <A HREF="#14803">topologies_</A>
<DT><STRONG>topolynomial</STRONG>
<DD><A HREF="#3939">extrasymbols</A>
 | <A HREF="#15663">Output optimization</A>
<DT><STRONG>tospectator</STRONG>
<DD><A HREF="#18666">Spectators</A>
<DT><STRONG>tosumnotation</STRONG>
<DD><A HREF="#10925">transform</A>
<DT><STRONG>totalsize</STRONG>
<DD><A HREF="#181">Running FORM</A>
 | <A HREF="#9945">on</A>
 | <A HREF="#17849">The setup</A>
<DT><STRONG>totensor</STRONG>
<DD><A HREF="#6766">totensor</A>
 | <A HREF="#6813">tovector</A>
<DL COMPACT>
<DT><STRONG>!set</STRONG>
<DD><A HREF="#10781">totensor</A>
<DT><STRONG>!vector</STRONG>
<DD><A HREF="#10768">totensor</A>
<DT><STRONG>functions</STRONG>
<DD><A HREF="#10755">totensor</A>
<DT><STRONG>nosquare</STRONG>
<DD><A HREF="#10742">totensor</A>
</DL>
<DT><STRONG>tovector</STRONG>
<DD><A HREF="#6812">tovector</A>
<DT><STRONG>trace</STRONG>
<DD><A HREF="#16504">Dirac algebra</A>
<DT><STRONG>trace contractions</STRONG>
<DD><A HREF="#7870">dimension</A>
<DT><STRONG>trace line</STRONG>
<DD><A HREF="#6839">trace4</A>
<DT><STRONG>trace4</STRONG>
<DD><A HREF="#6837">trace4</A>
 | <A HREF="#16577">Dirac algebra</A>
 | <A HREF="#16527">Dirac algebra</A>
<DL COMPACT>
<DT><STRONG>contract</STRONG>
<DD><A HREF="#10794">trace4</A>
<DT><STRONG>nocontract</STRONG>
<DD><A HREF="#10809">trace4</A>
<DT><STRONG>nosymmetrize</STRONG>
<DD><A HREF="#10824">trace4</A>
<DT><STRONG>notrick</STRONG>
<DD><A HREF="#10839">trace4</A>
</DL>
<DT><STRONG>tracen</STRONG>
<DD><A HREF="#6874">tracen</A>
 | <A HREF="#16592">Dirac algebra</A>
<DT><STRONG>traces</STRONG>
<DD><A HREF="#348">Indices</A>
<DT><STRONG>traffic jam</STRONG>
<DD><A HREF="#16822">Sorting and statistics</A>
<DT><STRONG>transform</STRONG>
<DD><A HREF="#6889">transform</A>
<DL COMPACT>
<DT><STRONG>addargs</STRONG>
<DD><A HREF="#11042">transform</A>
<DT><STRONG>cycle</STRONG>
<DD><A HREF="#10998">transform</A>
<DT><STRONG>decode</STRONG>
<DD><A HREF="#10910">transform</A>
<DT><STRONG>dedup</STRONG>
<DD><A HREF="#10984">transform</A>
<DT><STRONG>dropargs</STRONG>
<DD><A HREF="#11070">transform</A>
<DT><STRONG>encode</STRONG>
<DD><A HREF="#10896">transform</A>
<DT><STRONG>explode</STRONG>
<DD><A HREF="#10942">transform</A>
<DT><STRONG>implode</STRONG>
<DD><A HREF="#10926">transform</A>
<DT><STRONG>islyndon</STRONG>
<DD><A HREF="#11012">transform</A>
<DT><STRONG>mulargs</STRONG>
<DD><A HREF="#11056">transform</A>
<DT><STRONG>permute</STRONG>
<DD><A HREF="#10956">transform</A>
<DT><STRONG>replace</STRONG>
<DD><A HREF="#10882">transform</A>
<DT><STRONG>reverse</STRONG>
<DD><A HREF="#10970">transform</A>
<DT><STRONG>selectargs</STRONG>
<DD><A HREF="#11084">transform</A>
<DT><STRONG>tointegralnotation</STRONG>
<DD><A HREF="#10940">transform</A>
<DT><STRONG>tolyndon</STRONG>
<DD><A HREF="#11027">transform</A>
<DT><STRONG>tosumnotation</STRONG>
<DD><A HREF="#10924">transform</A>
</DL>
<DT><STRONG>translation</STRONG>
<DD><A HREF="#16347">Dictionaries</A>
<DT><STRONG>tree</STRONG>
<DD><DL COMPACT>
<DT><STRONG>balanced</STRONG>
<DD><A HREF="#10687">table</A>
<DT><STRONG>index</STRONG>
<DD><A HREF="#15552">Brackets</A>
</DL>
<DT><STRONG>tree of losers</STRONG>
<DD><A HREF="#16814">Sorting and statistics</A>
<DT><STRONG>tree sort</STRONG>
<DD><A HREF="#16796">Sorting and statistics</A>
<DT><STRONG>tricks</STRONG>
<DD><A HREF="#16584">Dirac algebra</A>
<DT><STRONG>tryreplace</STRONG>
<DD><A HREF="#6996">tryreplace</A>
<DT><STRONG>twolog</STRONG>
<DD><A HREF="#811">The preprocessor calculator</A>
<DT><STRONG>underscore</STRONG>
<DD><A HREF="#260">Names</A>
 | <A HREF="#270">Names</A>
 | <A HREF="#273">Names</A>
<DT><STRONG>underscore character</STRONG>
<DD><A HREF="#8146">format</A>
<DT><STRONG>unhide</STRONG>
<DD><A HREF="#4392">hide</A>
 | <A HREF="#5242">nunhide</A>
 | <A HREF="#7029">unhide</A>
<DT><STRONG>unit matrix</STRONG>
<DD><A HREF="#7050">unittrace</A>
 | <A HREF="#16514">Dirac algebra</A>
<DT><STRONG>unittrace</STRONG>
<DD><A HREF="#7049">unittrace</A>
<DT><STRONG>UNIX</STRONG>
<DD><A HREF="#168">Running FORM</A>
 | <A HREF="#1224">#pipe</A>
 | <A HREF="#1281">#remove</A>
 | <A HREF="#2736">Pattern matching</A>
 | <A HREF="#17124">The setup</A>
 | <A HREF="#18156">The parallel version</A>
 | <A HREF="#18457">An example</A>
<DT><STRONG>unpleasant</STRONG>
<DD><A HREF="#4727">inside</A>
<DT><STRONG>upper</STRONG>
<DD><A HREF="#3465">contract</A>
<DT><STRONG>use</STRONG>
<DD><A HREF="#16073">The TableBase</A>
 | <A HREF="#16098">apply</A>
 | <A HREF="#16157">testuse</A>
 | <A HREF="#16162">use</A>
<DT><STRONG>variable</STRONG>
<DD><DL COMPACT>
<DT><STRONG>dollar</STRONG>
<DD><A HREF="#4038">fill</A>
<DT><STRONG>preprocessor</STRONG>
<DD><A HREF="#992">#define</A>
 | <A HREF="#1272">#redefine</A>
 | <A HREF="#1354">#show</A>
 | <A HREF="#1417">#undefine</A>
 | <A HREF="#2871">The dollar variables</A>
</DL>
<DT><STRONG>variables</STRONG>
<DD><DL COMPACT>
<DT><STRONG>algebraic</STRONG>
<DD><A HREF="#2863">The dollar variables</A>
<DT><STRONG>dollar</STRONG>
<DD><A HREF="#250">Variables</A>
 | <A HREF="#268">Names</A>
 | <A HREF="#488">Dummy indices</A>
 | <A HREF="#2864">The dollar variables</A>
<DT><STRONG>lists</STRONG>
<DD><A HREF="#457">Name lists</A>
<DT><STRONG>preprocessor</STRONG>
<DD><A HREF="#248">Variables</A>
 | <A HREF="#259">Names</A>
 | <A HREF="#269">Names</A>
 | <A HREF="#1079">#endprocedure</A>
 | <A HREF="#2862">The dollar variables</A>
 | <A HREF="#6055">redefine</A>
<DT><STRONG>total number of</STRONG>
<DD><A HREF="#516">Restrictions</A>
</DL>
<DT><STRONG>vector</STRONG>
<DD><A HREF="#7064">vectors</A>
<DT><STRONG>vectors</STRONG>
<DD><A HREF="#306">Vectors</A>
 | <A HREF="#7487">auto, autodeclare</A>
<DT><STRONG>VERSION_</STRONG>
<DD><A HREF="#745">The preprocessor variables</A>
 | <A HREF="#1357">#show</A>
<DT><STRONG>vertices</STRONG>
<DD><A HREF="#6150">replaceloop</A>
<DT><STRONG>veto</STRONG>
<DD><A HREF="#2921">Dollar variables in a</A>
<DT><STRONG>virtual bracket</STRONG>
<DD><A HREF="#14426">dum_</A>
<DT><STRONG>warning</STRONG>
<DD><A HREF="#3401">collect</A>
 | <A HREF="#4032">fill</A>
<DT><STRONG>warnings</STRONG>
<DD><A HREF="#16367">Dictionaries</A>
<DT><STRONG>water</STRONG>
<DD><A HREF="#16710">A few notes on</A>
<DT><STRONG>weight</STRONG>
<DD><A HREF="#8499">if</A>
<DT><STRONG>while</STRONG>
<DD><A HREF="#3907">endwhile</A>
 | <A HREF="#7077">while</A>
<DT><STRONG>wildcard</STRONG>
<DD><A HREF="#2737">Pattern matching</A>
 | <A HREF="#2894">The dollar variables</A>
 | <A HREF="#4417">identify</A>
 | <A HREF="#14323">Functions</A>
<DL COMPACT>
<DT><STRONG>$-variable</STRONG>
<DD><A HREF="#2803">Pattern matching</A>
<DT><STRONG>argument field</STRONG>
<DD><A HREF="#2761">Pattern matching</A>
 | <A HREF="#14977">Functions</A>
<DT><STRONG>function</STRONG>
<DD><A HREF="#2742">Pattern matching</A>
<DT><STRONG>index</STRONG>
<DD><A HREF="#2746">Pattern matching</A>
<DT><STRONG>symbol</STRONG>
<DD><A HREF="#2755">Pattern matching</A>
<DT><STRONG>vector</STRONG>
<DD><A HREF="#2752">Pattern matching</A>
</DL>
<DT><STRONG>wildcarding</STRONG>
<DD><A HREF="#414">Sets</A>
<DT><STRONG>wildcards</STRONG>
<DD><A HREF="#6621">table</A>
<DT><STRONG>Windows</STRONG>
<DD><A HREF="#1285">#remove</A>
<DT><STRONG>word</STRONG>
<DD><A HREF="#16346">Dictionaries</A>
<DT><STRONG>worker</STRONG>
<DD><A HREF="#18163">TFORM</A>
<DT><STRONG>workers</STRONG>
<DD><A HREF="#18151">The parallel version</A>
<DT><STRONG>workspace</STRONG>
<DD><A HREF="#17867">The setup</A>
<DT><STRONG>write</STRONG>
<DD><A HREF="#7104">write</A>
<DL COMPACT>
<DT><STRONG>allnames</STRONG>
<DD><A HREF="#11106">write</A>
<DT><STRONG>allwarnings</STRONG>
<DD><A HREF="#11119">write</A>
<DT><STRONG>highfirst</STRONG>
<DD><A HREF="#11132">write</A>
<DT><STRONG>lowfirst</STRONG>
<DD><A HREF="#11145">write</A>
<DT><STRONG>names</STRONG>
<DD><A HREF="#11158">write</A>
<DT><STRONG>powerfirst</STRONG>
<DD><A HREF="#11171">write</A>
<DT><STRONG>setup</STRONG>
<DD><A HREF="#11184">write</A>
<DT><STRONG>shortstatistics</STRONG>
<DD><A HREF="#11197">write</A>
<DT><STRONG>shortstats</STRONG>
<DD><A HREF="#11210">write</A>
<DT><STRONG>statistics</STRONG>
<DD><A HREF="#11223">write</A>
<DT><STRONG>stats</STRONG>
<DD><A HREF="#11236">write</A>
<DT><STRONG>warnings</STRONG>
<DD><A HREF="#11249">write</A>
</DL>
<DT><STRONG>wtimestats</STRONG>
<DD><A HREF="#17881">The setup</A>
<DT><STRONG>Zen</STRONG>
<DD><A HREF="#16707">A few notes on</A>
<DT><STRONG>zero</STRONG>
<DD><DL COMPACT>
<DT><STRONG>dimension</STRONG>
<DD><A HREF="#8747">index, indices</A>
</DL>
<DT><STRONG>zlib</STRONG>
<DD><A HREF="#16056">The TableBase</A>

</DL>

<P>
<BR><HR>

</BODY>
</HTML>
